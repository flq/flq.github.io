{"data":{"markdownRemark":{"html":"<p>The DI container StructureMap has been coming along nicely lately, with version 2.5.1 <a href=\"http://sourceforge.net/projects/structuremap\">available as download</a>. I have been following closely its recent development, since it is providing some core object wiring functionality to my current project.</p>\n<p>A rather inviting pattern one can be lured into in DI container usage is using the container as service locator:</p>\n<pre><code>public ShippingScreenPresenter()\n{\n  _service = ObjectFactory.GetInstance&#x3C;IShippingService>();\n  _repository = ObjectFactory.GetInstance&#x3C;IRepository>();\n}\n</code></pre>\n<p>(This example is taken straight from Jeremy's <a href=\"http://codebetter.com/blogs/jeremy.miller/archive/2009/01/07/autowiring-in-structuremap-2-5.aspx\">recent StructureMap post</a>)</p>\n<p>As simple as it looks, splattering references to some \"ObjectFactory\" all over your code contradicts why you may be using the container in the first place: To simplify keeping concerns separated and removing responsibility of instantiation from classes, thereby simplifying coding against abstractions.</p>\n<p>StructureMap also has the notion of named instances, i.e. objects that are not retrieved as default but are rather stored under a key which must be used to retrieve said instance again. StructureMap can even provide you with named instances (or custom instances) when doing constructor-based injection. It may look something like that (taken from a StructureMap registry, the place to configure object dependencies):</p>\n<pre><code>ForRequestedType&#x3C;Form>()\n  .CacheBy(InstanceScope.Singleton)\n  .TheDefault.Is.OfConcreteType&#x3C;MainForm>()\n  .CtorDependency&#x3C;IApplicationModule>().Is(a=>a.TheInstanceNamed(\"MainModule\"));\n</code></pre>\n<p>In another scenario I have the problem that a class needs to obtain instances based on code that will provide an instance name. Here starting to use the ObjectFactory as service locator is ever so inviting. However, there is a simple way to provide some straightforward decoupling from the ObjectFactory. I delegate the resolving of object to an...ObjectResolver. This class is generic and the provided type argument sets what kind of types are being looked up. The implementation is very straightforward:</p>\n<pre><code>public class ObjectResolver&#x3C;T> where T : class\n{\n  public virtual T this[string key] { \n    get { \n      return ObjectFactory.GetNamedInstance&#x3C;T>(key); \n    }\n  }\n}\n</code></pre>\n<p>Now I can express the dependency to an ObjectResolver as with any other type in the constructor:</p>\n<pre><code>public class CommandMediator {\n  ctor(ObjectResolver&#x3C;ICommand> cmdResolver) {\n    ...\n  }\n\n  public void Foo() {\n    var cmd = cmdResolver[\"Save\"];\n    Assert.That(cmd != null);\n  }\n}\n</code></pre>\n<p>In what way is this better than doing service locating?</p>\n<ul>\n<li>For a common scenario, the tie to StructureMap for resolving named instances is reduced to a single class.</li>\n<li>If you wanted, replacing the lookup scheme for instances is fairly easy.</li>\n<li>Since the ObjectResolver is a concrete class, StructureMap can effortlessly instantiate it such that you don't need a single line of configuration to use it.</li>\n<li>You can satisfy a dependency to the ObjectResolver without instantiating any DI container.</li>\n</ul>\n<p>Check out the following code that uses <a href=\"http://ayende.com/projects/rhino-mocks.aspx\">Rhino Mocks</a> to provide a satisfying response within a test:</p>\n<pre><code>public void MediatorWillInstantiateSaveCommand {\n  var cmd = new Command();\n  var resolver = MockRepository.GenerateMock&#x3C;ObjectResolver&#x3C;ICommand>>();\n  resolver.Expect(r=>r[null]).Constraints(Is.Equal(\"Save\")).Return(cmd);\n  var mediator = new CommandMediator(resolver);\n  mediator.Foo();\n  resolver.VerifyAllExpectations();\n}\n</code></pre>\n<p>What I am trying to say is: Put some effort into your code when you see yourself using a DI Container as Service Locator. It is most likely to pay off in several ways.</p>","frontmatter":{"date":"January 07, 2009","path":null,"title":"Dependency Injection is not locating services","tags":["dotnet","patterns","libs-and-frameworks"]}}},"pageContext":{"title":"Dependency Injection is not locating services"}}