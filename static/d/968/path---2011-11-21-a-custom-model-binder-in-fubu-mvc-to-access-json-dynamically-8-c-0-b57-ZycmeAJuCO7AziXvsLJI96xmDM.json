{"data":{"markdownRemark":{"html":"<p>One aspect of my new web site is the admin interface which allows me to write new posts and post them to my site via a simple HTTP-based\ninterface. The posting of a new entry happens with the HTTP content-type <em>application/json</em>.</p>\n<p>Short of specifying what exactly the structure of the JSON should be, I wanted to keep this fairly dynamic. Literally.\nThis meant to somehow translate the incoming request to a dynamic object that allows access to the parsed JSON. The parse and access bit was relatively simple to come up with by using <a href=\"http://dynamicjson.codeplex.com/\">DynamicJson</a>. The project boils down to a single class inheriting from <em>DynamicObject</em>, allowing Json to be parsed and accessed in C# syntax style.</p>\n<p>Armed with that, the ideal situation from a FubuMVC perspective would be that the input model of an Action is an object of type <em>dynamic</em>:</p>\n<pre><code>[UrlRegistryCategory(\"Admin\")]\npublic void Post(dynamic content)\n{\n    var newId = _contentAdministration.InsertContent(content);\n    _request.Set(new InsertInfo(_urls.UrlFor(new ContentId(newId), \"Admin\")));\n}\n</code></pre>\n<p>One way to give Fubu the chance to handle this kind of input model is to provide custom model binding capabilities, wired up in the Fuburegistry with <code>Models.BindModelsWith&#x3C;T>() where T : IModelBinder</code>. An implementation of <em>IModelBinder</em> requires us to match for what types of models this new binding occurs. It turns out that the dynamic input object comes along as an object of type...<em>object</em>.</p>\n<pre><code>public bool Matches(Type type)\n{\n    return type == typeof(object);\n}\n</code></pre>\n<p>As soon as that's clear to FubuMVC, our Model binder gets the chance to do its work, i.e. to translate the bits of the current request to a model that will be passed on to any interested Action.</p>\n<pre><code>public object Bind(Type type, IBindingContext context)\n{\n    var rd = context.Service&#x3C;IRequestData>();\n    var cType = (string)rd.Value(\"Content-Type\");\n    if (!new[] { \"application/json\", \"application/jsonrequest\", \"application/x-javascript\" }.Any(ct => ct.Equals(cType)))\n        throw new DynamicBindException(\"Content-Type\");\n    var data = context.Service&#x3C;IStreamingData>().InputText();\n    try\n    {\n        return DynamicJson.Parse(data);\n    }\n    catch\n    {\n        throw new DynamicBindException(\"Parse\");\n    }\n}\n</code></pre>\n<p>The <em>binding context</em> allows us to access all those dependencies that are valid in the scope of the application as well as the scope of the current request.\n<em>IRequestData</em> is an abstraction that allows us to access relevant information about the current request. In the above example we attempt to read the Content-Type part of the HTTP header of the incoming request and only carry on when the content type fits to what the type for which we will do the conversion. <em>IStreamingData</em> gives us access to the incoming request text</p>\n<p>The shown implementation is harsh in that it will only work with the shown content type. One could imagine an implementation that can also handle XML Content and\ncreate <em>DynamicObject</em> instance that supports accessing the data stored in the XML dynamically.</p>","frontmatter":{"date":"November 21, 2011","path":null,"title":"A custom ModelBinder in FubuMVC to access JSON dynamically","tags":["software-development","web","libs-and-frameworks"]}}},"pageContext":{"title":"A custom ModelBinder in FubuMVC to access JSON dynamically"}}