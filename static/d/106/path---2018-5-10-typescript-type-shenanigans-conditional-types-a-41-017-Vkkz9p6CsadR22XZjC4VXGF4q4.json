{"data":{"markdownRemark":{"html":"<p>The amazing thing about Typescript's type system is not really that it strives to be the most complete type system, or the most formal, but in that in its pursue to be able to type all the things that lovers &#x26; haters of javascript do with the language, it explores new avenues and possibilities. This post looks at a use case for a fairly recent addition, <strong>conditional types</strong>.</p>\n<p>But before we get there, bask in the glory of this nifty type (I saw it first in the typing for <a href=\"https://github.com/reduxjs/redux/blob/619507a0fa46e6b90c5fca26eaf409c38a078faf/index.d.ts#L208\">redux</a>.</p>\n<pre><code class=\"language-ts\">export type DeepPartial&#x3C;T> = { [K in keyof T]?: DeepPartial&#x3C;T[K]> };\n</code></pre>\n<p>What does it do? - Given some type, it recursively turns itself and all of its properties as optional (remember that the in-built <code>Partial&#x3C;T></code> does it flat on T).</p>\n<p>You donÂ´t have to remember that. It has no relevance to what follows. It's <em>just</em> a cool and useful type that shows off all the parts that Typescript has learned in the past year or so.</p>\n<hr>\n<p>Right. <a href=\"http://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html\">Conditional Types</a>. To me it always helps to have some example. This one also involves some react. Sorry. </p>\n<p>Imagine some <strong>UI component</strong> which you can use in either of two ways.</p>\n<ul>\n<li>I give it a list of items which contain links and the component renders the links in some useful and pretty fashion</li>\n<li>I give it a list of items which contain actions (functions to be invoked when some button is clicked), and now the component is to render buttons with the click triggering those actions.</li>\n</ul>\n<p>Note that the two item types are mutually exclusive. I either want it to render links, or buttons. Ideally I want Typescript to guide me so that I'm filling in the details correctly.</p>\n<p>Let's encode the two types of functionality:</p>\n<pre><code class=\"language-ts\">type ActionableItemType = \"action\" | \"link\";\n</code></pre>\n<p>and the two kinds of items that I want to support:</p>\n<pre><code class=\"language-ts\">export interface ActionItem {\n  label: string;\n  action: () => any;\n}\n\nexport interface LinkItem {\n  label: string;\n  link: string;\n}\n</code></pre>\n<p>Now we are already ready to define our <strong>conditional type</strong> ðŸŽ‰ !</p>\n<pre><code class=\"language-ts\">type ActionableItem&#x3C;T extends ActionableItemType> = \n  T extends \"action\" \n  ? ActionItem\n  : T extends \"link\" \n  ? LinkItem \n  : never;\n</code></pre>\n<p>what it says is that given some Type <strong>T</strong>, when T extends the type <strong>\"action\"</strong>, <strong>ActionableItem</strong> is now an <strong>ActionItem</strong>, otherwise if <strong>T</strong> is <strong>\"link\"</strong>, <strong>ActionableItem</strong> is <strong>LinkItem</strong>. To complete the type, we use the <strong>never-Type</strong>, which is exactly for such cases where you want to use a Type that no instance can have.</p>\n<p>We are now armed to implement a react component that takes advantage of this typing, starting with defining the properties of the component.</p>\n<pre><code class=\"language-ts\">export interface ActionableItemComponentProps&#x3C;T extends ActionableItemType> {\n  items: Array&#x3C;ActionableItem&#x3C;T>>;\n}\n</code></pre>\n<p>And the component itself</p>\n<pre><code class=\"language-ts\">class ActionableItemComponent&#x3C;T extends ActionableItemType> extends React.Component&#x3C;\n  ActionableItemComponentProps&#x3C;T>\n> {\n    // ... impl to come\n}\n</code></pre>\n<p>The component itself is now generic, that is when we work with the items passed in we don't know if these are action or link items (remember the runtime is javascript, so all your type info is pretty much erased at runtime). To get back typings you will make use of <strong><a href=\"http://www.typescriptlang.org/docs/handbook/advanced-types.html\">type guards</a></strong>, a runtime check that gives your code safe areas where you may assume that something is indeed of the type you expect. Here are the two type guards that I will use in the <code>render</code>-code</p>\n<pre><code class=\"language-ts\">function isActionsArray(items: any[]): items is ActionItem[] {\n  return items.length > 0 &#x26;&#x26; items[0].action;\n}\n\nfunction isItemsArray(items: any[]): items is LinkItem[] {\n  return items.length > 0 &#x26;&#x26; items[0].link;\n}\n</code></pre>\n<p>You can see that I only check the first item of some array to check whether I have action or link types. The underlying assumption is that the call site is <strong>also written in TypeScript</strong>. You will see that the compile time check will ensure that all items must adhere to the same type.</p>\n<p>Now we are ready to implement a render function for the <code>ActionableItemComponent</code>.</p>\n<pre><code class=\"language-tsx\">render() {\n  const { items } = this.props;\n  return (\n    &#x3C;Container>\n      {(isActionsArray(items) &#x26;&#x26; this.renderActionItems(items)) ||\n        (isItemsArray(items) &#x26;&#x26; this.renderLinkItems(items))}\n    &#x3C;/Container>\n  );\n}\n</code></pre>\n<p>The implementation of <code>renderActionItems</code> and <code>renderLinkItems</code> is left to the reader (No, it's not, you can actually <a href=\"https://github.com/flq/ts-react-playground/blob/ac41d388a3746f66f63dd215d65801cac9ceaaaf/src/examples/ActionableItems.tsx#L37\">find it here</a>).</p>\n<p>The only thing left is to make the component readily available to users of the component (The generic in there means we can't use it easily straight away), so we provide two convenience types to have the two different styles of rendering actionable items:</p>\n<pre><code class=\"language-ts\">type ActionItemsComponent = new () => ActionableItemComponent&#x3C;\"action\">;\nexport const ActionItemsComponent = ActionableItemComponent as ActionItemsComponent;\n\ntype LinkItemsComponent = new () => ActionableItemComponent&#x3C;\"link\">;\nexport const LinkItemsComponent = ActionableItemComponent as LinkItemsComponent;\n</code></pre>\n<p>Users of the component can now go ahead and use it as such:</p>\n<pre><code class=\"language-tsx\">import * as React from \"react\";\nimport { ActionItemsComponent, LinkItemsComponent } from \"./ActionableItems\";\n\nexport const UsingActions : React.SFC = () => (\n    &#x3C;ActionItemsComponent items={[{action: () => alert(\"Hallelujah\"), label: \"alerted\" }]} />\n);\n\nexport const UsingLinks : React.SFC = () => (\n    &#x3C;LinkItemsComponent items={[{link: \"/#whatever\", label: \"whatever link\" }]} />\n);\n</code></pre>\n<p>Depending on either usage, the consumer gets nice type safety on how the items need to be structured, while the implementation can make use of the conditional type to provide a single implementation. </p>\n<p><em>Of course</em> there are many ways to encode such functionality, and if the two styles of rendering diverge a lot, you may be better off implementing two different components. Even so, I hope it helps you to consider in what ways conditional types can be useful to you.</p>","frontmatter":{"date":"June 10, 2018","path":null,"title":"Typescript type shenanigans: Conditional Types","tags":["programming","typescript","react"]}}},"pageContext":{"title":"Typescript type shenanigans: Conditional Types"}}