{"data":{"markdownRemark":{"html":"<p>Let us consider a more complex Bus setup in order to understand the capabilities of the different parts of the infrastructure:</p>\n<p> <img src=\"/assets/image_7337b070-7353-4041-bb93-87aca8327ca8.png\" alt=\"image\" title=\"image\"> </p>\n<p>What are we expressing here?</p>\n<ul>\n<li>\n<p>Publishing is configured</p>\n</li>\n<li>\n<p>If a message of type Transport is published, use the Sequential publisher</p>\n</li>\n<li>\n<p>If a message type ends with “Request” in its name, publish a message of type Transport as constructed and use the non blocking publisher for the Request message.</p>\n</li>\n<li>\n<p>If a message type ends with “Response” in its name, publish it in the parallel blocking fashion, then an instance of type Transport as shown.*   Subscriptions are configured </p>\n</li>\n</ul>\n<p>This is an example where you perform Requests with messages that may be long running: They are published and the UI would have to wait until a “Response” becomes available. The Transport-messages mark those cycles such that a UI can use them in a general form to provide feedback to the user that something is happening.</p>","frontmatter":{"date":"September 06, 2010","path":null,"title":"MemBus: A more complex rich client setup","tags":["software-development","dotnet","patterns","membus"]}}},"pageContext":{"title":"MemBus: A more complex rich client setup","previous":{"fields":{"slug":"/2010/09/02/introducing-membus-construction-variants"},"frontmatter":{"title":"Introducing MemBus: Construction Variants","tags":["csharp","membus"],"date":"2010/09/02"}},"next":{"fields":{"slug":"/2010/09/08/membus-performance-considerations"},"frontmatter":{"title":"Membus: Performance considerations","tags":["software-development","patterns","csharp","membus"],"date":"2010/09/08"}}}}