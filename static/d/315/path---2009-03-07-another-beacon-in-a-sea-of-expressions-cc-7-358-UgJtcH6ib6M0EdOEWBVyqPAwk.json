{"data":{"markdownRemark":{"html":"<p>A prosaic introduction to the subject of .NET expressions. These were introduced with .NET 3.5 and are featured most prominently in LINQ. Over <a href=\"/go/118\">here</a> I implemented a use case with the aid of expressions.</p>\n<p>In my current project I am using expressions to be able to analyze what the user of some API wants to express. From the expression</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Expression&lt;Function&lt;Person,object&gt;&gt; e = p =&gt; p. FirstName + &quot;,&quot; + p.LastName</code></pre></div>\n<p>I want to know that properties <em>FirstName</em> and <em>LastName</em> are being used to generate the return value. While developing the things for this to work I came across two things that really helped me:</p>\n<h2>A debugger visualizer for expressions</h2>\n<p>There is one available as part of the Visual Studio samples (under <em>Microsoft Visual Studio 9.0\\Samples\\1033\\CSharpSamples.zip\\LinqSamples\\ExpressionTreeVisualizer</em>) or downloadable from <a href=\"http://code.msdn.microsoft.com/csharpsamples\">here</a>.</p>\n<p>You will need to compile the visualizer and place it under <em>VS9.0\\Common7\\Packages\\Debugger\\Visualizers</em>.</p>\n<p><img src=\"/assets/expressiontreevisualizer.jpg\" alt=\"visualization of a simple expression\"></p>\n<h2>The expression Visitor</h2>\n<p>At the end of <a href=\"http://blogs.msdn.com/mattwar/archive/2007/07/31/linq-building-an-iqueryable-provider-part-ii.aspx\">this post here</a> on <a href=\"http://blogs.msdn.com/mattwar/\">The Wayward Weblog</a>. I have taken exactly that code and just made a run with R# over it. <a href=\"/assets/ExpressionVisitor.cs\">Grab it over here</a>. The class is extremely useful when you are checking up on complex expression trees. The class ensures that all nodes of the tree are visited and that you can actually replace certain parts of it. </p>\n<p>You would typically create a class that inherits from the ExpressionVisitor, override the methods that are interesting to you and provide some entry point that accepts an expression which is subsequently passed to the protected base class's Visit method. </p>\n<p>As an example, I wanted to parse an expression that gets a DataSet as arguments and represents access to a number of fields on a number of rows stemming from said DataSet. In this case I was only interested in any MemberAccess and it was sufficient to just override that method and insert my logic:</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre class=\"language-csharp\"><code class=\"language-csharp\"><span class=\"token keyword\">protected</span> <span class=\"token keyword\">override</span> <span class=\"token class-name\">Expression</span> <span class=\"token function\">VisitMemberAccess</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">MemberExpression</span> m<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">.</span>Member<span class=\"token punctuation\">.</span>DeclaringType<span class=\"token punctuation\">.</span><span class=\"token function\">IsSubclassOf</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> <span class=\"token punctuation\">(</span>DataRow<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span>\n      <span class=\"token operator\">!</span>m<span class=\"token punctuation\">.</span>Type<span class=\"token punctuation\">.</span><span class=\"token function\">IsSubclassOf</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> <span class=\"token punctuation\">(</span>DataRow<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">{</span>\n    datasetFieldName <span class=\"token operator\">=</span> m<span class=\"token punctuation\">.</span>Member<span class=\"token punctuation\">.</span>Name<span class=\"token punctuation\">;</span>\n    tableName <span class=\"token operator\">=</span> m<span class=\"token punctuation\">.</span>Member<span class=\"token punctuation\">.</span>DeclaringType<span class=\"token punctuation\">.</span>Name<span class=\"token punctuation\">.</span><span class=\"token function\">Replace</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Row\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">.</span>Member<span class=\"token punctuation\">.</span>DeclaringType<span class=\"token punctuation\">.</span><span class=\"token function\">IsSubclassOf</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> <span class=\"token punctuation\">(</span>DataSet<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">{</span>\n    dataSetName <span class=\"token operator\">=</span> m<span class=\"token punctuation\">.</span>Member<span class=\"token punctuation\">.</span>DeclaringType<span class=\"token punctuation\">.</span>Name<span class=\"token punctuation\">;</span>\n    entryTable <span class=\"token operator\">=</span> m<span class=\"token punctuation\">.</span>Member<span class=\"token punctuation\">.</span>Name<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">persistField</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">base</span><span class=\"token punctuation\">.</span><span class=\"token function\">VisitMemberAccess</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>As a last example, to show off the tree modifying features of the class to change an expression, the following 2 methods change</p>\n<p><code class=\"language-text\">Expression&lt;Func&lt;SomeDataSet,object&gt;&gt; e = ds =&gt; ds.Master[0].FirstName + &quot;,&quot; + ds.Master[0].GetAddresses()[0].City;</code>\nto\n<code class=\"language-text\">Expression&lt;Func&lt;DataRow,object&gt;&gt; e = r =&gt; ((MasterRow)r).FirstName + &quot;,&quot; + ((MasterRow)r).GetAddresses()[0].City;</code></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">protected override Expression VisitMethodCall(MethodCallExpression m)\n{\n  if (m.Method.Name == &quot;get_Item&quot;)\n    return Expression.Convert(dataRowParameter, m.Type);\n  return base.VisitMethodCall(m);\n}\n\nprotected override Expression VisitLambda(LambdaExpression lambda)\n{\n  if (visitedMainLambdaBody) \n    return base.VisitLambda(lambda);\n  visitedMainLambdaBody = true; // sort of. This is somewhat recursive...\n  Expression body = Visit(lambda.Body);\n  List&lt;ParameterExpression&gt; @params =\n    new List&lt;ParameterExpression&gt; { dataRowParameter };\n\n  return Expression.Lambda&lt;Func&lt;DataRow, object&gt;&gt;(body, @params);\n}</code></pre></div>","fields":{"slug":"/2009/03/07/another-beacon-in-a-sea-of-expressions"},"frontmatter":{"date":"March 07, 2009","path":null,"title":"Another beacon in a sea of expressions","tags":["software-development","download","dotnet","libs-and-frameworks"]}}},"pageContext":{"title":"Another beacon in a sea of expressions","previous":{"fields":{"slug":"/2009/01/31/playing-lotto-with-linq","published":true},"frontmatter":{"title":"Playing Lotto with LINQ","tags":["dotnet","geekdom","loosely-coupled"],"date":"2009/01/30"}},"next":{"fields":{"slug":"/2009/03/11/cycling-through-a-number-range","published":true},"frontmatter":{"title":"cycling through a number range","tags":["programming","dotnet","geekdom","mathematics","csharp"],"date":"2009/03/11"}}}}