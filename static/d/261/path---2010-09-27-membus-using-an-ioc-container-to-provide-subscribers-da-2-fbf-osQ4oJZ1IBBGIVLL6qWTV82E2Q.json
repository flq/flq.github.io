{"data":{"markdownRemark":{"html":"<p>The “Observe” and “Subscribe” functionality already opens up numerous possibilities for reacting to messages. Another way to handle messages is by providing a Handler which accepts messages of a certain type:</p>\n <div style=\"padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px\" id=\"scid:812469c5-0cb0-4c63-8c15-c81123a09de7:4bce9fa8-07f8-46ad-a2e3-ca2140037987\" class=\"wlWriterEditableSmartContent\"><pre name=\"code\" class=\"c#\">public interface IHandles&lt;T&gt; : ISubscription\n{\n    void Push(T message);\n}</pre></div>\n<p>Once we’re down to providing instances to handle available messages, it makes a lot of sense to bring IoC containers to the stage. Indeed, it is relatively easy to put your Container of choice into action by providing an implementation of “<strong>ISubscriptionResolver</strong>”. </p>\n<p>MemBus comes with an implementation that uses the <a href=\"http://commonservicelocator.codeplex.com/\">Common service locator</a> dll to allow plugging your container of choice into the functionality of letting “IHandles” implementations handle messages. Numerous IoC container on the .NET platform come with a bridge to plug into the common service locator. It is also quite easy to provide your own bridge. Here’s an example for <a href=\"http://structuremap.net/structuremap/index.html\">StructureMap</a>:</p>\n<div style=\"padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px\" id=\"scid:812469c5-0cb0-4c63-8c15-c81123a09de7:8830d825-85ac-43f7-8286-559d1e370eed\" class=\"wlWriterEditableSmartContent\"><pre name=\"code\" class=\"c#\">public class ServiceLocator : ServiceLocatorImplBase\n{\n    private readonly Func&lt;IContainer&gt; containerLookup;\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">private IContainer container\n{\n    get { return containerLookup(); }\n}\n\npublic ServiceLocator(Func&amp;lt;IContainer&amp;gt; containerLookup)\n{\n    this.containerLookup = containerLookup;\n}\n\nprotected override object DoGetInstance(Type serviceType, string key)\n{\n    return string.IsNullOrEmpty(key) ? container.GetInstance(serviceType) : container.GetInstance(serviceType, key);\n}\n\nprotected override IEnumerable&amp;lt;object&amp;gt; DoGetAllInstances(Type serviceType)\n{\n    return container.GetAllInstances(serviceType).OfType&amp;lt;object&amp;gt;();\n}</code></pre></div>\n<p>}</pre></div></p>\n<p><strong>ServiceLocatorImplBase</strong> is a class from the common service locator dll. </p>\n<p>Moving along with the StructureMap example, the Container enters MemBus in the following way:</p>\n<div style=\"padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px\" id=\"scid:812469c5-0cb0-4c63-8c15-c81123a09de7:d44a076e-6fd7-42f4-897b-08eab52836a9\" class=\"wlWriterEditableSmartContent\"><pre name=\"code\" class=\"c#\">var bus = BusSetup.StartWith&lt;AsyncRichClientFrontend, ClientPublishingConventions&gt;(\n  new ServiceLocatorSupport(new ServiceLocator(() =&gt; ObjectFactory.Container)))\n.Construct();</pre></div>\n<p><strong>ServiceLocatorSupport</strong> is a MemBus class which accepts an implementation of <strong>IServiceLocator</strong>, the main interface of the common service locator library.</p>\n<p>In StructureMap I can now make all IHandles implementations available e.g. inside a registry:</p>\n<div style=\"padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px\" id=\"scid:812469c5-0cb0-4c63-8c15-c81123a09de7:4156246a-c4c8-4573-8c5e-c5a5175dd9f6\" class=\"wlWriterEditableSmartContent\"><pre name=\"code\" class=\"c#\">Scan(s =&gt;\n{\n  s.AssembliesFromApplicationBaseDirectory();\n   s.AddAllTypesOf(typeof (IHandles&lt;&gt;));\n});</pre></div>\n<p>That way, any implementations that close this interface will be picked up and resolved when requested by MemBus. </p>\n<p>Another nice way to bring in message notification is by defining how an observable is constructed. MemBus brings along a generic implementation of <strong>IObservable&#x3C;T></strong> that is IoC friendly. The class <strong>MessageObservable</strong>, which is also returned by a call to <strong>IBus</strong>.<strong>Observe&#x3C;M></strong> can also be constructed by the IoC container, provided you let it know how to provide an IBus implementation:</p>\n<div style=\"padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px\" id=\"scid:812469c5-0cb0-4c63-8c15-c81123a09de7:62676971-a282-4123-97d4-9b261415c26b\" class=\"wlWriterEditableSmartContent\"><pre name=\"code\" class=\"c#\">ForSingletonOf&lt;IBus&gt;().Use(constructBus);\nFor(typeof (IObservable&lt;&gt;)).Use(typeof (MessageObservable&lt;&gt;));</pre></div>\n<p>Hence any instance that expresses a dependency to an IObservable&#x3C;T> will obtain a valid instance that will pick up notifications published via MemBus.</p>\n<p> </p>\n<p>By the way, all code samples here are taken from the Sample Application which is part of MemBus.</p>","frontmatter":{"date":"September 27, 2010","path":null,"title":"MemBus: Using an IoC Container to provide subscribers","tags":["software-development","patterns","membus"]}}},"pageContext":{"title":"MemBus: Using an IoC Container to provide subscribers","previous":{"fields":{"slug":"/2010/09/20/membus-extension-points"},"frontmatter":{"title":"MemBus extension points","tags":["software-development","patterns","csharp","membus"],"date":"2010/09/20"}},"next":{"fields":{"slug":"/2010/10/01/membus-caliburn-micro-lean-screen"},"frontmatter":{"title":"MemBus + Caliburn.Micro = Lean Screen","tags":["software-development","dotnet","membus","libs-and-frameworks"],"date":"2010/10/01"}}}}