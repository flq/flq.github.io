{"data":{"markdownRemark":{"html":"<p>Every once in a while you may be down to low-level element calculation and placement of elements in WPF. For this situation, I have found the following extension methods quite useful:</p>\n<h3>Translating a point</h3>\n <div style=\"padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px\" id=\"scid:812469c5-0cb0-4c63-8c15-c81123a09de7:facf6c1b-2a27-4f03-8419-42e848242b43\" class=\"wlWriterEditableSmartContent\"><pre name=\"code\" class=\"c#\">public static Point Translate(this Point p, Func&lt;Point,Tuple&lt;double,double&gt;&gt; translateFunction)\n{\n    var points = translateFunction(p);\n    return new Point(p.X + points.Item1, p.Y + points.Item2);\n}\n<p>public static Point Translate(this Point p, Vector translation)\n{\nreturn p.Translate(po => Tuple.Create(translation.X, translation.Y));\n}</p>\n<p>public static Point Translate(this Point p, double xOffset, double yOffset)\n{\nreturn p.Translate(po=>Tuple.Create(xOffset, yOffset));\n}</p>\n<p>public static Point TranslateX(this Point p, double xOffset)\n{\nreturn p.Translate(xOffset, 0);\n}</p>\n<p>public static Point TranslateY(this Point p, double yOffset)\n{\nreturn p.Translate(0, yOffset);\n}</pre></div></p>\n<p>The first method is a low level application of a double-tuple as offset to a given point. All others use this method to create a new point from an old point and some additional info. Some examples:</p>\n<div style=\"padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px\" id=\"scid:812469c5-0cb0-4c63-8c15-c81123a09de7:e74055e9-3855-4599-b776-fe59dc3fabdc\" class=\"wlWriterEditableSmartContent\"><pre name=\"code\" class=\"c#\">var p = new Point(0,0);\np2 = p.TranslateY(10); //10 pixels to the right\np3 = p2.Translate(10); //New point at 10,10\np4 = p3.Translate(new Vector(10,10)); //New point at 20,20</pre></div>\n<h3>Point Sources</h3>\n<p>A point source is an object that implements IEnumerable&#x3C;Point>. One type of Poiint Source I have used is one that takes a seed point and to which you can provide a function how to get from previous to the next point. the following example uses this class to be able to iterate over equal-spaced points along the vertical axis:</p>\n<div style=\"padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px\" id=\"scid:812469c5-0cb0-4c63-8c15-c81123a09de7:49c08465-1cd6-49d0-8940-20a2871ef835\" class=\"wlWriterEditableSmartContent\"><pre name=\"code\" class=\"c#\">var psource = new PointSource(new Point(10, 10), p =&gt; p.TranslateY(10));\nvar points = psource.Take(5).ToArray() // 10,10 ; 10,20 ; 10,30 ...</pre></div>\n<p>By entering the IEnumerable realm, you open your code to all the shiny LINQiness there is out there.</p>\n<h3>Arcs and the like</h3>\n<p>In WPF you can work with vectors and matrices. That gives you a nice base to implement a “Rotate” method:</p>\n<div style=\"padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px\" id=\"scid:812469c5-0cb0-4c63-8c15-c81123a09de7:126bfd5d-6b0c-4fba-8415-c7fa77b0609f\" class=\"wlWriterEditableSmartContent\"><pre name=\"code\" class=\"c#\">public static Vector Rotate(this Vector origin, double angle)\n{\n    var cos = Math.Cos(angle);\n    var sin = Math.Sin(angle);\n    var rotationMatrix = new Matrix(cos, -sin, sin, cos, 0, 0);\n    return origin * rotationMatrix;\n}</pre></div>\n<p>In combination with a different point source that takes an IEnumerable&#x3C;T> and provides a conversion to an IEnumerable&#x3C;Point> you can create arcs and circles of points quite easily:</p>\n<div style=\"padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px\" id=\"scid:812469c5-0cb0-4c63-8c15-c81123a09de7:f9d7e2c5-f7d4-45d6-b08e-e5b2a151c766\" class=\"wlWriterEditableSmartContent\"><pre name=\"code\" class=\"c#\">var radius = new Vector(0.0, 10.0);\nvar angleToRadians = Math.PI / 180.0;\nvar midpoint = new Point(20,20);\n<p>var translationVectors =\nfrom step in Enumerable.Range(0, 360)\nlet angle = step * angleToRadians\nselect radius.Rotate(angle);</p>\n<p>var ps = new PointSource&#x3C;Vector>(translationVectors, v => midpoint.Translate(v));</p>\n<p>ps.Take(45); // Gives 45 points over 45 degrees, each with a radius of 10</pre></div></p>\n<p>Note that above, you could also get the functionality by using the LINQ-Select on the list of vectors. Also note the lazy nature of all involved items. If you only need 45 items, that’s all that is calculated.</p>\n<p>I am just thinking of putting this kind of stuff into a small library to help dealing with that low-level stuff, which can be useful for Custom arrangers and the like. I am wondering what else could be in that library…or maybe there is already one?</p>","frontmatter":{"date":"October 11, 2010","path":null,"title":"Useful Extension Methods for Points and friends in WPF","tags":["software-development","libs-and-frameworks"]}}},"pageContext":{"title":"Useful Extension Methods for Points and friends in WPF"}}