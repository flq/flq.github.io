{"data":{"markdownRemark":{"html":"<p>When developing a piece of code that could potentially be used as a central component, one should have a look at the performance as well. There is no easy answer as to whether MemBus is fast or not – it depends which features you are using.</p>\n<p>I have been doing a number of performance measurements wit the following setup:</p>\n<pre><code class=\"language-csharp\">public void Run(IBus bus, TextWriter w)\n{\n    bus.Subscribe&#x3C;MessageA>(onMessageA);\n    bus.Subscribe&#x3C;MessageB>(onMessageB);\n    bus.Subscribe&#x3C;MessageC>(onMessageC);\n\n    var r = new Random();\n    var dict = new Dictionary&#x3C;int, Func&#x3C;object>>\n                   {\n                       {0, () => new MessageA()},\n                       {1, () => new MessageB()},\n                       {2, () => new MessageC()},\n                   };\n    int count = 0;\n    var sw = Stopwatch.StartNew();\n    while (count &#x3C; 100000)\n    {\n        bus.Publish(dict[r.Next(0, 3)]());\n        count++;\n    }\n\n    w.WriteLine(\"Through {0}\", sw.ElapsedMilliseconds);\n\n    count = 0;\n    while (count &#x3C; 4)\n    {\n        w.WriteLine(\"From MsgA:{0}({1}), B:{2}({3}), C:{4}({5})\", aCount, MessageA.Count, bCount,\n                    MessageB.Count, cCount, MessageC.Count);\n        Thread.Sleep(200);\n        count++;\n    }\n}\n</code></pre>\n<p>The actual publishing happens in line 18. We publish three different messages by random, in total 100’000 messages. The three subscriptions each increment a counter, the messages themselves increment an internal counter when they are constructed. Let’s start with the simple setup (“<strong>Conservative</strong>”):</p>\n<p><img src=\"/public/assets/image_5314e329-cdb9-4cdc-82d8-2245ebc72749.png\" alt=\"image\" title=\"image\"> </p>\n<p>Pretty quick. Let’s compare it to the “<strong>AsyncConfiguration</strong>”:</p>\n<p><img src=\"/public/assets/image_e3e558bc-b06e-4827-bf63-59863e4ff134.png\" alt=\"image\" title=\"image\"> </p>\n<p>That’s taking a while...Let us actually do some work in a subscription and put a small thread.sleep() of 1 milliseconds in the subscription of message B. Let’s go <strong>Conservative</strong>:</p>\n<p><img src=\"/public/assets/image_26fb2203-0e83-4070-a1b7-93ac4c8c9dab.png\" alt=\"image\" title=\"image\"> </p>\n<p>That could be expected! B got 33463 messages, at 1ms each it gives you roughly that number. Let’s push it through the <strong>AsyncConfiguration</strong>:</p>\n<p><img src=\"/public/assets/image_4f1ee625-b549-4ff8-933f-35ee48eb3165.png\" alt=\"image\" title=\"image\"> </p>\n<p>The Publishing loop comes back much quicker, but now we can see that the work hasn’t been completed yet – The message construction count differs from the subscription counters! Also note that in this scenario I had to change the Increment code (“<strong>++</strong>”) to the thread-safe version (“<strong>Interlocked.Increment(ref i)</strong>”) as the counts would not match up anymore. As opposed to the code shown, I changed the counter output to be delayed by 1 seconds. Hence, after roughly 9 seconds all work was done.</p>\n<p>As a final check, let’s use the “<strong>Fast</strong>” setup:</p>\n<p><img src=\"/public/assets/image_7519dc98-15d1-439f-aa9f-1ac3a30d139a.png\" alt=\"image\" title=\"image\"> </p>\n<p>Here, publishing comes back pretty quick, but the work also takes about the same time. the Fast setup was created after some sessions with the dotTrace performance profiler that showed where time could be saved. The fast setup will not do <strong>contravariant publishing</strong> (i.e. a subscription on a message of type object will not receive a message of type “MessageA”) and exceptions in subscriptions are <strong>not taken care of</strong>.</p>\n<p>As usual, answering performance related issues isn’t easy. It very much depends on the circumstances, what kind of setup you should take, how much work subscriptions do, how many messages are sent, etc., etc.</p>","frontmatter":{"date":"September 08, 2010","path":null,"title":"Membus: Performance considerations","tags":["software-development","patterns","csharp","membus"]}}},"pageContext":{"title":"Membus: Performance considerations"}}