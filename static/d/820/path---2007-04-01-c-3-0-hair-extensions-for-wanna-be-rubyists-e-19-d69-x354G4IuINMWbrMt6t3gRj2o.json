{"data":{"markdownRemark":{"html":"<p>Metaprogramming and cool syntax aside, there is something in ruby that is quite sexy and will be available to the .NET world once C# 3.0 is out: Check out this sweet ruby code:</p>\n<pre><code class=\"language-ruby\">2.upto 5 do |x|\n  puts x\nend\n</code></pre>\n<p>Or here (works within your Rails environment):</p>\n<pre><code>3.weeks.ago\n</code></pre>\n<p>While the first code snippet will iterate from 2 up to 5, the second will provide you the time 3 weeks in the past from this moment in time. **Now **this is something we can provide as well in C#. For that we will have extension methods. Those are simply static methods that due to their syntax will attach themselves to the object specified. This is best explained by the following example: </p>\n<pre><code class=\"language-csharp\">public static class TimeExtensions {\n  public static TimeSelector Weeks(this int i) {\n    return new WeekSelector { ReferenceValue = i };\n  }\n  public static TimeSelector Days(this int i) {\n    return new DaysSelector { ReferenceValue = i };\n  }\n  public static TimeSelector Years(this int i) {\n    return new YearsSelector { ReferenceValue = i };\n  }\n}\n</code></pre>\n<p>The trick is the **this **keyword in its umpteenth meaning: It specifies that the method (and this only works for methods) will be attached to the specified type. In other words, as soon as you reference the namespace in which the extension is defined, three methods will be added to your <em>int</em> definition. This is the same trick how bog standard arrays and collections suddenly know how to behave within LINQ expressions.</p>\n<p>Btw, another thing shown off is the new way to initialize properties of a newly instantiated object. This is a true code-lines saver, since in this simple case it means that I do not have to inherit a constructor three times if I want to allow a developer using the class to instantiate it with relevant values in a one-liner. An effective enhancement, if there ever was one.</p>\n<p>Let me show you the TimeSelector class to finalize this treat:</p>\n<pre><code class=\"language-csharp\">public abstract class TimeSelector {\n  protected TimeSpan myTimeSpan;\n\n  internal int ReferenceValue {\n    set { myTimeSpan = MyTimeSpan(value); }\n  }\n\n  public DateTime Ago { get { return DateTime.Now - myTimeSpan; } }\n  public DateTime FromNow { get { return DateTime.Now + myTimeSpan; } }\n  public DateTime AgoSince(DateTime dt) { return dt - myTimeSpan; }\n  public DateTime From(DateTime dt) { return dt + myTimeSpan; }\n  protected abstract TimeSpan MyTimeSpan(int refValue);\n\n}\n\npublic class WeekSelector : TimeSelector {\n  protected override TimeSpan MyTimeSpan(int refValue) { return new TimeSpan(7 * refValue, 0, 0, 0); }\n}\n\npublic class DaysSelector : TimeSelector {\n  protected override TimeSpan MyTimeSpan(int refValue) { return new TimeSpan(refValue, 0, 0, 0); }\n}\n\npublic class YearsSelector : TimeSelector {\n  protected override TimeSpan MyTimeSpan(int refValue) {\n    return new TimeSpan(365 * refValue, 0, 0, 0);\n  }\n}\n</code></pre>\n<p>Btw, this cannot be used to open up the innards of a foreign type definition: The type to be extended is only visible through its public / internal face, respectively.</p>\n<p>Now, in your code you can do this:</p>\n<pre><code>using RF.Extensions.Time;\n...\nConsole.WriteLine(3.Weeks().Ago);\nConsole.WriteLine(5.Years().FromNow);\nConsole.WriteLine(19.Days().From(new DateTime(2007,1,1)));\n</code></pre>\n<p>The second example was the ability to iterate between two integers. This is also an extension to the integer type and it usage will be simplified by the concise syntax that can be used for providing inline expressions. First comes the code that enables it:</p>\n<pre><code class=\"language-csharp\">public static class IterationExtensions {\n  public static void IterateTo(this int start, int end, Func&#x3C;int, int> modify, Action&#x3C;int> action) {\n    int prefix = end &#x3C; start ? -1 : 1;\n\n    for (int i = prefix * start; i &#x3C;= prefix * end; i = modify(i))\n    {\n      action(prefix * i);\n    }\n  }\n\n  public static void IterateTo(this int start, int end, Action&#x3C;int> action) {\n    IterateTo(start, end, i => i + 1, action);\n  }\n}\n</code></pre>\n<p>This version not only allows you to iterate up and down, but also defines an overload where you can specify your own stepping in the form of a lambda expression.</p>\n<p>This stuff is used as such:</p>\n<pre><code>using RF.Extensions.Iteration;\n...\n2.IterateTo(5, i => Console.WriteLine(i));\n(-10).IterateTo(-12, i => Console.WriteLine(i));\n2.IterateTo(20, c => c + 2, i => Console.WriteLine(i));\n</code></pre>\n<p>Sadly, the usage is not quite as cool as in the Ruby version, yet we have another way to express concise code. I can't wait for nice extension libraries that will provide extensions to well known objects for given scenarios. I'll probably start my own. If anyone has a nice idea that should find its way in the RF extension library, let me know.</p>","frontmatter":{"date":"April 01, 2007","path":null,"title":"C# 3.0 - Hair extensions for wanna-be rubyists","tags":["software-development","ruby","dotnet"]}}},"pageContext":{"title":"C# 3.0 - Hair extensions for wanna-be rubyists"}}