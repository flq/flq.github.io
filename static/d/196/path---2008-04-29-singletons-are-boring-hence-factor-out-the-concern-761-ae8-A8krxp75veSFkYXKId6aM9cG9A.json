{"data":{"markdownRemark":{"html":"<p><a href=\"http://www.dotnetkicks.com\">dotnetkicks</a> has an astonishing amount of entries related to <a href=\"http://www.dotnetkicks.com/search?q=singleton\">\"The Singleton\"Â®</a>...</p>\n<p>Regardless of whether Singletons are considered harmful or not, I could not resist but provide you with my own take on factoring out the need to get a Singleton which doesn't feel like a Singleton at all. We can single-ton out any classes that provide a default constructor. Due to the reflection spice you can provide a private one as well. Takes somewhat longer, but you're only doing it once, don't you ;) ?</p>\n<pre><code class=\"language-csharp\">class SingletonOf&#x3C;T> where T : class\n{\n    static T instance = (T)Activator.CreateInstance(typeof(T), true);\n\n    public static implicit operator T (SingletonOf&#x3C;T> singleton) {\n        return SingletonOf&#x3C;T>.instance;\n    }\n}\n</code></pre>\n<p>The implicit operator makes it possible to do this:</p>\n<pre><code class=\"language-csharp\">Person p = new SingletonOf&#x3C;Person>();\nPerson p2 = new SingletonOf&#x3C;Person>();\nDebug.Assert(object.ReferenceEquals(p, p2), \"W00t?! They should be equal!\");\n</code></pre>\n<p>Doesn't it look funny? I find it quite likeable and you definitely don't pollute the class in question with some singleton boilerplate. I would like to say \"Go forth and multiply\" but it seems wholly inappropriate for the issue at hand...</p>","frontmatter":{"date":"April 29, 2008","path":null,"title":"Singletons are boring, hence factor out the concern","tags":["software-development","dotnet","patterns"]}}},"pageContext":{"title":"Singletons are boring, hence factor out the concern"}}