{"data":{"markdownRemark":{"html":"<h2>Functional space-invaders series</h2>\n<ol>\n<li><a href=\"/2013/09/17/FunSpIns-a-recap-of-Rob-Ashtons-lessons-Das-Intro\">A recap of Rob Ashton's lessons - Das Intro</a></li>\n<li><a href=\"/2013/09/18/FunSpIns-Drawing-a-Rectangle\">Drawing a Rectangle</a></li>\n<li><a href=\"%7B%25%20post_url%202013-9-19-FunSpIns-Moving-a-Rectangle%20%25%7D\">Moving a Rectangle</a></li>\n<li>No attributes, No vectors, A tiny Workflow and more squares</li>\n<li><a href=\"%7B%25%20post_url%202013-9-23-FunSpIns-State-the-World-the-Loop%20%25%7D\">State, the World, the Loop</a></li>\n<li><a href=\"%7B%25%20post_url%202013-9-24-FunSpIns-The-hero-must-move-the-enemies-must-move-smarter%20%25%7D\">The hero must move, the enemies must move smarter</a></li>\n<li><a href=\"%7B%25%20post_url%202013-9-25-FunSpIns-The-hero-shoots%20%25%7D\">The hero shoots</a></li>\n<li><a href=\"%7B%25%20post_url%202013-9-26-FunSpIns-Collisions-the-dead-and-a-not-so-grateful-ending%20%25%7D\">Collisions, the dead, and a (not so) grateful ending</a></li>\n</ol>\n<blockquote>\n<p>Inspired by Rob Ashton's series \"<a href=\"http://codeofrob.com/entries/learn-functional-programming-with-me---attributes-and-vectors.html\">Learn</a> <a href=\"http://codeofrob.com/entries/learn-functional-programming-with-me---improving-my-workflow.html\">functional</a> <a href=\"http://codeofrob.com/entries/learn-functional-programming-with-me---adding-lots-more-state.html\">programming with me</a>\"</p>\n</blockquote>\n<p>This post kind of covers 3 of Rob's posts, as, frankly, I can't say much about attributes - in Rob's case it refers to the DOM, which we don't have here.\nWhy he would mention Vectors? I don't know, maybe to sound fancy ;)  </p>\n<p>When it comes to the working workflow in Haskell, my tool of choice right now is the interactive haskell (<em>ghci</em>) - saying <strong><em>:load game</em></strong> (provided I have a game.hs lying around) will either tell me that all is cool or throw relevant compiler errors at me, which usually is some form of elaborate type mismatch (<em>90%</em>) or a syntax error (<em>9%</em>) with an error margin of Â±1%.</p>\n<p>As to drawing lots of enemies, functional approaches should be somewhat similar. The permutation thing that Rob does with the <strong>(for [x [...]] [y [...]])</strong> is also achieved with list comprehensions, just that you have to specify two ranges to feed the output. Here is a function to give us a grid of squares:</p>\n<pre><code>enemyGrid (originX,originY) (rows, cols) = \n  map toRect [ (x, y) | x &#x3C;- take cols [originX,originX+60..], y &#x3C;- take rows [originY,originY+30..]]\n  where\n    toRect (x,y) = Rect x y 20 10\n</code></pre>\n<p>Providing two comma-separated values to the Haskell range (the <strong>[n..m]</strong> thing, or here, the <strong>[n, n+s, ..]</strong>) defines the step of the range. Due to the lazy nature of Haskell,\nI can leave the range open ended. The <em>breaking condition</em> is that I just <strong>take</strong> as many values as I want (columns and rows, respectively).</p>\n<p>These little buggers need to be fed into the drawing API, which we can do as such:</p>\n<pre><code>canvas &#x3C;- FX.getVideoSurface\nmapM (\\r -> FX.fillRect canvas (Just r) white) $ enemyGrid (10,10) (5, 10)\nFX.flip canvas\n</code></pre>\n<p><strong>mapM</strong> is again the monadic version of map<sup>*)</sup>, required to create something wrapped in IO context. The <strong>(\\r -></strong> denotes the start of a lambda, while <strong>$</strong> influences associativity such that I spare myself surrounding the <strong>enemyGrid</strong> call with brackets.</p>\n<p><sup>*) or Select, for the LINQ folks crazy enough to have followed this so far)</sup> </p>","frontmatter":{"date":"September 20, 2013","path":null,"title":"FunSpIns - No attributes, No vectors, A tiny Workflow and more squares","tags":["software-development","haskell","fun-spin"]}}},"pageContext":{"title":"FunSpIns - No attributes, No vectors, A tiny Workflow and more squares"}}