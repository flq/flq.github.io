{"data":{"markdownRemark":{"html":"<p>This post is about how the feature of listening to morse sounds when pressing the button...</p>\n<p><img src=\"/public/assets/play-morse-button.png\" alt=\"ts auto-complete\"></p>\n<p>...is implemented.</p>\n<ul>\n<li><a href=\"#reactredux\">react/redux</a></li>\n<li><a href=\"#elm\">elm</a></li>\n</ul>\n<h3>react/redux</h3>\n<p>Let's start with the user interaction <a href=\"https://github.com/flq/remorse/blob/834762ec8185fa024160c397a07000e6cd7667fd/src/TypingScreen/TypingScreen.js#L37-L43\">in the UI</a>:</p>\n<pre><code class=\"language-html\">&#x3C;input\n    type=\"button\"\n    className=\"soundButton\"\n    value=\"&#x26;#128266;\"\n    onClick={playSound} />\n</code></pre>\n<p><code>playSound</code> is an action that is surfaced through react-redux' <code>connect</code>-functionality. The action <a href=\"https://github.com/flq/remorse/blob/834762ec8185fa024160c397a07000e6cd7667fd/src/TypingScreen/Actions.js#L23-L28\">looks like that</a>:</p>\n<pre><code class=\"language-javascript\">export function playSound() {\n  return async (dispatch, getState) => {\n    const { userInput, soundSpeed } = getState().typing;\n    textAsMorseSound(userInput, soundSpeed);\n  };\n}\n</code></pre>\n<p>This type of function is supported by the <a href=\"https://github.com/gaearon/redux-thunk\">redux-thunk</a> middleware, which provides the dispatch and getState functions to be able to perform <em>side-effects</em> within a user-UI interaction. <a href=\"https://github.com/flq/remorse/blob/834762ec8185fa024160c397a07000e6cd7667fd/src/components/SoundLib.js#L32\">Digging deeper</a>: </p>\n<pre><code class=\"language-javascript\">export async function textAsMorseSound(input, soundSpeed) {\n  for (let c of Array.from(input)) {\n    var code = charToMorseCode(c);\n    await asyncPlayMorse(Array.from(code), soundSpeed);\n    await delay(DASH_LENGTH / soundSpeed); // Pause between chars\n  }\n}\n//...\nexport function delay(millisecs, value = null) {\n  return new Promise((res, rej) => {\n    setTimeout(() => res(value), millisecs);\n  });\n}\n</code></pre>\n<p>The async/await, part of ES2017, but already available through babeljs-transpiling, allows you to work with promises much like you do with Tasks in the post .NET 4.5 world.\nThis makes the code that performs the necessary time delays <a href=\"https://github.com/flq/remorse/blob/834762ec8185fa024160c397a07000e6cd7667fd/src/components/SoundLib.js#L40-L64\">much easier to read</a>. </p>\n<pre><code class=\"language-javascript\">// characters: Array of strings like \"-\" and \".\" and \" \"\nexport async function asyncPlayMorse(characters, soundSpeed = 1) {\n  for (let c of characters) {\n    switch (c) {\n      case \".\":\n        startSound();\n        await delay(DOT_LENGTH / soundSpeed);\n        stopSound();\n        await delay(DOT_LENGTH / soundSpeed);\n        break;\n      case \"-\":\n        startSound();\n        await delay(DASH_LENGTH / soundSpeed);\n        stopSound();\n        await delay(DOT_LENGTH / soundSpeed);\n        break;\n      case \" \":\n        await delay(PAUSE / soundSpeed);\n        break;\n      default:\n        console.log(c);\n        break;\n    }\n  }\n}\n</code></pre>\n<p>Finally <code>startSound</code> and <code>stopSound</code> connect and disconnect the oscillator that <a href=\"https://github.com/flq/remorse/blob/834762ec8185fa024160c397a07000e6cd7667fd/src/components/SoundLib.js#L14-L30\">is set up</a> to the audio output of the browser.</p>\n<h3>elm</h3>\n<p>As you can imagine, not every single browser API is surfaced to elm - hence the concept of defining ports, a subsystem that allows you to interop to plain javascript and its access to all of the browser's API.\nTherefore, we go ahead and <a href=\"https://github.com/flq/elmorse/blob/ce330e70098106e988d92059c3762708c43646f5/src/Interop.elm#L5-L6\">define ports</a> to start and stop the sound:</p>\n<pre><code class=\"language-javascript\">port audioOn : () -> Cmd msg\nport audioOff : () -> Cmd msg\n</code></pre>\n<p>In javascript, we need to fill these ports <a href=\"https://github.com/flq/elmorse/blob/ce330e70098106e988d92059c3762708c43646f5/src/Typing/audioPort.js#L23-L35\">with life</a>:</p>\n<pre><code class=\"language-javascript\">export function initAudioPort(elmApp) {\n  let isConnected = false;\n  elmApp.ports.audioOn.subscribe(function() {\n    if (isConnected) return;\n    oscillator.connect(audioCtx.destination);\n    isConnected = true;\n  });\n  elmApp.ports.audioOff.subscribe(function() {\n    if (!isConnected) return;\n    oscillator.disconnect(audioCtx.destination);\n    isConnected = false;\n  });\n}\n\n// which is used like that:\nconst app = Main.embed(document.getElementById('root'));\ninitAudioPort(app);\n</code></pre>\n<p>Now that we have this in place, we can stay in elm to implement the functionality. Let's <a href=\"https://github.com/flq/elmorse/blob/ce330e70098106e988d92059c3762708c43646f5/src/Typing/View.elm#L36-L40\">start in the UI</a> again:</p>\n<pre><code class=\"language-javascript\">input [\n  type_ \"button\", \n  class \"soundButton\", \n  onClick OnListenToMorse,\n  value \"Play Morse\" ] []\n</code></pre>\n<p><code>OnListenToMorse</code>is a defined message that needs to be handled in the <code>update</code> function of your application.</p>\n<pre><code class=\"language-sql\">update msg model = \n  case msg of\n    -- stuff\n    OnListenToMorse ->\n      (model, Audio.playWords model.userInput model.morseSpeed)\n</code></pre>\n<p>Just like in the redux app, where I didn't show any reducer code, implying that nothing changes in the application's model, the only reaction here consists of initiating a <em>side-effect</em>.\n<a href=\"https://github.com/flq/elmorse/blob/8db340ed97ffe00ae075d7cca4236962b8336570/src/Typing/MorseAudio.elm#L37-L41\">What happens in</a> <code>playWords</code> ?</p>\n<pre><code class=\"language-sql\">playWords : String -> Float -> Cmd Msg\nplayWords words factor = \n  stringToMorseSymbols words\n  |> List.map (convertSymbolToCommands factor)\n  |> bringTogether\n\n-- type of stringToMorseSymbols: String -> List MorseSymbol\n\nconvertSymbolToCommands: Float -> MorseSymbol -> List (Milliseconds, Msg)\nconvertSymbolToCommands factor symbol =\n  let\n    adapt (millisecs, msg) = (millisecs / factor, msg)\n    adaptAll = List.map adapt\n  in\n    adaptAll &#x3C;| case symbol of\n      Dot -> playDot\n      Dash -> playDash\n      ShortPause -> playBetweenChars\n      LongPause -> playBetweenWords\n      Garbled -> playBetweenWords\n\n-- example of the \"play\" functions:\n\nplayDot: List (Milliseconds, Msg)\nplayDot =  \n  [\n    (0, (SoundMsg StartSound)),\n    (dotLength, (SoundMsg StopSound)),\n    (pauseBetweenChars, NoOp)\n  ]\n\n-- from tuples to commands\n\nbringTogether : List (List ( Milliseconds, Msg )) -> Cmd Msg\nbringTogether = List.concat >> List.map toSequenceTuple >> sequence\n</code></pre>\n<p>In other words, first the user input is converted to a list of morse symbols.\nThis is then processed to a <strong>list of list of tuples</strong> that state at\nwhich relative time in milliseconds which message should be piped into the update function (See e.g. <code>Dot -> playDot + applying speed factor</code>).</p>\n<p>The final ingredient to this magic is the <strong>sequence</strong> function from the elm package <a href=\"http://package.elm-lang.org/packages/andrewMacmurray/elm-delay/latest/Delay#sequence\">delay</a>. <a href=\"https://github.com/andrewMacmurray/elm-delay/blob/2.0.2/src/Delay.elm\">The code</a> is actually not super-complex,\nit does the necessary plumbing to call out to <strong>Process.sleep</strong> the elm equivalent to javascript's <code>setTimeout</code>.</p>\n<p>What happens then, when the <code>SoundMsg StartSound</code> and <code>StopSound</code> messages are received?</p>\n<pre><code class=\"language-sql\">update msg model = \n  case msg of\n    -- stuff\n    SoundMsg msg -> \n      Audio.update msg model\n\n-- In audio update:\n\nupdate : SoundMsg -> Model -> (Model, Cmd Msg)\nupdate msg model =\n  case msg of\n    StartSound -> (model, audioOn ())\n    StopSound -> (model, audioOff ())\n</code></pre>\n<p>And <a href=\"https://github.com/flq/elmorse/blob/8db340ed97ffe00ae075d7cca4236962b8336570/src/Typing/MorseAudio.elm#L17-L21\">here is where</a> you finally find the calls to the interop ports we defined to connect and disconnect the Oscillator :)</p>\n<p>Which route do you prefer?</p>","frontmatter":{"date":"August 21, 2017","path":null,"title":"react/redux to elm feature comparison: playing morse sounds","tags":["web","programming","javascript"]}}},"pageContext":{"title":"react/redux to elm feature comparison: playing morse sounds"}}