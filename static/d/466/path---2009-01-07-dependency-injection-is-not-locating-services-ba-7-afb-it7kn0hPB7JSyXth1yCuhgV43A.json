{"data":{"markdownRemark":{"html":"<p>The DI container StructureMap has been coming along nicely lately, with version 2.5.1 <a href=\"http://sourceforge.net/projects/structuremap\">available as download</a>. I have been following closely its recent development, since it is providing some core object wiring functionality to my current project.</p>\n<p>A rather inviting pattern one can be lured into in DI container usage is using the container as service locator:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">public ShippingScreenPresenter()\n{\n  _service = ObjectFactory.GetInstance&lt;IShippingService&gt;();\n  _repository = ObjectFactory.GetInstance&lt;IRepository&gt;();\n}</code></pre></div>\n<p>(This example is taken straight from Jeremy's <a href=\"http://codebetter.com/blogs/jeremy.miller/archive/2009/01/07/autowiring-in-structuremap-2-5.aspx\">recent StructureMap post</a>)</p>\n<p>As simple as it looks, splattering references to some \"ObjectFactory\" all over your code contradicts why you may be using the container in the first place: To simplify keeping concerns separated and removing responsibility of instantiation from classes, thereby simplifying coding against abstractions.</p>\n<p>StructureMap also has the notion of named instances, i.e. objects that are not retrieved as default but are rather stored under a key which must be used to retrieve said instance again. StructureMap can even provide you with named instances (or custom instances) when doing constructor-based injection. It may look something like that (taken from a StructureMap registry, the place to configure object dependencies):</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">ForRequestedType&lt;Form&gt;()\n  .CacheBy(InstanceScope.Singleton)\n  .TheDefault.Is.OfConcreteType&lt;MainForm&gt;()\n  .CtorDependency&lt;IApplicationModule&gt;().Is(a=&gt;a.TheInstanceNamed(&quot;MainModule&quot;));</code></pre></div>\n<p>In another scenario I have the problem that a class needs to obtain instances based on code that will provide an instance name. Here starting to use the ObjectFactory as service locator is ever so inviting. However, there is a simple way to provide some straightforward decoupling from the ObjectFactory. I delegate the resolving of object to an...ObjectResolver. This class is generic and the provided type argument sets what kind of types are being looked up. The implementation is very straightforward:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">public class ObjectResolver&lt;T&gt; where T : class\n{\n  public virtual T this[string key] { \n    get { \n      return ObjectFactory.GetNamedInstance&lt;T&gt;(key); \n    }\n  }\n}</code></pre></div>\n<p>Now I can express the dependency to an ObjectResolver as with any other type in the constructor:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">public class CommandMediator {\n  ctor(ObjectResolver&lt;ICommand&gt; cmdResolver) {\n    ...\n  }\n\n  public void Foo() {\n    var cmd = cmdResolver[&quot;Save&quot;];\n    Assert.That(cmd != null);\n  }\n}</code></pre></div>\n<p>In what way is this better than doing service locating?</p>\n<ul>\n<li>For a common scenario, the tie to StructureMap for resolving named instances is reduced to a single class.</li>\n<li>If you wanted, replacing the lookup scheme for instances is fairly easy.</li>\n<li>Since the ObjectResolver is a concrete class, StructureMap can effortlessly instantiate it such that you don't need a single line of configuration to use it.</li>\n<li>You can satisfy a dependency to the ObjectResolver without instantiating any DI container.</li>\n</ul>\n<p>Check out the following code that uses <a href=\"http://ayende.com/projects/rhino-mocks.aspx\">Rhino Mocks</a> to provide a satisfying response within a test:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">public void MediatorWillInstantiateSaveCommand {\n  var cmd = new Command();\n  var resolver = MockRepository.GenerateMock&lt;ObjectResolver&lt;ICommand&gt;&gt;();\n  resolver.Expect(r=&gt;r[null]).Constraints(Is.Equal(&quot;Save&quot;)).Return(cmd);\n  var mediator = new CommandMediator(resolver);\n  mediator.Foo();\n  resolver.VerifyAllExpectations();\n}</code></pre></div>\n<p>What I am trying to say is: Put some effort into your code when you see yourself using a DI Container as Service Locator. It is most likely to pay off in several ways.</p>","frontmatter":{"date":"January 07, 2009","path":null,"title":"Dependency Injection is not locating services","tags":["dotnet","patterns","libs-and-frameworks"]}}},"pageContext":{"title":"Dependency Injection is not locating services","previous":{"fields":{"slug":"/2008/12/08/iterators-do-1"},"frontmatter":{"title":"Iterators do [1..]","tags":["software-development","dotnet","libs-and-frameworks"],"date":"2008/12/08"}},"next":{"fields":{"slug":"/2009/01/31/playing-lotto-with-linq"},"frontmatter":{"title":"Playing Lotto with LINQ","tags":["dotnet","geekdom","loosely-coupled"],"date":"2009/01/30"}}}}