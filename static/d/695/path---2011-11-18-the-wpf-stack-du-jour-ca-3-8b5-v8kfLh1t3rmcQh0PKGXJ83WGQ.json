{"data":{"markdownRemark":{"html":"<p>For the past year i've had plenty of possibility to get my head around WPF as a UI technology.\nIn that time a number of frameworks have crystallized that in their combination makes writing good WPF Apps, let's say, bearable:</p>\n<ul>\n<li><a href=\"http://caliburnmicro.codeplex.com/\">Caliburn.Micro</a></li>\n<li><a href=\"https://github.com/structuremap/structuremap\">StructureMap</a></li>\n<li><a href=\"https://github.com/flq/MemBus\">Membus</a></li>\n</ul>\n<h2>Caliburn.Micro:</h2>\n<p><strong>What it brings to the table</strong>: </p>\n<ul>\n<li>Conventional wiring of ViewModel->View, </li>\n<li>conventional and extendable wiring of UI elements to elements of the Viewmodel, </li>\n<li>Interfaces that allow you to cleanly describe the lifecycles of your ViewModels, </li>\n<li>a nice hook to get your favorite DI Container doing instantiation work for you</li>\n<li>A nice attached property to get out of corner cases when needing View events in ViewModels.</li>\n</ul>\n<p><strong>What it should bring to the table</strong>: Not much really, I prefer that thing to stay low-profile.</p>\n<p><strong>What it shouldn't bring to the table</strong>: I can't find a use case for the coroutine implementation, I don't need the event aggregator (see MemBus), it's unlikely I'll ever need all those default conductors already defined.</p>\n<h2>StructureMap</h2>\n<p><strong>What it brings to the table</strong>: Fufils all instantiation needs you'll ever have, served to you in a non-ceremomial way that puts the current MEF incarnation to shame.</p>\n<p><strong>What it should bring to the table</strong>: Some funky things I am beginning to desire after a couple of years of DI Container usage.</p>\n<h2>MemBus</h2>\n<p><strong>What it brings to the table</strong>: Fulfils all \"event aggregation\" needs you'll ever have. Seamless wiring of ViewModels to messages, in-built mechsnism to ensure messages are processed on the UI thread or processed in the background, extensible to allow your own interesting scenarios around app-internal messaging.</p>\n<p><strong>What it should bring to the table</strong>: I am still wondering whether correlated messaging could be useful (publishing a message with id x and then receiving messages in the context of that id)</p>\n<p><strong>What it doesn't need to bring to the table</strong>: Funny enough there is quite a bit of API I don't need anymore, because it can be expressed in a different way that seems more attractive and maintainable. I'll probably mark those bits as obsolete.</p>\n<p>This <em>package</em>, sprinkled with a number of goodies which I usually don't bother making a dll of (for example the <a href=\"http://realfiction.net/go/198\">DataTemplateChoice</a>, or an attached property to influence Focus from the ViewModel, or a key binding service with a simple API that saves me the trouble to know the goddamn visual tree all the time) allows for a pretty quick development speed while maintaining a fairly clean overall structure and keeping a number of hooks and tools around to tackle more challenging stuff.</p>","frontmatter":{"date":"November 18, 2011","path":null,"title":"The WPF stack du jour","tags":["dotnet","libs-and-frameworks"]}}},"pageContext":{"title":"The WPF stack du jour"}}