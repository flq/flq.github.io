{"data":{"markdownRemark":{"html":"<p>A few days ago, Michael Feathers tweeted this:</p>\n<blockquote class=\"twitter-tweet\" data-lang=\"en\"><p lang=\"en\" dir=\"ltr\">The fact that many simple correct Ruby programs become ridiculously complex when translated to other languages means something.</p>&mdash; Michael Feathers (@mfeathers) <a href=\"https://twitter.com/mfeathers/status/864122686695460866\">May 15, 2017</a></blockquote> <script async src=\"//platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n<p>Now, I am not a complete [stranger to ruby][1], which is why this statement resonated with me, and upon requesting an example, Michael came up with this:</p>\n<blockquote class=\"twitter-tweet\" data-conversation=\"none\" data-lang=\"en\"><p lang=\"en\" dir=\"ltr\"><a href=\"https://twitter.com/fquednau\">@fquednau</a> The simple ones are interesting. Try this in C#: ([0] + arr).each_cons(2).count {|x,y| x == 0 &amp;&amp; y == 1 }</p>&mdash; Michael Feathers (@mfeathers) <a href=\"https://twitter.com/mfeathers/status/864222881538072578\">May 15, 2017</a></blockquote> <script async src=\"//platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\nor\n<pre><code class=\"language-ruby\">([0] + arr).each_cons(2).count {|x,y| x == 0 &#x26;&#x26; y == 1 }\n</code></pre>\n<blockquote>\n<p>[each_cons][2] is a function that provides consecutive elements\nof a given list. E.g.\n<code>[0,1,2,3].each_cons(3).each { |x,y,z| puts \"#{x},#{y},#{z}\" }</code>\nIt can be useful for obtaining info about the local structure\nof a list. Think derivatives, rates of change, etc. and probably\na host of other things.</p>\n</blockquote>\n<p>This does indeed show off ruby's expresiveness quite nicely:</p>\n<ul>\n<li>A simple syntax to concatenate lists</li>\n<li>A rich set of libraries for manipulation of things (I am referring to the <em>each\\</em>cons_)</li>\n<li>The syntax of ruby's yields and blocks, which have been used so many times as the syntactical basis for DSLs</li>\n</ul>\n<p>The fact that the parameter influences how many items will be yielded into\nyour block reminds us why all of us like to write Javascript once in a while.</p>\n<p><strong>What about other languages then?</strong></p>\n<h3>F\\</h3>\n<p>Let's look at the code which performs (almost) the same job:</p>\n<pre><code class=\"language-fsharp\">seq { yield 0; yield! {1..4} }\n  |> Seq.pairwise \n  |> Seq.filter (fun (x,y) -> x = 0 &#x26;&#x26; y = 1)\n  |> Seq.length\n</code></pre>\n<p>It is pretty compact and readable, but even though some things look\nsimilar, they actually use completely different mechanics of the\nlanguage</p>\n<ul>\n<li>The first line is a [computational expression to generate sequences][4] which provides\nus with a pretty syntax for concatenating elements and lists of elements</li>\n<li>The <em>pairwise</em> is the closest we get to <em>each\\</em>cons_</li>\n<li>The <em>length</em> does not have a version where we can provide a filter condition, so we\nneed to specify the filter beforehand.</li>\n<li>The <em>pairwise</em> method provides a tuple which is then pattern matched into two arguments in the\nlambda to <em>filter</em>.</li>\n</ul>\n<p>Of note is that <em>pairwise</em> will provide exactly 2 consecutive elements of a list, it\ndoes not allow a parameter like the ruby version. This makes sense, since F# is statically typed.\nIf you wanted a version that provides 3 consecutive elements, you would have to write a method\nyourself that yields an element of type <strong>(a,a,a)</strong>.</p>\n<h3>C\\</h3>\n<p>To actually achieve the same level of expressiveness we need to put some work into this:</p>\n<p><img src=\"/public/assets/csharp_cons.jpg\"></p>\n<p>With those two additional extension methods we can now write</p>\n<pre><code class=\"language-csharp\">0.ToEnumerable().Concat(arr).Windowed().Count(t => t.x == 0 &#x26;&#x26; t.y == 1);\n</code></pre>\n<p>While tuples are now available in c#, you cannot deconstruct them like you can do in most other\nfunctional languages or even in ES2016\n(which has actually gone to great lengths to make deconstruction a dependable feature).</p>\n<p>While I can kind of forgive a missing <em>each\\</em>cons<em>-like BCL method, I write the _ToEnumerable</em> again in almost every project. I mean, that method is the damned [unary return operation][6]!</p>\n<h3>Kotlin</h3>\n<p>Xavier Lepaul chimed in with a view on what Kotlin is up to with respect to the challenge:</p>\n<blockquote class=\"twitter-tweet\" data-conversation=\"none\" data-lang=\"en\"><p lang=\"en\" dir=\"ltr\"><a href=\"https://twitter.com/mfeathers\">@mfeathers</a> <a href=\"https://twitter.com/fquednau\">@fquednau</a> Kotlin is almost there (with <a href=\"https://t.co/b2TpoX5LqA\">https://t.co/b2TpoX5LqA</a>)<br>(listOf(0) + arr).windowed(2).count {(x,y) -&gt; x == 0 &amp;&amp; y == 1}</p>&mdash; Xavier Lepaul (@xlepaul) <a href=\"https://twitter.com/xlepaul/status/864404258476752896\">May 16, 2017</a></blockquote> <script async src=\"//platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n<pre><code class=\"language-java\">(listOf(0) + arr).windowed(2).count {(x,y) -> x == 0 &#x26;&#x26; y == 1}\n</code></pre>\n<p>This doesn't fall very short of the ruby example, however, the <em>windowed</em> is not available yet in\nKotlin 1.1 - What I particularly liked is that even though the type signature of <em>windowed</em> is</p>\n<pre><code class=\"language-java\">fun &#x3C;T> Iterable&#x3C;T>.windowed(size: Int, step: Int): List&#x3C;List&#x3C;T>>\n</code></pre>\n<p>i.e. returning a list of lists, one can still deconstruct the list into the x and y you can\nsee in the lambda provided to <em>count</em>. This works because the deconstruction in kotlin simply\nstarts working when the deconstructed object provides methods named <em>component1</em> down to\n<em>componentN</em>. A quick look at Kotlin's list type...</p>\n<p><img src=\"/public/assets/kotlin_destructure.png\"></p>\n<p>Kudos to the Kotlin team which make a language that feels functional with strategies that are\nvery different to a \"real\" functional language. I have been an outsider to the JVM most of my\ntime, but when you get to know Java and Kotlin I really cannot fathom what exactly would make you\nstick to Java.</p>\n<h3>Type safety vs elegance?</h3>\n<p>In order for ruby and Kotlin to shine in this example, both pay up by allowing misunderstandings\nin API use to surface only at runtime. Note that in both languages the compiler will happily allow\nyou to capture more or less output than <em>each\\</em>cons<em>/</em>windowed_ actually provides. This seems to be\nthe price you need to pay for such an API, since the output <em>\"type\"</em> is determined by the argument to the windowing function. Now if there was a language where types\ncould be determined programmatically...</p>\n<h3>Idris</h3>\n<p>[Idris][7] is a programming language which is close in spirit to Haskell but adds the capability\nto define <em>dependent types</em>. </p>\n<blockquote>\n<p>Disclaimer: I have never worked with Idris before, I just had the vague idea that dependent\ntypes could be what I was looking for in this moment. Most of the things in Idris continue\nto be outside my grasp. Many, many thanks go out to <strong>Anton Trunov</strong> who\n[answered][8] my stackoverflow [questions][9].</p>\n</blockquote>\n<p>In this language, we can define the following type signature for a method:</p>\n<pre><code class=\"language-haskell\">window : (n : Nat) -> List a -> List (Vect n a)\n</code></pre>\n<p>This describes a method that takes a natural number <strong>n</strong>,\nand a list containing things with type <strong>a</strong> and then returns a list containing vectors of length <strong>n</strong>. <strong>n</strong> has now become part of the type definition for <strong>Vect</strong>. With much help\n(I couldn't see how to make the leap from the variable length <strong>List a</strong> to the type <strong>Vect n a</strong>),\nthis is then one possible implementation of <em>windowed</em> in Idris: </p>\n<pre><code class=\"language-haskell\">total\ntakeExact : (n : Nat) -> (xs : List a) -> Maybe (Vect n a)\ntakeExact Z xs = Just []\ntakeExact (S n) [] = Nothing\ntakeExact (S n) (x :: xs) with (takeExact n xs)\n  takeExact (S n) (x :: xs) | Nothing = Nothing\n  takeExact (S n) (x :: xs) | (Just v) = Just (x :: v)\n\n\ntotal\nwindow : (n : Nat) -> List a -> List (Vect n a)\nwindow n xs with (takeExact n xs)\n  window n xs | Nothing = []\n  window n [] | (Just ys) = []\n  window n (x :: xs) | (Just ys) = ys :: window n xs\n</code></pre>\n<blockquote>\n<p><em>total</em> tells the Idris compiler to check the method whether it is indeed total as far as\nIdris is capable to tell. Total means that this method is guaranteed to return for whatever\ninput that is provided. <strong>Z</strong> and <strong>S</strong> are types representing <strong>Zero</strong>\nand <strong>Successor</strong> within the Natural number type.</p>\n</blockquote>\n<p>Now we can use the window function to write down the example provided.</p>\n<pre><code class=\"language-haskell\">--with\ncondition : Vect 2 Integer -> Bool\ncondition [x,y] = x == 0 &#x26;&#x26; y == 1\n\n*hello> length $ filter condition (window 2 $ 0::[1,2,3,4])\n1 : Nat\n</code></pre>\n<p>It is also pretty compact, with the <em>little</em> difference that the filter function provided must\ndeconstruct a Vector of type <strong>Vect 2 Integer</strong>, based on the arguments to the <em>window</em> function. That is, in your function you are forced to take the vector as a whole or deconstruct to exactly\nthe right size that is provided.</p>\n<p>Why is all this interesting? Because it is sometimes plain <em>fun</em> to compare different programming\nlanguages. They present to you different ways of thinking, different ways to express your intentions. One common theme is that conciseness comes when you get close to functional programming idioms. Also, before this post I didn't think that you could actually expand upon the\nHaskell type system, but you can. Alas, we also have to recognize the great popularity of languages like ruby. Reasoning with types requires much practice, but help you squash bugs before you even get to the runtime. Languages like javascript and ruby reward you quickly when you get your act together, but depend on decent documentation to get API usage right.</p>\n<p>Hence, ruby is indeed expressive, but quite a few popular languages have learned to recreate that expressiveness with the possibilities that their respective runtimes provide.</p>\n<p>[1]: {% link tag/ruby.md %}\n[2]: <a href=\"https://ruby-doc.org/core-2.1.0/Enumerable.html#method-i-each_cons\">https://ruby-doc.org/core-2.1.0/Enumerable.html#method-i-each_cons</a>\n[3]: <a href=\"https://github.com/Kotlin/KEEP/blob/master/proposals/stdlib/window-sliding.md\">https://github.com/Kotlin/KEEP/blob/master/proposals/stdlib/window-sliding.md</a>\n[4]: <a href=\"https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/sequences\">https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/sequences</a>\n[5]: <a href=\"http://stackoverflow.com/questions/44078891/how-do-i-evaluate-this-recursive-function-in-idris-interactive\">http://stackoverflow.com/questions/44078891/how-do-i-evaluate-this-recursive-function-in-idris-interactive</a>\n[6]: <a href=\"https://en.wikipedia.org/wiki/Monad_(functional_programming)#Overview\">https://en.wikipedia.org/wiki/Monad<em>(functional</em>programming)#Overview</a>\n[7]: <a href=\"http://docs.idris-lang.org\">http://docs.idris-lang.org</a>\n[8]: <a href=\"http://stackoverflow.com/questions/44078891/how-do-i-evaluate-this-recursive-function-in-idris-interactive\">http://stackoverflow.com/questions/44078891/how-do-i-evaluate-this-recursive-function-in-idris-interactive</a>\n[9]: <a href=\"http://stackoverflow.com/questions/44079181/idris-vect-fromlist-usage-with-generated-list\">http://stackoverflow.com/questions/44079181/idris-vect-fromlist-usage-with-generated-list</a></p>","frontmatter":{"date":"May 22, 2017","path":null,"title":"each_cons - the wise and tall of popular languages","tags":["programming","ruby","csharp","fsharp","haskell"]}}},"pageContext":{"title":"each_cons - the wise and tall of popular languages"}}