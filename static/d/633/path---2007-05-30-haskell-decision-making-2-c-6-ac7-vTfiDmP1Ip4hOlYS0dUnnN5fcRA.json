{"data":{"markdownRemark":{"html":"<p>A few days ago, while I was implementing something in PL/SQL for that dreaded Oracle Forms project I had to code some scary if-else construct spanning two logic checks that depending on the combination gave four different results. </p>\n<div class=\"gatsby-highlight\" data-language=\"fsharp\"><pre class=\"language-fsharp\"><code class=\"language-fsharp\"><span class=\"token keyword\">if</span> a<span class=\"token operator\">=</span><span class=\"token keyword\">true</span> <span class=\"token keyword\">and</span> b<span class=\"token operator\">=</span><span class=\"token keyword\">true</span> <span class=\"token keyword\">then</span> <span class=\"token number\">1</span>\nelsif a<span class=\"token operator\">=</span><span class=\"token keyword\">true</span> <span class=\"token keyword\">and</span> b<span class=\"token operator\">=</span><span class=\"token keyword\">false</span> <span class=\"token keyword\">then</span> <span class=\"token number\">2</span>\nelsif a<span class=\"token operator\">=</span><span class=\"token keyword\">false</span> <span class=\"token keyword\">and</span> b<span class=\"token operator\">=</span><span class=\"token keyword\">true</span> <span class=\"token keyword\">then</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> </code></pre></div>\n<p>Back in the train on the way home I had a look if my limited Haskell knowledge could come up with something nicer.</p>\n<p>This post presents the first version of such a program that tries to give an answer. It is likely that other posts may refer back to this, once my brain has digested e.g. this <a href=\"http://www.randomhacks.net/articles/2007/03/12/monads-in-15-minutes\">'Random hack'</a>.</p>\n<p>Let us start with the type definitions, logic constraints and result data:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token keyword\">type</span> <span class=\"token constant\">Input</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Int</span> <span class=\"token punctuation\">;</span> <span class=\"token keyword\">type</span> <span class=\"token constant\">Output</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Int</span>\n<span class=\"token keyword\">type</span> <span class=\"token constant\">PosX</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Int</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">type</span> <span class=\"token constant\">PosY</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Int</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">type</span> <span class=\"token constant\">DecisionOutput</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Bool</span>\n<span class=\"token keyword\">type</span> <span class=\"token constant\">DecisionTuple</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">PosY</span><span class=\"token punctuation\">,</span><span class=\"token constant\">PosX</span><span class=\"token punctuation\">,</span><span class=\"token constant\">DecisionOutput</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">type</span> <span class=\"token constant\">Decider</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span><span class=\"token constant\">Input</span><span class=\"token operator\">-></span><span class=\"token constant\">DecisionOutput</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">data</span> <span class=\"token constant\">Solution</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Solution</span> <span class=\"token punctuation\">[</span><span class=\"token constant\">DecisionTuple</span><span class=\"token punctuation\">]</span> <span class=\"token constant\">Output</span>\n\n<span class=\"token hvariable\">deciderGates</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">[</span><span class=\"token constant\">Decider</span><span class=\"token punctuation\">]</span>\n<span class=\"token hvariable\">deciderGates</span> <span class=\"token operator\">=</span> \n    <span class=\"token punctuation\">[</span>\n        <span class=\"token punctuation\">[</span><span class=\"token operator\">\\</span><span class=\"token hvariable\">x</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">75</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">\\</span><span class=\"token hvariable\">x</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">`within`</span> <span class=\"token punctuation\">(</span><span class=\"token number\">75</span><span class=\"token punctuation\">,</span><span class=\"token number\">80</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">\\</span><span class=\"token hvariable\">x</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">></span> <span class=\"token number\">80</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n        <span class=\"token punctuation\">[</span><span class=\"token operator\">\\</span><span class=\"token hvariable\">x</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">\\</span><span class=\"token hvariable\">x</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">]</span>\n\n<span class=\"token hvariable\">solutions</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">[</span><span class=\"token constant\">Solution</span><span class=\"token punctuation\">]</span>\n<span class=\"token hvariable\">solutions</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>\n        <span class=\"token constant\">Solution</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token constant\">True</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token constant\">True</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span> <span class=\"token number\">34</span><span class=\"token punctuation\">,</span>\n        <span class=\"token constant\">Solution</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token constant\">True</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token constant\">True</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span> <span class=\"token number\">30</span><span class=\"token punctuation\">,</span>\n        <span class=\"token constant\">Solution</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token constant\">True</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token constant\">True</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span> <span class=\"token number\">28</span><span class=\"token punctuation\">,</span>\n        <span class=\"token constant\">Solution</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token constant\">True</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token constant\">True</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span> <span class=\"token number\">25</span><span class=\"token punctuation\">,</span>\n        <span class=\"token constant\">Solution</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token constant\">True</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span>\n        <span class=\"token constant\">Solution</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token number\">0</span>\n    <span class=\"token punctuation\">]</span>\n\n<span class=\"token hvariable\">result</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Solution</span> <span class=\"token hvariable\">_</span> <span class=\"token hvariable\">r</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">r</span></code></pre></div>\n<p>This is the lengthiest part of the code which is just fine since it lays out what we want to do.</p>\n<p>The idea behind the whole thing is that we start off with an array of Inputs. We then have an array of <strong>Deciders</strong>. Such a decider is a collection of functions that take an input and produce a result. The <strong>deciderGates</strong> contain several such lines. Each line is meant to be applied to one of the inputs contained in the input array. Hence, the first input enters the first gate, the second the second, and so on.</p>\n<p>The atomic decisions contained in those gates may also be addressed in XY coordinates (we have an array of arrays of decisions). The remainder of the program will consider Y to be going down and X to the right.</p>\n<p>The <strong>solutions</strong> data encodes solutions in that way. <strong>DecisionTuples</strong> are used to constrain what the <strong>decidergates</strong> should output for a certain desired return value. The first solution says that the decision at position 0,0 should be true as well as the one at position 1,1. If you now check DecisionTuple's type\nyou should see how this is meant. The conditions <code class=\"language-text\">x &lt; 75</code> and <code class=\"language-text\">x == 0</code> have to be met in order to return the result 34. If you\nthink that this will never happen consider that the decision gates are applied to different inputs. Accordingly, the input [11,0] will satisfy the outlined conditions. The function that provides said answer looks like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">solve</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">[</span><span class=\"token constant\">Input</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Output</span>\n<span class=\"token hvariable\">solve</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">find</span> <span class=\"token number\">0</span><span class=\"token operator\"> . </span><span class=\"token hvariable\">solutionGateEvaluation</span><span class=\"token operator\"> . </span><span class=\"token hvariable\">decisionYX</span> <span class=\"token number\">0</span><span class=\"token operator\"> . </span><span class=\"token hvariable\">callDeciders</span></code></pre></div>\n<p>Looks simple, doesn't it? Let us look at the functions that compose it:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">callDeciders</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">[</span><span class=\"token constant\">Input</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token constant\">DecisionOutput</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span>\n<span class=\"token hvariable\">callDeciders</span> <span class=\"token hvariable\">input</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">zipWith</span> <span class=\"token hvariable\">call</span> <span class=\"token hvariable\">input</span> <span class=\"token hvariable\">deciderGates</span>\n    <span class=\"token keyword\">where</span> <span class=\"token hvariable\">call</span> <span class=\"token hvariable\">input</span> <span class=\"token hvariable\">checks</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">\\</span><span class=\"token hvariable\">check</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">check</span> <span class=\"token hvariable\">input</span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">checks</span></code></pre></div>\n<p><strong>zipWith</strong> is used here to zip together the input with said deciderGates. Just a reminder of zipWith's type:</p>\n<p><code class=\"language-text\">zipWith :: (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c]</code>.</p>\n<p>Each <strong>deciderGate</strong> is an array of decisions that all need to be called with the input that is relevant in the context of the zipWith. We do this calling with a <strong>map</strong>. Hence this function will end up with the same array structure as the deciderGates, only that those decisions are now evaluated with the provided input.</p>\n<p>Next stop is to convert the obtained solutions to a different representation, one that is compatible to the YX-coordinate decision tuples that are laid out in the solutions array.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">decisionYX</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Int</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token constant\">DecisionOutput</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token constant\">DecisionTuple</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span>\n<span class=\"token hvariable\">decisionYX</span> <span class=\"token hvariable\">_</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n<span class=\"token hvariable\">decisionYX</span> <span class=\"token hvariable\">l</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token operator\">:</span><span class=\"token hvariable\">xs</span><span class=\"token punctuation\">)</span><span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">zip3</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">repeat</span> <span class=\"token hvariable\">l</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token operator\">..</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">:</span> <span class=\"token hvariable\">decisionYX</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">l</span><span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">xs</span></code></pre></div>\n<p>Here some pattern matching is used to separate out the first element of the incoming array. In other words, in <strong>x</strong> we will find an array of decision outputs. This we can zip together with some numbers that represent our YX coordinates. Lazy evaluation is our friend here. While <strong>repeat 1</strong> gives us an infinite array of 1s, the list [0..] is basically the set of natural numbers. Of course, since <strong>x</strong> is finite,\nwe have no trouble with those. The remaining stuff is treated the same way as the first element, only that the Y counter goes up, which is just what I coded. What we will have now is an array of decision tuple arrays - that's already quite close to the things encoded in the solutions.</p>\n<p>Let us make the final evaluation and see which of the solutions manages to match to our decision outputs:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">solutionGateEvaluation</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token constant\">DecisionTuple</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token constant\">Bool</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span>\n<span class=\"token hvariable\">solutionGateEvaluation</span> <span class=\"token hvariable\">decTuplesFromCall</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span> <span class=\"token hvariable\">compareSolnWithCall</span> <span class=\"token hvariable\">solutions</span>\n    <span class=\"token keyword\">where</span> <span class=\"token hvariable\">compareSolnWithCall</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Solution</span> <span class=\"token hvariable\">decTuplesFromSoln</span> <span class=\"token hvariable\">_</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> \n        <span class=\"token builtin\">zipWith</span> <span class=\"token builtin\">elem</span> <span class=\"token hvariable\">decTuplesFromSoln</span> <span class=\"token hvariable\">decTuplesFromCall</span></code></pre></div>\n<p>Here we look at every single solution via map. We then zip together the array of tuples for a single solution with the array of arrays of decision tuples from having called the decider gates. We do this with the built-in <strong>elem</strong> function that returns true if the first argument is found in the array that the second argument must be (<code class=\"language-text\">elem :: (Eq a) =&gt; a -&gt; [a] -&gt; Bool</code>).</p>\n<p>As an example, if I pipe in the inputs [11,0], I first get this structure:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token operator\">></span> callDeciders <span class=\"token punctuation\">[</span>11,0<span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>True,False,False<span class=\"token punctuation\">]</span>,<span class=\"token punctuation\">[</span>False,True<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span></code></pre></div>\n<p>Which is transformed to <code class=\"language-text\">[[(0,0,True),(0,1,False),(0,2,False)],[(1,0,False),(1,1,True)]]</code></p>\n<p>This is what gets zipped together with the solutions. The first array only refers to stuff from the first gate, etc. For the solutions we have to <strong>assume</strong> that only <strong>one DecisionTuple</strong> is present for a Y coordinate and that they are specified in the same order as the gates. Consequently, the <strong>solutionGateEvaluation</strong> has this result:</p>\n<p><code class=\"language-text\">[[True,True],[False,True],[True,False],[False,True],[False],[]]</code></p>\n<p>For the first solution ([(0,0,True),(1,1,True)]) the code asks:</p>\n<blockquote>\n<p>Is (0,0,True) element of [(0,0,True),(0,1,False),(0,2,False)] ? Yes!\nIs (1,1,True) element of [(1,0,False),(1,1,True)] ? Yes!</p>\n</blockquote>\n<p>Hence <code class=\"language-text\">[True,True]</code>.</p>\n<p>There are as many arrays as there are solutions (of course, that's how often we called <strong>zipWith</strong>). Guess where we find our solution..? It's the first one that returns true from all of its elements.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">find l solnEvals\n    | l &gt; (length solnEvals) - 1 = error &quot;No available solution&quot;\n    | and (solnEvals!!l) = result (solutions!!l)\n    | otherwise = find (l+1) solnEvals  </code></pre></div>\n<p>Here the in-built <strong>and</strong> is applied to an array while the <strong>l</strong> counts for us at which index we are looking. With the <strong>l</strong>-index we can simply pick out the solution with the <strong>result</strong> function that is already defined.</p>\n<p>This solution isn't too bad. The single problem that may be perceived is that all inputs must be of the same type for now. The nice thing is that you have the decisions clearly separated from the solutions clearly separated from the implementation of the evaluation. Also, at a first glance the implementation relies on the fact that we can compare things to each other. A future version may show how the implementation can be made so generic that exactly this statement and not more is encapsulated. For now you could just change the type definitions on top of the program.</p>\n<p>Clearly, other languages allow you to do similar degrees of separating concerns, but here you can do it in a few lines of code, providing a great blueprint for other languages.</p>","fields":{"slug":"/2007/05/30/haskell-decision-making"},"frontmatter":{"date":"May 30, 2007","path":null,"title":"Haskell decision making","tags":["software-development","haskell"]}}},"pageContext":{"title":"Haskell decision making","previous":{"fields":{"slug":"/2007/05/24/functional-programming-and-quantum-computing","published":true},"frontmatter":{"title":"Functional Programming and Quantum Computing","tags":["physics","haskell"],"date":"2007/05/24"}},"next":{"fields":{"slug":"/2007/06/01/some-testing-is-always-going-on","published":true},"frontmatter":{"title":"Some testing is always going on","tags":["site","tools","web"],"date":"2007/06/01"}}}}