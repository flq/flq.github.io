{"data":{"markdownRemark":{"html":"<p>When you do the MS exams to become a certified developer you may come across the 486 course. The <a href=\"https://channel9.msdn.com/Series/Dev-ASP-MVC4-WebApps\">supporting video</a> for that is 4 years old and is based on MVC 4. This post keep the notes I made while working through the video's content based on ASP.NET Core's capabilities, to see whether the info in there still holds up. The code is <a href=\"https://github.com/flq/MS486Core\">checked in</a>, the commits more or less follow the progress made in the videos on channel 9.</p>\n<!-- START doctoc generated TOC please keep comment here to allow auto update -->\n<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->\n<ul>\n<li><a href=\"#video-1---introduction\">Video 1 - Introduction</a></li>\n<li><a href=\"#video-2---models\">Video 2 - Models</a></li>\n<li><a href=\"#video-3--controllers\">Video 3- Controllers</a></li>\n<li><a href=\"#video-4--views\">Video 4- Views</a></li>\n<li><a href=\"#video-5---javascript-page-updates-etc\">Video 5 - Javascript, Page updates etc.</a></li>\n<li><a href=\"#video-6---web-apis\">Video 6 - Web APIs.</a></li>\n<li>\n<p><a href=\"#deploying-to-azure\">Deploying to Azure</a></p>\n<ul>\n<li><a href=\"#missing-microsoftentityframeworkcoredesign\">Missing <code>Microsoft.EntityFrameworkCore.Design</code></a></li>\n<li><a href=\"#connection-string-from-_appsettingsjson_-not-found\">Connection string from <em>appsettings.json</em> not found:</a></li>\n<li><a href=\"#config-object-null\">Config object null</a></li>\n</ul>\n</li>\n</ul>\n<!-- END doctoc generated TOC please keep comment here to allow auto update -->\n<h3>Video 1 - Introduction</h3>\n<p>To get ourselves an mvc app we can do</p>\n<pre><code class=\"language-bash\">dotnet new web\ndotnet add package Microsoft.AspnetCore.Mvc\ndotnet add package Microsoft.AspnetCore.StaticFiles\n</code></pre>\n<p>I deliberately started fom an <em>empty</em> web project, because I am a purist like that. You could also do <code>dotnet new mvc</code> and have a ton of stuff and an application that can run. To be honest, what put me off where the bower references. I am not going to start getting aquainted with bower at this point int time.</p>\n<p>Anyhow, you can hook up the MVC functionality yourself into the basic web application startup:</p>\n<pre><code class=\"language-csharp\">//\"ConfigureServices\"\nservices.AddMvc(); \n...\n// \"Configure\"\napp.UseStaticFiles();\napp.UseMvc(routes =>\n{\n    routes.MapRoute(\n        name: \"default\",\n        template: \"{controller=Home}/{action=Index}/{id?}\");\n}); \n</code></pre>\n<p>Then we need</p>\n<ul>\n<li><strong>Controllers</strong> and <strong>Views</strong> folders</li>\n<li>A <strong>HomeController</strong>, an <strong>Index</strong> view, maybe a <strong>Layout</strong></li>\n</ul>\n<p>and off you go. So far, pretty much the same stuff.</p>\n<h3>Video 2 - Models</h3>\n<p>Entity Framework, really now?\nOh well, I said I would follow along, so here we go:</p>\n<pre><code class=\"language-bash\">dotnet add package Microsoft.EntityFrameworkCore.SqlServer\n</code></pre>\n<p>Now we wire up tha database stuff on Startup...</p>\n<pre><code class=\"language-csharp\">// In \"ConfigureServices\"\nservices.AddDbContext&#x3C;ConferenceContext>(opt => opt.UseSqlServer(\n  \"Server=(localdb)\\\\mssqllocaldb;Database=Conferences;\" +\n  \"Trusted_Connection=True;MultipleActiveResultSets=true\"));\n</code></pre>\n<p>That local db file will btw end up in your user directory (i.e. ~), I was too lazy to parse through changing the default,\nso I stuck with it (With frameworks &#x26; dependencies like that, just go with the flow, you will thank me when you have time\nto go have drinks on the weekend)</p>\n<p>The ConferenceContext is <a href=\"https://github.com/flq/MS486Core/blob/master/Database/ConferenceContext.cs\">over here</a>, then there is some initialization code, <a href=\"https://github.com/flq/MS486Core/blob/master/Database/DbInitializer.cs\">hand-written</a>. I didn't find that\nfancy <strong>DropCreateAlwaysDatabaseInitializer</strong> thing mentioned in the video, but this is about MVC, not EF, so I didn't search very hard. The initializer will do fine, I'm sure. We call it in Startup's <code>Configure</code>:</p>\n<pre><code class=\"language-csharp\">public void Configure(..., ConferenceContext dbContext)\n{\n    if (env.IsDevelopment())\n    {\n        app.UseDeveloperExceptionPage();\n        DbInitializer.Initialize(dbContext);\n    }\n}\n</code></pre>\n<p>By configuring the EF stuff into the in-built DI Container, we could just let the framework provide us with a db Context.\nYou will often see in the videos that the context gets instantiated in the controllers. You won't need to do that anymore. If you want to know more about EF on .NET Core, <a href=\"https://docs.microsoft.com/en-us/aspnet/core/data/ef-mvc/intro\">this page</a> is a good starting point.</p>\n<p>The <code>ComponentModel</code> namespace is around, so you can attribute your models like crazy, just like in the video.</p>\n<h3>Video 3- Controllers</h3>\n<p>All still basically the same stuff. There is now also an <code>IActionResult</code> interface if you want to implemen the Action Result yourself completely. Also the action / controller filters have more options to choose from...</p>\n<ul>\n<li>Auth filters - user authorisation</li>\n<li>Resource filters - Caching etc.</li>\n<li>Action filters - run code before / after</li>\n<li>Exception filters - as the name implies</li>\n<li>Result filters - only when the wrapped action runs successfully</li>\n</ul>\n<p>There are also async variants, it is all nicely explained <a href=\"https://docs.microsoft.com/en-us/aspnet/core/mvc/controllers/filters\">over here</a>.</p>\n<p>Global filters are added in the <strong>Startup</strong> through the options object that you get when calling the corresponding overload of <code>services.AddMvc();</code> inside <code>ConfigureServices</code>. </p>\n<h3>Video 4- Views</h3>\n<p>Html Helpers are still around, but what you may probably do these days is using the new <a href=\"https://docs.microsoft.com/en-us/aspnet/core/mvc/views/tag-helpers/intro\">Tag Helpers</a> to write out such a form. This is looking somewhat like that:</p>\n<pre><code class=\"language-html\">&#x3C;form asp-action=\"Create\">\n    &#x3C;div asp-validation-summary=\"All\">&#x3C;/div>\n    &#x3C;div class=\"row\">\n        &#x3C;div class=\"one column\">\n          &#x3C;label asp-for=\"Name\">&#x3C;/label>\n          &#x3C;span asp-validation-for=\"Name\">&#x3C;/span>\n        &#x3C;/div>\n        &#x3C;div class=\"eight columns\">\n          &#x3C;input asp-for=\"Name\" />\n        &#x3C;/div>\n    &#x3C;/div>\n    ...\n</code></pre>\n<p>One of the <a href=\"https://github.com/flq/MS486Core/commit/7591aa5cdf08e2339a508240acc1d0ac8d23b5c2\">last commits</a> introduces some custom layout tag helpers to test out the feature.</p>\n<p><strong>Partial Views</strong> seem more or less unchanged.</p>\n<h3>Video 5 - Javascript, Page updates etc.</h3>\n<p>There has been so much change with regard to how to do &#x26; use javascript for UIs in general and ASP.NET MVC in particular lately that I am not going into much detail here. You can still return partial views, but e.g. the Ajax helper you see in the video does not seem to be around.</p>\n<p>Bundling and minification also seems <a href=\"https://docs.microsoft.com/en-us/aspnet/core/client-side/bundling-and-minification\">to be supported</a> as a build step rather than a runtime step. These days you may do this with a tool like <a href=\"https://webpack.github.io/\">webpack</a> anyway, so there isn't much need to do this via Visual Studio. Also, all that nice javascript out there isn't made available via Nuget anymore but you'll rather have to go to npm. Additionally, jQuery just isn't as important anymore.</p>\n<h3>Video 6 - Web APIs.</h3>\n<p>Quite a few changes over here as well. Web API got folded into the ASP.NET Core effort. Apparently there is a <a href=\"https://stackify.com/asp-net-core-web-api-guide/\">compatibility shim</a> to smooth migration of an existing application. But, if you start from scratch, my repo contains a minimal example of getting all Sessions or Speakers, together with content negotation.</p>\n<p>Out of the box you only get support for json. For xml e.g. you need to </p>\n<pre><code class=\"language-bash\">dotnet add package Microsoft.AspNetCore.Mvc.Formatters.Xml\n</code></pre>\n<p>And then in <code>Startup.ConfigureServices</code></p>\n<pre><code class=\"language-csharp\">services.AddMvc(opts =>\n{\n  opts.OutputFormatters.Add(new XmlSerializerOutputFormatter());\n});\n</code></pre>\n<p>Then, a simple controller which inherits from Controller, just like the MVC ones:</p>\n<pre><code class=\"language-csharp\">[Route(\"api/[controller]/[action]\")]\npublic class DataController : Controller\n{\n    private readonly ConferenceContext _ctx;\n    public DataController(ConferenceContext ctx) => _ctx = ctx;\n\n    [HttpGet]\n    public IEnumerable&#x3C;Session> Sessions() => _ctx.Sessions.ToList();\n\n    [HttpGet]\n    public IEnumerable&#x3C;Speaker> Speakers() => _ctx.Speakers.ToList();\n}\n</code></pre>\n<p>Now, e.g. with curl you can make calls with the proper accept header:</p>\n<pre><code class=\"language-bash\">curl localhost:5000/api/data/speakers -v -H \"Accept: application/xml\"\n</code></pre>\n<p>And, presto, api with content negotiation.</p>\n<h3>Deploying to Azure</h3>\n<p>I won't go into the actual azure deploying, as there are so many ways to do it (e.g. deploying a container these days, etc.), but in the\nlight of doing standard MVC apps, one can have a look on how to do Entity Framewrk migrations these days. We will do this in the command line,\nand for this we extend the <code>dotnet</code>-CLI by adding a \"plugin\" in the csproj file (don't forget to <code>dotnet restore</code> afterwards):</p>\n<pre><code class=\"language-xml\">&#x3C;ItemGroup>\n  &#x3C;!-- stuff -->\n  &#x3C;DotNetCliToolReference Include=\"Microsoft.EntityFrameworkCore.Tools.DotNet\" Version=\"1.0.1\" />\n&#x3C;/ItemGroup>\n</code></pre>\n<p>When all works you should be able to run migration commands via <code>dotnet ef ...</code></p>\n<p>And then, when you are working without Visual Studio you may be subject to a number of issues:</p>\n<h4>Missing <code>Microsoft.EntityFrameworkCore.Design</code></h4>\n<p>add it e.g. via <code>dotnet add package</code> and restore.</p>\n<h4>Connection string from <em>appsettings.json</em> not found:</h4>\n<p>The migrations thing actually runs from <code>bin/...</code>, so you need to make sure that your settings file ends up there as well.</p>\n<p>Doing this manually, you need to add the following to the csproj file:</p>\n<pre><code class=\"language-xml\">&#x3C;ItemGroup>\n  &#x3C;Content Update=\"appsettings.json\">\n    &#x3C;CopyToOutputDirectory>Always&#x3C;/CopyToOutputDirectory>\n  &#x3C;/Content>\n&#x3C;/ItemGroup>\n</code></pre>\n<h4>Config object null</h4>\n<p>the migrations tool will actually run your <code>ConfigureServices</code> code from your startup, but <strong>NOT</strong> your Program's Main.\nIt is there where I had the code to instantiate a config. To resolve, I check in <code>ConfigureServices</code> that the Config object exists:</p>\n<pre><code class=\"language-csharp\">//Startup.cs\npublic void ConfigureServices(IServiceCollection services)\n{\n    Program.EnsureConfig();\n    // ...\n    services.AddDbContext&#x3C;ConferenceContext>(opt => \n        opt.UseSqlServer(\n            Program.Configuration.GetConnectionString(\"DefaultConnection\")));\n}\n\n// Program.cs\npublic static void EnsureConfig()\n{\n    if (Configuration != null)\n        return;\n\n    var builder = new ConfigurationBuilder()\n        .SetBasePath(Directory.GetCurrentDirectory())\n        .AddJsonFile(\"appsettings.json\");\n\n    Configuration = builder.Build();\n}\n</code></pre>\n<p>From there on I was able to use the tool. Then we can create the initial setup:</p>\n<pre><code class=\"language-bash\">dotnet ef migrations add InitialCreate\ndotnet ef database update\n</code></pre>\n<p>which sets up a migration file (as well as a .designer.cs file? No idea...). Btw, for a documentation of the tool's capabilities go to\nthe <a href=\"https://docs.microsoft.com/en-us/aspnet/core/data/ef-mvc/migrations\">Migrations docs</a></p>","frontmatter":{"date":"July 29, 2017","path":null,"title":"MS ASP.NET MVC Certification course vs ASP.NET core","tags":["web","programming","dotnet"]}}},"pageContext":{"title":"MS ASP.NET MVC Certification course vs ASP.NET core"}}