{"data":{"markdownRemark":{"html":"<h2>Functional space-invaders series</h2>\n<ol>\n<li><a href=\"%7B%25%20post_url%202013-9-17-FunSpIns-a-recap-of-Rob-Ashtons-lessons-Das-Intro%20%25%7D\">A recap of Rob Ashton's lessons - Das Intro</a></li>\n<li><a href=\"%7B%25%20post_url%202013-9-18-FunSpIns-Drawing-a-Rectangle%20%25%7D\">Drawing a Rectangle</a></li>\n<li><a href=\"%7B%25%20post_url%202013-9-19-FunSpIns-Moving-a-Rectangle%20%25%7D\">Moving a Rectangle</a></li>\n<li><a href=\"%7B%25%20post_url%202013-9-20-FunSpIns-No-attributes-No-vectors-A-tiny-Workflow-and-more-squares%20%25%7D\">No attributes, No vectors, A tiny Workflow and more squares</a></li>\n<li><a href=\"%7B%25%20post_url%202013-9-23-FunSpIns-State-the-World-the-Loop%20%25%7D\">State, the World, the Loop</a></li>\n<li>The hero must move, the enemies must move smarter</li>\n<li><a href=\"%7B%25%20post_url%202013-9-25-FunSpIns-The-hero-shoots%20%25%7D\">The hero shoots</a></li>\n<li><a href=\"%7B%25%20post_url%202013-9-26-FunSpIns-Collisions-the-dead-and-a-not-so-grateful-ending%20%25%7D\">Collisions, the dead, and a (not so) grateful ending</a></li>\n</ol>\n<blockquote>\n<p>Inspired by Rob Ashton's series \"<a href=\"http://codeofrob.com/entries/learn-functional-programming-with-me---keyboard-input-for-our-red-square.html\">Learn functional programming with me</a>\"\nIt is time to feed things back to the actors! The actor signature did change a teeny bit:</p>\n</blockquote>\n<pre><code>type Point = (Int,Int)\ndata ItemColor = White | Red | Black\ndata WorldItem = WorldItem Point ItemColor\nWorld -> (World,[WorldItem])\n</code></pre>\n<p>That way we will be able to tell the rendering what colour we want our rectangles to be.</p>\n<p>So, our enemies actor becomes:</p>\n<pre><code>enemiesActor :: World -> (World,[WorldItem])\nenemiesActor w = (newState, enemies)\n  where\n    newState = w { enemyPosition = changeX (+2) (enemyPosition w) }\n    enemies = enemyGrid (enemyPosition w) (3, 5)\n    enemyGrid (originX,originY) (rows, cols) = \n      map enemy [ (x,y) | x &#x3C;- take cols [originX,originX+60..], y &#x3C;- take rows [originY,originY+30..]]\n    enemy p = WorldItem p White\n</code></pre>\n<p>changeX is a new method with a pretty simple implementation:</p>\n<pre><code>changeX f (x,y) = (f x, y)\n</code></pre>\n<p>From which you can conclude that (+2) is actually a function, namely adding two to whatever supports adding twos to them.</p>\n<p>Some changes where done on the loop. Indeed, there was no bail-out condition, which is introduced by checking whether 'x' is pressed.\nAlso, I don't want to react to any mouse events, hence it is sufficient to just pass on any key that is pressed by the gamer. The main and loop functions got some refactoring:</p>\n<pre><code>main :: IO ()\nmain = do\n  canvas &#x3C;- init\n  loop $ initWorld canvas\n  where\n    init = FX.init [InitVideo] >> (FX.setVideoMode 640 480 32 []) >> FX.getVideoSurface\n</code></pre>\n<p>As you can see main is pretty much toned down to set up the SDL stuff and start looping with an initial version of our World. Loop became its own function:</p>\n<pre><code>loop :: World -> IO ()\nloop world = do\n  FX.pollEvent >>= handleEvent\n  where\n    handleEvent x = case x of\n        KeyDown (Keysym SDLK_x _ _) -> FX.quit\n        KeyDown (Keysym key _ _) -> render key >>= loop\n        KeyUp _ -> render SDLK_UNKNOWN >>= loop\n        x -> render (lastKey world) >>= loop\n    render e = do\n      let c = canvas world\n      FX.fillRect c Nothing black\n      let (newWorld,items) = foldl runActor (world { lastKey = e }, []) $ actors world\n      mapM (\\wi -> FX.fillRect c (getRect wi) (getPixel wi)) items\n      FX.flip c\n      FX.delay 40\n      return newWorld\n    runActor (wld, items) actor = (newWorld, items++moreItems)\n      where (newWorld,moreItems) = actor wld  \n</code></pre>\n<p>the value of <strong>pollEvent</strong> is bound to the <strong>handleEvent</strong> function. That one is responsible for our bailout (matching on a keydown event where <strong>x</strong> is pressed), as well as keeping the loop going in any other event. </p>\n<p>One speciality is that we extract the pressed key, and in case of any other event that may come through we do as if some unknown key would have been pressed. Hence, our World now does not keep the whole SDL event, but just the last key pressed. <strong>Also</strong>, while no KeyUp event is coming along, we moving the lastKey of the previous  world on to the next. This has the nice effect that our actors will react to the keydown event as long as the given key is pressed (<em>Your keyboard will thank me!</em>). <strong>getRect</strong> and <strong>getPixel</strong> functions are helpers to map from our <strong>WorldItem</strong> into the SDL data types.</p>\n<p>Now that we have a nice key event hanging around in the <em>World</em>, let's get our hero into the equation:</p>\n<pre><code>heroActor :: World -> (World,[WorldItem])\nheroActor w = (newState, (hero newState))\n  where\n    newState = case (lastKey w) of\n      SDLK_LEFT -> move (+(-10))\n      SDLK_RIGHT -> move (+10)\n      _ -> w\n    hero (World { heroPosition = p }) = [(WorldItem p Red)]\n    move f = w { heroPosition = changeX f (heroPosition w) }\n</code></pre>\n<p>Depending on whether the user pressed left or right cursor key, we define the position of our hero in the World and create the corresponding <em>WorldItem</em>. I also need to match any other key, otherwise a <em>non-exhaustive pattern match</em> error will occur at runtime -  in this case we leave the world unchanged.</p>\n<h3>Enemy movement</h3>\n<p>Rob got somewhat ahead of me in that he has already sorted out the enemies moving from left to right and back, etc. - My enemies are currently edlessly wandering towards the left, leaving the screen and escaping the <em>righteous vengeance</em> of our world-defending hero.</p>\n<p>For this I introduce a new state into the world:</p>\n<pre><code>data World = World \n    {\n      ...\n      enemyMovement :: MovementPattern,\n      ...\n    }\n</code></pre>\n<p>where <strong>MovementPattern</strong> is defined as </p>\n<pre><code>type MovementPattern = [(Movement, [(Int, Int)] -> Bool)]\ndata Movement = Rght | Dwn | Lft deriving Show\n</code></pre>\n<p>A pattern is therefore a number of Tuples consisting of a movement definition and a function that evaluates to true/false based on an input of Points. The way to use the pattern is as follows:</p>\n<ul>\n<li>Extract the points from whatever <strong>WorldItem</strong>s you want to consider</li>\n<li>If the function of the first element evaluates to True, leave things as they are</li>\n<li>If the function of the first element evaluates to False, roll over the pattern - first becomes last, second becomes first.</li>\n</ul>\n<p>So I go ahead and express that code-wise:</p>\n<pre><code>evaluateMovePattern :: [(Int,Int)] -> MovementPattern -> (Movement,MovementPattern)\nevaluateMovePattern items pattern = \n  case (evaluate items) of\n    True -> next pattern\n    False -> next newPattern\n    where \n      evaluate = snd $ head pattern\n      next p = (nextMove p, p)\n      newPattern = roll pattern\n      nextMove (m:ms) = fst m\n</code></pre>\n<p>where <strong>fst</strong>, <strong>snd</strong> are <a href=\"http://www.haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html\">Prelude</a> functions to extract the first and second value of a tuple, respectively. roll is just <strong>roll (x:xs) = xs++[x]</strong>.\nArmed with the ability to evaluate a movement pattern, let's define one in the initialization of our World:</p>\n<pre><code>initWorld canvas = World \n  { \n    ... \n    enemyMovement = [(Rght,(&#x3C;=620) . maxX),(Dwn,alwaysFalse),(Lft,(>=0) . minX),(Dwn,alwaysFalse)],\n    ...\n  }\n-- with ..\ngetX :: Num a => (a,a) -> a\ngetX (x,_) = x\nboundX f = getX . (f (comparing getX))\nmaxX = boundX maximumBy\nminX = boundX minimumBy\n</code></pre>\n<p>Hence, the pattern is right, while the maximum X of our point cloud is smaller than 620, the one time down (alwaysFalse returns false for whatever input), then left while the smallest X of the point cloud is bigger than 0, the one time down.</p>\n<p>We can use this in our enemy actor to make sure that it moves properly throughout the screen:</p>\n<pre><code>enemiesActor :: World -> (World,[WorldItem])\nenemiesActor w = (newState, enemies)\n  where\n    enemies = enemyGrid (enemyPosition w) (4, 8)\n    newMovePattern = evaluateMovePattern (map getPoint enemies) (enemyMovement w)\n    requiredChange = case (fst newMovePattern) of\n      Rght -> changeX (+3)\n      Lft -> changeX (+(-3))\n      Dwn -> changeY (+10)\n    newState = w { enemyPosition = requiredChange (enemyPosition w), enemyMovement = snd newMovePattern }\n    ...\n</code></pre>\n<p>Based on the current Movement, the enemy position is changed for the next iteration through our world.</p>\n<p>At this point in the series we have...</p>\n<ul>\n<li>A bunch of enemies that move left to right, slowly coming down</li>\n<li>A red hero that can be moved to the left and the right</li>\n</ul>\n<p>Doesn't sound terribly impressive, but the total LoC is about 117, and that from a FP noob, but we have still some way to go.</p>","frontmatter":{"date":"September 24, 2013","path":null,"title":"FunSpIns - The hero must move, the enemies must move smarter.","tags":["software-development","haskell","fun-spin"]}}},"pageContext":{"title":"FunSpIns - The hero must move, the enemies must move smarter."}}