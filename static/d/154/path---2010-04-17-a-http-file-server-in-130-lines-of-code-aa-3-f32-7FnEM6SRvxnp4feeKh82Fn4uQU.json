{"data":{"markdownRemark":{"html":"<p>...of which 20 deal with mapping file extensions to MIME types. </p>\n<p>For an integration test I want to be able to set up an HTTP server that serves files from a directory. While I was at it I ensured that a proper directory listing and links are provided by the web server so I can browse the contents of a directory from my browser. With the aid of the <a href=\"http://msdn.microsoft.com/en-us/library/system.net.httplistener.aspx\">HttpListener</a> this is quite easy to do.</p>\n<p>The whole thing is wrapped inside a class HttpFileServer, implementing disposable.</p>\n <div style=\"padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px\" id=\"scid:812469c5-0cb0-4c63-8c15-c81123a09de7:dc577a0e-949c-4180-8762-62094bf06400\" class=\"wlWriterEditableSmartContent\"><pre name=\"code\" class=\"c#\">public HttpFileServer(string rootPath)\n{\n  this.rootPath = rootPath;\n  http = new HttpListener();\n  http.Prefixes.Add(\"http://localhost:8889/\");\n  http.Start();\n  http.BeginGetContext(requestWait, null);\n}\n<p>public void Dispose()\n{\nhttp.Stop();\n}</pre></div></p>\n<p>Careful with the selection of your port. You’ll get an Exception if it is registered to another application, even if that application is not running. The <em>requestWait</em> method is a callback that allows you to react to incoming requests asynchronously. It should be implemented with the well known pattern introduced to .NEt almost a decade ago:</p>\n<div style=\"padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px\" id=\"scid:812469c5-0cb0-4c63-8c15-c81123a09de7:42f290aa-16a0-4453-a63a-bd105a4de8f8\" class=\"wlWriterEditableSmartContent\"><pre name=\"code\" class=\"c#\">if (!http.IsListening) return;\nvar c = http.EndGetContext(ar);\nhttp.BeginGetContext(requestWait, null);</pre></div>\n<p>c is of type <a href=\"http://msdn.microsoft.com/en-us/library/system.net.httplistenercontext.aspx\">HttpListenerContext</a>. The callback will also be called when the HttpListener is stopped, hence make sure that you only do stuff when you really seem to have a legitimate request.</p>\n<p>As long as you keep your method re-entrant (i.e. you do not try to keep any request-specific state in some instance variable) you should be fine with multiple requests leading to multiple threads handling those.</p>\n<p>As a file server, I only need to differ between a file being requested, a directory or something I don’t know:</p>\n<div style=\"padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px\" id=\"scid:812469c5-0cb0-4c63-8c15-c81123a09de7:e648ff6e-d1a1-4880-8be9-b9f46606717a\" class=\"wlWriterEditableSmartContent\"><pre name=\"code\" class=\"c#\">var url = tuneUrl(c.Request.RawUrl);\nvar fullPath = string.IsNullOrEmpty(url) ? rootPath : Path.Combine(rootPath, url);\n<p>if (Directory.Exists(fullPath))\nreturnDirContents(c, fullPath);\nelse if (File.Exists(fullPath))\nreturnFile(c, fullPath);\nelse\nreturn404(c);</pre></div></p>\n<p>The dir contents just serves some HTML. Here, especially on a computer where German umlauts are inside directory and file names, you should not forget to put the proper encoding into the HTML header:</p>\n<div style=\"padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px\" id=\"scid:812469c5-0cb0-4c63-8c15-c81123a09de7:a8078900-a5a0-4969-9133-e9b2a381f6e1\" class=\"wlWriterEditableSmartContent\"><pre name=\"code\" class=\"c#\">context.Response.ContentType = \"text/html\";\ncontext.Response.ContentEncoding = Encoding.UTF8;\nusing (var sw = new StreamWriter(context.Response.OutputStream))\n{\n  sw.WriteLine(\"&lt;html&gt;\");\n  sw.WriteLine(\"&lt;head&gt;&lt;meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=utf-8\\\"&gt;&lt;/head&gt;\");\n  sw.WriteLine(\"&lt;body&gt;&lt;ul&gt;\");</pre></div>\n<p>When links contain spaces, umlauts etc. modern browsers should take care about escaping them correctly into a URL request sent to the server (at least Chrome does). On the server side you need to ensure that this is converted back into things understood by the classes in System.IO, which happily deal with UTF-8 encoded strings. Thankfully there is a class in .NET, the <a href=\"http://msdn.microsoft.com/en-us/library/system.web.httputility.aspx\">HttpUtility</a> in System.Web that will be able to do that for you:</p>\n<div style=\"padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px\" id=\"scid:812469c5-0cb0-4c63-8c15-c81123a09de7:fc5c0022-cf2b-4409-9829-a1e6ad34012c\" class=\"wlWriterEditableSmartContent\"><pre name=\"code\" class=\"c#\">private static string tuneUrl(string url)\n{\n  url = url.Replace('/', '\\\\');\n  url = HttpUtility.UrlDecode(url, Encoding.UTF8);\n  url = url.Substring(1);\n  return url;\n}</pre></div>\n<p>When actually hitting a file, you need to read it and write it to the appropriate output stream. Just to be on the safe side regarding file size, I chose a chunked approach:</p>\n<div style=\"padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px\" id=\"scid:812469c5-0cb0-4c63-8c15-c81123a09de7:5e1d94f6-1388-4b3a-a44d-2ba626c8a7a5\" class=\"wlWriterEditableSmartContent\"><pre name=\"code\" class=\"c#\">context.Response.ContentType = \n  getcontentType(Path.GetExtension(filePath));\nusing ( var fs = File.OpenRead(filePath))\n{\n  context.Response.ContentLength64 = fs.Length;\n  int read;\n  while ((read = fs.Read(buffer, 0, buffer.Length)) &gt; 0)\n    context.Response.OutputStream.Write(buffer, 0, read); \n}</pre></div>\n<p>Don’t forget in all cases to <strong>close the Output Stream</strong>. In the case of using a StreamWriter, it’s disposal will close the underlying stream, in the case of serving the file directly, you’ll need to do it yourself.</p>\n<p>To make things a bit more comfortable for e.g. a browser, it is useful to provide an appropriate MIME type. This is pretty boring code and goes along the lines of this example. A fairly nice list <a href=\"http://www.feedforall.com/mime-types.htm\">can be found here</a>:</p>\n<div style=\"padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px\" id=\"scid:812469c5-0cb0-4c63-8c15-c81123a09de7:3e69c679-f01c-4aa4-9228-15380626d000\" class=\"wlWriterEditableSmartContent\"><pre name=\"code\" class=\"c#\">private static string getcontentType(string extension)\n{\n  switch (extension)\n  {\n    case \".avi\":  return \"video/x-msvideo\";\n    case \".css\":  return \"text/css\";\n    ...</pre></div>\n<p>And for those who want to play with this, here’s the full monty:</p>\n<script src=\"http://gist.github.com/369432.js?file=HttpFileServer.cs\"></script>[![Shout it](http://dotnetshoutout.com/image.axd?url=http%3A%2F%2Frealfiction.net%2Fgo%2F166)](http://dotnetshoutout.com/A-HTTP-file-server-in-130-lines-of-code)","frontmatter":{"date":"April 17, 2010","path":null,"title":"A HTTP file server in 130 lines of code","tags":["software-development","dotnet","web"]}}},"pageContext":{"title":"A HTTP file server in 130 lines of code"}}