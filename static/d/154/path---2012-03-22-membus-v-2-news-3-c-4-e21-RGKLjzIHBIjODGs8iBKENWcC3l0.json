{"data":{"markdownRemark":{"html":"<p>Membus 1.5.0 is a kind of V2 release in that it removed a number of things that had ben marked as obsolete and also provides users with a new feature.</p>\n<h3>IOC-Adapter</h3>\n<p>If you wanted to have MemBus call into your DI-Container of choice you pretty much followed the things outlined in this <a href=\"http://realfiction.net/go/183\">blog post here</a>. Things changed since then. The dependency to the <strong>CommonServiceLocator</strong> package has been removed, you rather implement the <strong>IocAdapter</strong>-interface whose contract is straightforward:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">public interface IocAdapter\n{\n    IEnumerable&lt;object&gt; GetAllInstances(Type desiredType);\n}</code></pre></div>\n<p>Implement this interface, bridging e.g. to your DI-Container and finally use it when setting up MemBus:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">_bus = BusSetup\n    .StartWith&lt;Conservative&gt;()\n    .Apply&lt;IoCSupport&gt;(s =&gt; s.SetAdapter(new MyAdapter()).SetHandlerInterface(typeof(GimmeMsg&lt;&gt;)))\n    .Construct();</code></pre></div>\n<p><strong>SetHandlerInterface</strong> is a new call that lets you provide an interface that your handler types implement. It expects an open generic type where the generic argument closes a <strong>single method</strong> defined on the interface that can accept one object and returns void (<em>void Foo(T msg)</em>).</p>\n<p>Previously the interface that had to be implemented was fixed and provided by MemBus. The change means that there is a whole new category of classes that can be called by MemBus but <strong>do not</strong> take a direct dependency on it, since they implement an interface that you provide.</p>\n<h3>Flexible subscribing</h3>\n<p>The flexible subscription adapter has received an extension that allows you to subscribe methods that return either an object or as a special case an <strong>IEnumerable</strong>.</p>\n<p>In both cases, MemBus will take the <strong>return value and either publish it back</strong> on the Bus again, or will enumerate the return value and <strong>publish every yielded object</strong> on the Bus.</p>\n<p>Taking an example from the tests:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var bus = BusSetup\n          .StartWith&lt;Conservative&gt;()\n          .Apply&lt;FlexibleSubscribeAdapter&gt;(\n            c =&gt; c.ByMethodName(&quot;Handle&quot;).PublishMethods(&quot;Route&quot;))\n          .Construct();</code></pre></div>\n<p>And a subscriber may look like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">public class Controller {\n  public View Route(Input msg) {\n    return new View();\n  }\n}\n...\nbus.Subscribe(new Controller());</code></pre></div>\n<p>Now, when publishing a new Input instance, the <strong>Route</strong>-method will be called and the return value will subsequently be delivered to any subscribers of the <strong>View</strong>-Type.</p>\n<p>This should open up a new set of scenarios where you have methods that publish a new message based on a different one. This scenario can now be implemented <strong>without</strong> taking a direct dependency to MemBus.</p>","frontmatter":{"date":"March 22, 2012","path":null,"title":"membus v2 news","tags":["software-development","dotnet","membus"]}}},"pageContext":{"title":"membus v2 news"}}