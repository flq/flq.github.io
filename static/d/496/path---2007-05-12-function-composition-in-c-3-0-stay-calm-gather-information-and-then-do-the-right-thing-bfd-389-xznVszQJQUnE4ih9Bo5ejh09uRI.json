{"data":{"markdownRemark":{"html":"<p>In the <a href=\"/go/117\">last post</a> I was talking about how we could create the natural Haskell function composition operator into C# and my first solution (also contained as the <em>Functional</em> assembly in the attached solution) was one based on the possibilities provided by the 2.0 Version of the .NET framework. It worked, but it was clumsy, with a lot infrastructure to support a single requirement.</p>\n<p>Luckily I am already delving a bit into LINQ and the technologies behind it and respective implementations in different domains, e.g. <a href=\"http://www.google.de/search?hl=en&#x26;q=DLINQ+overview&#x26;btnG=Search\">DLINQ</a> for doing strongly typed queries against DBs. If creating the query would already do anything against the DB, all hell would break loose considering that (D)LINQ allows for joins between objects. It would be bad news if you'd have to do the join in your application and not your DB.</p>\n<p>Therefore, what rather happens is that a so-called <a href=\"http://www.interact-sw.co.uk/iangblog/2005/09/30/expressiontrees\">expression tree</a> is generated. It conveys all the information that is expressed through writing down said query. Once the application really wants to perform a query, the frameworky bits of DLINQ can look at the created expression tree and create a decent SQL statement to get just that information without any excessive roundtripping.</p>\n<p>Alas, expression trees are much more powerful than just being LINQ's backbone. They allow you to create new expressions, compile and use them at runtime. This is what is meant by deferred execution. You don't execute e.g. the LINQ query but rather gather the execution into an abstraction in order to be executed later. Now, that almost sounds like Haskell's lazy evaluation, doesn't it? Well, not quite, but the greatness of expression trees is that you can create new expressions, compile and use them at runtime. There, I just repeated myself. Why do I think that this is important? Go back to the <a href=\"/go/117\">last post</a>. In imperative programming sometimes information is missing at a given point in time. A LINQ is finished and ready to be executed when the programmer says so. In my case the function composition is only finished when the programmer says so. Only then I have all necessary information to create the correct function composition.</p>\n<p><strong>&#x3C;Stop blurbing, how does it work then?></strong></p>\n<p>Let me just remind you the syntax of the function compositor. It stayed almost the same, as all the generics fun and method chaining makes for great type safety:</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre class=\"language-csharp\"><code class=\"language-csharp\">Func<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">decimal</span><span class=\"token operator\">></span> func <span class=\"token operator\">=</span>\n        <span class=\"token keyword\">new</span> <span class=\"token class-name\">FunctionalExpress</span><span class=\"token punctuation\">.</span><span class=\"token generic-method\"><span class=\"token function\">FuncCombination</span><span class=\"token punctuation\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">decimal</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token generic-method\"><span class=\"token function\">Add</span><span class=\"token punctuation\">&lt;</span><span class=\"token keyword\">string</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span>int2StringStatic<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">Add</span><span class=\"token punctuation\">(</span>s <span class=\"token operator\">=</span><span class=\"token operator\">></span> s<span class=\"token punctuation\">.</span><span class=\"token function\">ToArray</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">AddFinal</span><span class=\"token punctuation\">(</span>char2Decimal<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">decimal</span> d <span class=\"token operator\">=</span> <span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token number\">23</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Now, however, I don't really have to store a reference to the passed delegate. I extract the info contained in the delegate and store it in a list that will be passed along the instances on which Add are called:</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre class=\"language-csharp\"><code class=\"language-csharp\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">delegate</span> V <span class=\"token generic-method\"><span class=\"token function\">Digestif</span><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">V</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token class-name\">T</span> input<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token keyword\">private</span> List<span class=\"token operator\">&lt;</span>MethodInfo<span class=\"token operator\">></span> infos<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token keyword\">public</span> FuncAddendum<span class=\"token operator\">&lt;</span>START<span class=\"token punctuation\">,</span> FINAL<span class=\"token punctuation\">,</span> OUT<span class=\"token punctuation\">,</span> NEWOUT<span class=\"token operator\">></span> <span class=\"token generic-method\"><span class=\"token function\">Add</span><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">NEWOUT</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span>Digestif<span class=\"token operator\">&lt;</span>OUT<span class=\"token punctuation\">,</span> NEWOUT<span class=\"token operator\">></span> pluck<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n  infos<span class=\"token punctuation\">.</span><span class=\"token function\">Add</span><span class=\"token punctuation\">(</span>pluck<span class=\"token punctuation\">.</span>Method<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token generic-method\"><span class=\"token function\">FuncAddendum</span><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">START</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">FINAL</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">OUT</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">NEWOUT</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span>infos<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Once AddFinal is called, something else happens:</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre class=\"language-csharp\"><code class=\"language-csharp\"><span class=\"token keyword\">public</span> Func<span class=\"token operator\">&lt;</span>START<span class=\"token punctuation\">,</span>FINAL<span class=\"token operator\">></span> <span class=\"token function\">AddFinal</span><span class=\"token punctuation\">(</span>Digestif<span class=\"token operator\">&lt;</span>OUT<span class=\"token punctuation\">,</span> FINAL<span class=\"token operator\">></span> pluck<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n  infos<span class=\"token punctuation\">.</span><span class=\"token function\">Add</span><span class=\"token punctuation\">(</span>pluck<span class=\"token punctuation\">.</span>Method<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">GetFunction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>At this point in time all information is available to combine the functions in an optimal fashion.\nWhat we would do when chaining the functions in a normal fashion (i.e. when writing our source code) is essentially this:</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre class=\"language-csharp\"><code class=\"language-csharp\">type <span class=\"token function\">myFuncComposition</span><span class=\"token punctuation\">(</span>type <span class=\"token keyword\">value</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">last_method</span><span class=\"token punctuation\">(</span><span class=\"token function\">before_last_method</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">(</span>first <span class=\"token function\">method</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">value</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Only, we are already at runtime! Let's create the expression that looks like above instead. At the current state of the .NET framework 3.5 we use static methods of the Expression class to create different expressions (method calls, parameters, comparisons, additions, multiplications, etc., etc....).</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre class=\"language-csharp\"><code class=\"language-csharp\"><span class=\"token keyword\">private</span> Func<span class=\"token operator\">&lt;</span>START<span class=\"token punctuation\">,</span> FINAL<span class=\"token operator\">></span> <span class=\"token function\">GetFunction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n  <span class=\"token class-name\">ParameterExpression</span> pe <span class=\"token operator\">=</span>\n    Expression<span class=\"token punctuation\">.</span><span class=\"token function\">Parameter</span><span class=\"token punctuation\">(</span>infos<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">GetParameters</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>ParameterType<span class=\"token punctuation\">,</span> infos<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">GetParameters</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>Name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token class-name\">MethodCallExpression</span> mce <span class=\"token operator\">=</span> <span class=\"token function\">BuildExpression</span><span class=\"token punctuation\">(</span>infos<span class=\"token punctuation\">.</span><span class=\"token function\">GetEnumerator</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> pe<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  Expression<span class=\"token operator\">&lt;</span>Func<span class=\"token operator\">&lt;</span>START<span class=\"token punctuation\">,</span> FINAL<span class=\"token operator\">></span><span class=\"token operator\">></span> myFunc <span class=\"token operator\">=</span>\n    Expression<span class=\"token punctuation\">.</span>Lambda<span class=\"token operator\">&lt;</span>Func<span class=\"token operator\">&lt;</span>START<span class=\"token punctuation\">,</span> FINAL<span class=\"token operator\">></span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>mce<span class=\"token punctuation\">,</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ParameterExpression</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">{</span> pe <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> myFunc<span class=\"token punctuation\">.</span><span class=\"token function\">Compile</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>For once we can make good use of the Enumerator as an object to pass along a recursive chain (Which is what I do, since the expression created from the first method is the input to the second method which is the input to the third...you get it).\nThe difference between the first and all other methods is that its input is the very same parameter that is the input to the function that will be generated once we compile the whole caboodle - which is why <strong>pe</strong> appears twice here. The last piece in the puzzle is the <strong>BuildExpression</strong> method:</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre class=\"language-csharp\"><code class=\"language-csharp\"><span class=\"token keyword\">private</span> <span class=\"token class-name\">MethodCallExpression</span> <span class=\"token function\">BuildExpression</span><span class=\"token punctuation\">(</span>IEnumerator<span class=\"token operator\">&lt;</span>MethodInfo<span class=\"token operator\">></span> mis<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Expression</span> ex<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>mis<span class=\"token punctuation\">.</span><span class=\"token function\">MoveNext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">MethodCallExpression</span> intermediate <span class=\"token operator\">=</span>\n      Expression<span class=\"token punctuation\">.</span><span class=\"token function\">Call</span><span class=\"token punctuation\">(</span>mis<span class=\"token punctuation\">.</span>Current<span class=\"token punctuation\">.</span>DeclaringType<span class=\"token punctuation\">,</span> mis<span class=\"token punctuation\">.</span>Current<span class=\"token punctuation\">.</span>Name<span class=\"token punctuation\">,</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Expression</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">{</span> ex <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">BuildExpression</span><span class=\"token punctuation\">(</span>mis<span class=\"token punctuation\">,</span> intermediate<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>MethodCallExpression<span class=\"token punctuation\">)</span>ex<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>And that's this. Once the recursion is finished, the Visual Studio shows us the ToString(), which gives a nice confirmation of what I was trying to achieve:</p>\n<p><img src=\"/assets/func_expression.gif\"></p>\n<p>You can see, soon there are even more tools in the ever growing .NET toolbox. In some situations you may want to resort to create and compile some small-scale code at runtime - namely when you have all necessary information available to create just the right code to answer your requirement.</p>\n<p>A final word to the function compositor provided in the attachment: It is currently able to call lambdas as well as static methods but no instance methods.</p>","fields":{"slug":"/2007/05/12/function-composition-in-c-3-0-stay-calm-gather-information-and-then-do-the-right-thing"},"frontmatter":{"date":"May 12, 2007","path":null,"title":"Function composition in C#3.0 (Stay calm, gather information and then do the right thing)","tags":["software-development","download","dotnet"]}}},"pageContext":{"title":"Function composition in C#3.0 (Stay calm, gather information and then do the right thing)","previous":{"fields":{"slug":"/2007/05/10/how-much-haskell-can-i-squeeze-out-of-c","published":true},"frontmatter":{"title":"How much Haskell can I squeeze out of C#?","tags":["software-development","dotnet","haskell"],"date":"2007/05/10"}},"next":{"fields":{"slug":"/2007/05/15/haunted-by-pi-changing-a-numbers-base-in-haskell","published":true},"frontmatter":{"title":"Haunted by PI - changing a number's base in Haskell","tags":["software-development","geekdom","mathematics","haskell"],"date":"2007/05/15"}}}}