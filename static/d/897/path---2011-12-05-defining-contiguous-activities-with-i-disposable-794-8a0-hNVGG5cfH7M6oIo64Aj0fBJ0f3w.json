{"data":{"markdownRemark":{"html":"<blockquote>\n<p>\"Atomic activities may not be confused with consecutive code\" - <em>Arthur X. Brannigan</em><br>\n\"Ideally, atomic activities can be read as consecutive code\" - <em>Arthur X. Brannigan</em></p>\n</blockquote>\n<p>What Arthur is trying to say is that sometimes you have an atomic activity (something that should happen completely or not at all) whose parts are separated by arbitrary amounts of code. What would be desirable is that such an activity can also be read as such. That is, as a consecutive block of code, even though its parts may run at different points of the program execution. This will also encourage reusability, since a consecutive code block can easily be refactored via <em>\"extract method\"</em></p>\n<p>The using pattern with <em>IDisposable</em> can help us creating such activities. We introduce a class that can run arbitrary code and implements <em>IDisposable</em>:</p>\n<pre><code>public class AdHocDisposable : IDisposable\n{\n    private readonly Action _end;\n    public static IDisposable Create(Action start, Action end)\n    {\n        return new AdHocDisposable(start, end);\n    }\n    public AdHocDisposable(Action start, Action end)\n    {\n        _end = end;\n        start();\n    }\n    public void Dispose()\n    {\n        _end();\n    }\n}\n</code></pre>\n<p>Usage may be encapsulated in a single private method of the class in need of the switching:</p>\n<pre><code>private IDisposable FooEnabled()\n{\n    return AdHocDisposable.Create(() => _foo = true, () => _foo = false);\n}\n</code></pre>\n<p>After which we can use it in the following way:</p>\n<pre><code>using (FooEnabled())\n{\n  // Doing funny stuff\n}\n</code></pre>\n<p>The repetitiveness has been dragged into its own method. The before/after\nparts are written in close vicinity to each other, making it clear to a future reader what must be understood to be an <em>atomic activity</em>.</p>\n<p>In a functional language like F#, such patterns would probably be evolved with functional features.\nThe following is a quick example based on function definitions, written as a test.</p>\n<pre>\n[&lt;TestFixture&gt;] \ntype ``Atomic Tests`` ()=\n\n  let mutable i = 0\n  let enclose (A,O) x = A(); x(); O();\n  let encloseWithI = ((fun() -&gt; i &lt;- 1), (fun() -&gt; i &lt;- 0)) |> enclose\n  let dispose = DisposableBuilder()\n\n  [&lt;Test&gt;] member test.``test with the lambda`` ()=\n    encloseWithI (fun() -&gt; i |&gt; should equal 1)\n    i |&gt; should equal 0\n</pre>\n<p>It makes use of currying (<em>encloseWithI</em>) to specialize the <em>enclose</em> function with the desired effect of changing the value of <strong><em>i</em></strong> before and after some other\nactivity. <em>A(lpha)</em> and <em>O(mega)</em> are expected to be functions that are run before and after the third function <em>x()</em></p>","frontmatter":{"date":"December 05, 2011","path":null,"title":"defining contiguous activities with IDisposable","tags":["software-development","dotnet","patterns","fsharp"]}}},"pageContext":{"title":"defining contiguous activities with IDisposable"}}