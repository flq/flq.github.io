{"data":{"markdownRemark":{"html":"<h2>TL;DR</h2>\n<p>Don't dismiss controllers in a MVVM scenario - they remain useful and are an easy target for certain responsibilities that would burden VMs. With some infrastructure they can look much like Web-style controllers.</p>\n<h2>MVVM</h2>\n<p>I hear you groan - there is not much that can beat those 4 letters on the boredom scale. Model-View-ViewModel.\nThis pattern is meant to play well in WPF - You know, </p>\n<blockquote>\n<p>Data binding, the promise of a reactive UI,\na puppet that dances according to your data-powered, notify property-infused <em>will</em>,\nattached to thin (Dispatcher) threads.</p>\n</blockquote>\n<p>Unfortunately some concerns are not addressed very well.</p>\n<ul>\n<li>Where does the model come from?</li>\n<li>Where does data you are showing come from?</li>\n<li>What with all the things the user wants to do?</li>\n<li>Questions / Validation / Navigation?</li>\n<li>What if you actually <em>don't have</em> a Model to begin with?</li>\n</ul>\n<p>All this can lead to fatty View Models - unwieldy behemoths, with fat constructors, a concoction of methods, properties with the cohesion that compares favourably only to a young star nebula.</p>\n<h2>C</h2>\n<p><em>Dude</em>, I hear MVC devs say, you want to sell us Controllers as something new? Why, of course not - they are an old concept, but nonetheless can be very useful. Controllers lend themselves nicely to <strong>responding to user or programmatic events that request the activation of a new screen</strong>, and to take <strong>some of the burden of setting VMs up for display</strong>.</p>\n<p>In a web app the frameworks you use usually let you map Actions/Controllers easily to <strong>urn</strong>s. We don't have that nice simplicity in a WPF app - Here, <strong>messages</strong> can take the role of uniquely identifying a Route to which the Controller must respond.</p>\n<p>This begins to look rather similar to Web-MVC-Style controllers if you consider that the input parameters of a Web request are often mapped to some object through the <em>might</em> of <strong>Model Binding</strong>.</p>\n<p>In our current infrastructure we achieve this structural equivalence through the use of Membus. Instantiating some class that you designate as a controller and subscribing it to Membus allows you to write methods like these:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">public Activate&lt;SomeNiceViewModel&gt; Activate(ActivateSomething request)\n{\n    VMArguments args;\n    using (var session = _session())\n    {\n\t\tvar tmp = session.Query&lt;SomeModel&gt;().FirstOrDefault()\n        var model = tmp ?? new SomeModel();\n        args = new VMArguments(model)\n        {\n            StartInEditMode = tmp == null\n        };\n    }\n    \n    var viewModel = _vmFactory.With(args).Instantiate&lt;SomeNiceViewModel&gt;();\n\n    return ActivationMessage.For(viewModel);\n}</code></pre></div>\n<p><em>ActivateSomething</em> is something that is published from some other area of the application. What you see as a reaction to the message is some light example on preparing the <em>model</em> and providing it to the view model through a set of arguments which may contain additional parameters. The return value of the method is treated as a message by Membus. Provided that you have a listener to that message (in our case a <strong>Conductor with a single active item</strong>, with only some modifications to what you get OOTB from Caliburn.Micro)</p>\n<p>This example e.g. shows that for obtaining the underlying model, the VM does not require a dependency on some session provider or anything like that - this pattern allows you to make the basic <strong>routing</strong> in your application explicit - Just inspect your controllers and the messages they consume as well as the return values they provide. </p>\n<p>It does not have to stop there. Other things you could pass into it:</p>\n<ul>\n<li>Tasks that return some value based on a query or whatever else</li>\n<li>ViewModels meant for composition, e.g. a backend for a searchable, paginated Grid and the like</li>\n<li>The actual models, of course ;)</li>\n</ul>","frontmatter":{"date":"August 05, 2013","path":null,"title":"Combat fatty WPF VMs - Controller","tags":["dotnet","libs-and-frameworks"]}}},"pageContext":{"title":"Combat fatty WPF VMs - Controller","previous":{"fields":{"slug":"/2013/07/31/atrocious-learnings-of-haskell-for-make-benefit-of-solving-math-problem"},"frontmatter":{"title":"Atrocious Learnings of Haskell for Make Benefit of solving Math Problem","tags":["software-development","haskell"],"date":"2013/07/30"}},"next":{"fields":{"slug":"/2013/08/13/what-id-have-wished-windows-8-to-be"},"frontmatter":{"title":"What I'd have wished Windows 8 to be","tags":["windows"],"date":"2013/08/13"}}}}