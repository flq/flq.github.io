{"data":{"markdownRemark":{"html":"<p>I was looking back at <a href=\"/go/113\">Christoph's ruby code</a> and was thinking that by now I should be able to implement that algorithm in Haskell. Indeed, one of my solutions looks like that:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">out</span> <span class=\"token hvariable\">x</span>\n    <span class=\"token operator\">|</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">>=</span> <span class=\"token hvariable\">base</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">foldl</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">$</span> <span class=\"token builtin\">map</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">\\</span><span class=\"token hvariable\">f</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">out</span> <span class=\"token operator\">$</span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">x</span> <span class=\"token hvariable\">base</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">[</span><span class=\"token builtin\">mod</span><span class=\"token punctuation\">,</span><span class=\"token builtin\">div</span><span class=\"token punctuation\">]</span>\n    <span class=\"token operator\">|</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">&lt;</span> <span class=\"token hvariable\">base</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">digit</span>\n    <span class=\"token keyword\">where</span>\n        <span class=\"token builtin\">range</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token char\">'a'</span><span class=\"token operator\">..</span><span class=\"token char\">'z'</span><span class=\"token punctuation\">]</span>\n        <span class=\"token hvariable\">digit</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token builtin\">range</span><span class=\"token operator\">!!</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">fromIntegral</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n        <span class=\"token hvariable\">base</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">fromIntegral</span> <span class=\"token operator\">$</span> <span class=\"token builtin\">length</span> <span class=\"token builtin\">range</span></code></pre></div>\n<p>The digit to be output is a letter of the alphabet, so we are changing PI to a base 26 number system. Let's check it briefly: The <strong>map</strong> function maps one array to another. In this case the array consists of two functions, <strong>mod</strong> and <strong>div</strong>. mod returns the remainder of a division while div returns how often the divisor fits in the dividend.</p>\n<p>In other words, the right-hand side of the dollar-sign (which is a symbol in Haskell to influence the binding power of functions and often simply aids in removing the need to put an expression in brackets) returns an array like <code class=\"language-text\">[out(mod x base),out(div x base)]</code>. <strong>foldl</strong> then gobbles it all up coming from the left. It kicks off with an empty array ([]), takes the first element and concatenates it (++) to said array, then takes the second element in the array and (++) it to what it already has, and...you get it. Btw, !! is the indexer operation to an array [1,2]!!1 gives us 2.</p>\n<p>You may be wondering about two things:</p>\n<ol>\n<li>What is this <strong>fromIntegral</strong> stuff?</li>\n<li>Isn't the number that comes out backwards?</li>\n</ol>\n<p>To the first: fromIntegral's type is</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Main&gt; :t fromIntegral\nfromIntegral :: (Num b, Integral a) =&gt; a -&gt; b</code></pre></div>\n<p>It's input is therefore an Integral. An integral, on the other hand, is an integer with \"infinite\" length. Yeah! I finally stumbled across a language that can do looong integers out-of-the-box.</p>\n<p>Hence, using fromIntegral in that context gives the following signature for the function:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Main&gt; :t out\nout :: (Integral a) =&gt; a -&gt; [Char]</code></pre></div>\n<p>It will get an arbitrary length integral and returns a String. Nice!\nAs to the second point...Let's marry the whole thing with some IO:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">main = do\n  myPi &lt;- readFile &quot;c:/pi/pismaller.txt&quot;\n  writeFile &quot;c:/pi/tmp.txt&quot; (out $ read myPi)\n  piBackwards &lt;- readFile &quot;c:/pi/tmp.txt&quot;\n  writeFile &quot;c:/pi/output.txt&quot; (reverse piBackwards)</code></pre></div>\n<p>The <strong>out</strong> looks a bit lost there, but it does its job. You can see that at the end I turn around the string. Indeed, <strong>out</strong> spills out the rebased Pi backwards. Why? Well, the calculations for the last digits are finished first and so could in theory already be written out to the file. And you know what? That's just what Haskell does! Yeah, I know, you wouldn't really expect this, but on the other hand you think it could and it most probably will start to bind it all together.\nEven so, all this is not desperately efficient. The program took about 35 mins on my T43 (inside a VM) for the 1MB version of PI. Even so, the memory footprint was relatively small and stayed constant, but dividing that darned large number so many times just took a while.</p>\n<p>Well, <em><strong>I</strong></em> am impressed! Not something you need every day, but a task that had me finished in C#.</p>","frontmatter":{"date":"May 15, 2007","path":null,"title":"Haunted by PI - changing a number's base in Haskell","tags":["software-development","geekdom","mathematics","haskell"]}}},"pageContext":{"title":"Haunted by PI - changing a number's base in Haskell"}}