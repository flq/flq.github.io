{"data":{"markdownRemark":{"html":"<h2>Functional space-invaders series</h2>\n<ol>\n<li><a href=\"/2013/09/17/FunSpIns-a-recap-of-Rob-Ashtons-lessons-Das-Intro\">A recap of Rob Ashton's lessons - Das Intro</a></li>\n<li>Drawing a Rectangle</li>\n<li><a href=\"/2013/09/19/FunSpIns-Moving-a-Rectangle\">Moving a Rectangle</a></li>\n<li><a href=\"/2013/09/20/FunSpIns-No-attributes-No-vectors-A-tiny-Workflow-and-more-squares\">No attributes, No vectors, A tiny Workflow and more squares</a></li>\n<li><a href=\"/2013/09/23/FunSpIns-State-the-World-the-Loop\">State, the World, the Loop</a></li>\n<li><a href=\"%7B%25%20post_url%202013-9-24-FunSpIns-The-hero-must-move-the-enemies-must-move-smarter%20%25%7D\">The hero must move, the enemies must move smarter</a></li>\n<li><a href=\"%7B%25%20post_url%202013-9-25-FunSpIns-The-hero-shoots%20%25%7D\">The hero shoots</a></li>\n<li><a href=\"%7B%25%20post_url%202013-9-26-FunSpIns-Collisions-the-dead-and-a-not-so-grateful-ending%20%25%7D\">Collisions, the dead, and a (not so) grateful ending</a></li>\n</ol>\n<blockquote>\n<p>Inspired by Rob Ashton's series \"<a href=\"http://codeofrob.com/entries/learn-functional-programming-with-me---drawing-a-square.html\">Learn functional programming with me</a>\"</p>\n</blockquote>\n<p>It probably <em>is</em> a good idea to introduce to some basic syntax:</p>\n<p>A Haskell function call:</p>\n<pre><code>letme \"die\" \"twice\"\n</code></pre>\n<p>Here, <em>letme</em> would be the function, whereas the remaining parts would be arguments passed to it.</p>\n<p>A Haskell function definition:</p>\n<pre><code>letme:: String -> String -> String\nletme x y = x ++ \" \" ++ y\n</code></pre>\n<p>In Haskell, Types are <strong>sooper-important</strong>. In this example we have specified the signature of the function explicitly.\nAs a sidenote, we don't have to do that, in this case Haskell would have inferred the following signature:</p>\n<pre><code>*Blog> :t letme\nletme :: [Char] -> [Char] -> [Char]\n</code></pre>\n<p>*) <sup>btw, this is taken from the ghci the interactive way to talk with Haskell.</sup></p>\n<p>Huh, not as generic as we thought, how come? - Reason's the <strong>\" \"</strong> in the function definition. Anyway, on to other stuff.</p>\n<p>Assuming you got Haskell ready to talk to SDL (see previous post in the fun spins series), we need to think about how to draw a rectangle.</p>\n<p>Drawing a rectangle certainly is IO, hence that kind of thing will have to happen in Haskell's IO context. In that context it is a fairly OK thing\nto have an entry point - leering a bit at animal machine's series, we can get us a nice lil' entry point:</p>\n<pre><code>module Game where\n\n  import Graphics.UI.SDL as SDL\n\n  main :: IO ()\n  main = do\n   SDL.init [SDL.InitEverything]\n   SDL.setVideoMode 640 480 32 []\n   SDL.setCaption \"Draw Rectangle\"\n   eventLoop\n   SDL.quit\n   print \"done\"\n where\n   eventLoop = SDL.waitEventBlocking >>= checkEvent\n   checkEvent (KeyUp _) = return ()\n   checkEvent _ = eventLoop\n</code></pre>\n<p>Woa, OK - main is a thing that runs in an IO context and returns nothing ( hence the <strong>()</strong> ).\n<strong>>>=</strong> has a type definition of</p>\n<pre><code>Monad m => m a -> (a -> m b) -> m b\n</code></pre>\n<p>Which reads along the lines of</p>\n<blockquote>\n<p>Given some thing of type <strong>a</strong> running in a <strong>context</strong> and a function that accepts something of type a and returns some type <strong>b</strong> running in the <strong>same context</strong>, get me the result of said function, wrapped in that context we mentioned.</p>\n</blockquote>\n<p>I doubt that this helps you, for now it doesn't help me a lot, but I think it is pretty clear what <em>effect</em> the code has. We have ourselves a nice event loop which I am sure will come in handy later on. </p>\n<p>So, what about that frikkin' rectangle?</p>\n<pre><code>module Main where\n\n  import Graphics.UI.SDL as FX\n\n  main :: IO ()\n  main = do\n       FX.init [InitVideo]\n       FX.setVideoMode 640 480 32 []\n       canvas &#x3C;- FX.getVideoSurface\n       FX.fillRect canvas (Just (Rect 25 25 100 100)) (Pixel 0xFFFFFF)\n       FX.flip canvas\n       eventLoop\n       FX.quit\n   where\n       eventLoop = FX.waitEventBlocking >>= checkEvent\n       checkEvent (KeyUp _) = return ()\n       checkEvent _         = eventLoop\n</code></pre>\n<p>Paints us a <strong>white rectangle</strong> at position <strong>25,25</strong> with a width and height of <strong>100</strong> pixels.</p>\n<h3>A word on running the program</h3>\n<p>You can either</p>\n<ul>\n<li>start ghci and then type <strong>:load game</strong>, where your file is called game.hs, or </li>\n<li>use the compiler like <strong>ghc -o game game.hs</strong> </li>\n</ul>","frontmatter":{"date":"September 18, 2013","path":null,"title":"FunSpIns - Drawing a Rectangle","tags":["software-development","haskell","fun-spin"]}}},"pageContext":{"title":"FunSpIns - Drawing a Rectangle"}}