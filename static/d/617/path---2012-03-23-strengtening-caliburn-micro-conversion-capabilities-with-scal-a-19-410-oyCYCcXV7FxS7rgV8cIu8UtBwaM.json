{"data":{"markdownRemark":{"html":"<p>If one looks into how <a href=\"http://caliburnmicro.codeplex.com/\">Caliburn.Micro</a> performs binding between models and views, a number of methods must be considered that play a role.</p>\n<ul>\n<li>Conventions play a role how bindings are derived from naming and involved elements</li>\n<li>VM getter / setter situation plays a role about the supported Binding directions</li>\n<li>Does the VM implement anything Validation-specific?</li>\n<li>Is there a type mismatch between the binding source and target? (classic example: Boolean -> Visibility)</li>\n</ul>\n<p>Especially for the last one Scal introduces a configuration hook to provide your own Value Converters. Check out the usage in the sample application:</p>\n<pre><code>Converters.ApplyDefaults();\n...\npublic static ConverterConfiguration ApplyDefaults(this ConverterConfiguration config)\n{\n    config\n        .Add&#x3C;bool, Visibility, BooleanToVisibilityConverter>()\n        .Add&#x3C;string, ImageSource, PathToImageSourceConverter>();\n    return config;\n}\n</code></pre>\n<p>This is supported by replacing a certain method deep in the bowels of <a href=\"https://github.com/flq/scal\">Scal</a>:</p>\n<pre><code>public class ValueConverterManagement\n{\n    private readonly Dictionary&#x3C;Tuple&#x3C;Type, Type>, IValueConverter> _converters;\n\n    public ValueConverterManagement(AppModel model)\n    {\n        ConventionManager.ApplyValueConverter = ApplyConverter;\n        _converters =  model.Converters.ToDictionary(k => Tuple.Create(k.Item1, k.Item2), v => v.Item3);\n    }\n\n    private void ApplyConverter(Binding binding, DependencyProperty dProp, PropertyInfo vmProp)\n    {\n        var t = Tuple.Create(vmProp.PropertyType, dProp.PropertyType);\n        _converters.Get(t).Do(v => binding.Converter = v);\n    }\n}\n</code></pre>\n<p>The <strong>ConventionManager</strong> is a Caliburn.Micro class that (<em>through the CM-typical override mechanism of replacing static Func-fields</em>) provides a hook into the binding operations. The key to a value converter is the pair of bound ViewModel-Type to the target UIElement type.</p>\n<p>An additional way to leverage Caliburn.Micro's Binding routine is through the <strong>ScalBinding</strong> markup extension:</p>\n<p><code>&#x3C;TextBlock x:Name=\"Hello\" Visibility=\"{svc:ScalBinding IsVisible}\">&#x3C;/TextBlock></code></p>\n<p>This markup extension will call into the relevant CM Binding-related methods beyond those that deal with the Convention-based binding. That way, the binding shown above will use Scal's knowledge of known value converters to map the <strong>Visibility</strong> property to the <strong>IsVisible</strong> bool.</p>","frontmatter":{"date":"March 23, 2012","path":null,"title":"Strengtening Caliburn.Micro conversion capabilities with Scal","tags":["software-development","dotnet","libs-and-frameworks"]}}},"pageContext":{"title":"Strengtening Caliburn.Micro conversion capabilities with Scal"}}