{"data":{"markdownRemark":{"html":"<p>For <a href=\"http://www.isolutions.ch/Seiten/default.aspx\">my new gig</a> I had the chance to look into <a href=\"https://dev.botframework.com/\">Microsoft's Bot framework</a>. Said framework exists to</p>\n<ul>\n<li>provide the foundation of setting up chat <em>Dialogs</em>, similarly to how you would set up screen flows.</li>\n<li>Through its mechanisms of (de)serialization provide a suspendable state machine to keep a conversation with the user going and wire up necessary services like pre-canned dialogs or intention revealing services like <a href=\"https://www.luis.ai/home/index\">LUIS</a></li>\n<li>Through the registration in the bot portal provide the basis of having bots serve multiple channels (think web, but also slack, Skype, Skype for Business, etc.)</li>\n</ul>\n<p>The bot API comes in two flavours:</p>\n<h3>The IDialog<T> interface</h3>\n<p>This is the basic building block of bots. Based on this interface you can package your functionality like MS has done it for example with the in-built Form dialog that will ask questions dictated by the shape of a provided object or the <a href=\"https://github.com/Microsoft/BotBuilder-Location\">location dialog</a>, a pre-canned dialog to collect location data within a conversation with the help of Bing Maps. The type argument of a Dialog refers to its return value. In the case of the location dialog this is e.g. a <strong>Place</strong> object.</p>\n<h3>The Chain fluent API</h3>\n<p>This API allows to chain those callbacks, switches and similar things that you would usually place into a Dialog as lambdas and such construct a bot without having to explicitly define Dialogs yourself.</p>\n<p>My main quarrel with the API is that back in your mind you always need to consider that your Dialog must be serializable. This puts a few restrictions on your design, e.g. how you treat your injected services. Also, with the default serializer you will run into trouble when in your continuations, which you usually express as lambdas, you try to access an instance field of the dialog. In this case the serialization system will just complain bitterly that you simply cannot do that. To get out of that problem, your continuations get access to the state data through an interface passed in.</p>\n<p>Another thing is that the API does not make it easy for you to separate the <em>\"soul\"</em> of your Dialog, the business logic, from the necessary plumbing of the Dialog API, nor is there any guidance on how to do that.</p>\n<p>Granted, all dependencies are accessible through interfaces, such that an <code>IDialog</code> implementation is in theory testable. However, you'll still have the issue of having a class whose structure is predominantly shaped by the technicalities of the Bot API while containing the logic of your conversation.</p>\n<p>What follows is one way to get that separation done. The idea is to define a <em>Saga</em>, where I am using the word in the sense as it is <a href=\"https://docs.particular.net/nservicebus/sagas/\">introduced e.g. by NServiceBus</a>.</p>\n<h3>the bot's body</h3>\n<p>Let us introduce an IDialog implementation that supports kicking off a so-called <strong>Customer Saga</strong>.</p>\n<pre><code class=\"language-csharp\">[Serializable]\npublic class CustomerSagaDrivenDialog&#x3C;T> : IDialog&#x3C;object> where T : ICustomerSaga\n{\n    public Task StartAsync(IDialogContext context)\n    {\n        var customerSaga = Conversation.Container.Resolve&#x3C;T>();\n        context.SetSaga(customerSaga);\n        context.Wait(WaitForUserToStart);\n        return Task.CompletedTask;\n    }\n    ...\n}\n\npublic interface ICustomerSaga\n{\n    Task&#x3C;ProcessResponse> Start(string input);\n}\n</code></pre>\n<p>The container (which btw is an AutoFac container, i.e. thank the decent engineers working on this that it's not Unity) resolves our Saga and is directly put into the <strong>context</strong>. Context is an object which also implements <code>IBotData</code>, an interface which abstracts away the access to data which consitutes the state of your conversation and user interaction. Then we wait for the user to talk to our bot. Once this happens...</p>\n<pre><code class=\"language-csharp\">private async Task WaitForUserToStart(IDialogContext context, IAwaitable&#x3C;IMessageActivity> result)\n{\n    var r = await result;\n    context.ConversationData.TryGetValue(\"saga\", out T saga);\n    var whatNext = await saga.Start(r.Text);\n    HandleWhatNext(context, whatNext);\n}\n</code></pre>\n<p>We await the result that contains amongst other info the user's input, obtain/deserialize the saga from the bot's state, and call the <strong>Start</strong> method of the saga with the user's input. <strong>whatNext</strong> is just a sloppy name for an object that will help us to dispatch what should happen next in the dialog.</p>\n<pre><code class=\"language-csharp\">private async void HandleWhatNext(IDialogContext context, ProcessResponse whatNext)\n{\n    whatNext.Being&#x3C;ContinuedResponse>(context.SetContinuation);\n\n    switch (whatNext)\n    {\n        case TerminateDialog td: ...\n        case AskForAddress afa: ...\n        case PromptResponse pr:\n            PromptDialog.Text(context, async (dialogContext, result) =>\n            {\n                var response = await result;\n                var continuation = await dialogContext.CallContinuation&#x3C;T>(response);\n                HandleWhatNext(dialogContext, continuation);\n            }, pr.Prompt);\n            break;\n        default: ...\n    }\n}\n</code></pre>\n<p><code>ProcessResponse</code> is the name of the abstract class from which all actions emanating from the Saga inherit. With the new switch enhancement we can now also pattern-match on the actual return type halfway decently even in C#. Also of note is the first line that will store the continuation of said action <strong>if</strong> the action is a <code>ContinuedResponse</code>. All <code>ProcessResponse</code> types are a <code>ContinuedResponse</code> apart from those that, well, end the dialog and hence have no continuation, e.g. the <code>TerminateDialog</code> type.</p>\n<p>The code above shows one example how the Saga's action is handled. Here, a Bot Dialog helper is used to prompt the user with some text, then, with the user's response the continuation is called that had previously been stored in the context.</p>\n<p>What happens in <code>CallContinuation</code>?</p>\n<pre><code class=\"language-csharp\">public static async Task&#x3C;ProcessResponse> CallContinuation&#x3C;T>(this IDialogContext ctx, object input) \n    where T :  ICustomerSaga\n{\n    ctx.ConversationData.TryGetValue(\"saga\", out T saga);\n    if (ctx.ConversationData.TryGetValue(\"continuation\", \n        out ContinuedResponse continuation))\n    {\n        var value = await continuation.Call(saga, input);\n        // The saga may have changed its internal state and \n        // wants back into the bag\n        ctx.SetSaga(saga);\n        return value;\n    }\n    return ProcessResponse.NoOp;\n}\n</code></pre>\n<p>Here the saga is taken from the context as well as a previously stored continuation. Once both are obtained, the continuation is called with the current input that has been provided by the bot framework. This could be a simple text from the user, or some complex object from some child dialog that has just completed. Also of importance is that after having obtained the next action from the Saga, the saga is put back into its box, as it may have changed its internal state (which is kind of the whole point of a Saga).</p>\n<p>In the continuation call we get a little bit dirty:</p>\n<pre><code class=\"language-csharp\">public Task&#x3C;ProcessResponse> Call(object saga, object input)\n{\n    var method = saga.GetType().GetMethod(Continuation, \n      BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);\n    if (method == null)\n        return Task.FromResult&#x3C;ProcessResponse>(\n            new TerminateDialog { \n                Text = $\"Failure to identify a continuation from {Continuation}\" \n            });\n    var result = method.Invoke(saga, new [] { input });\n    return (Task&#x3C;ProcessResponse>)result;\n}\n</code></pre>\n<p>A sprinkle of reflection helps us break the chains of serialization. My first attempt had been to store an actual delegate\nas continuation, but since those continuations need to be serializable, the default serializer was in deep trouble with those.\nHence the necessary weakening of compile-time safety.</p>\n<p>Now that we have covered the <em>body</em>, let's look at the bot's <em>soul</em>.</p>\n<h3>the bot's soul</h3>\n<p>Let us look at the setup of the Saga:</p>\n<pre><code class=\"language-csharp\">public class SomeSaga : ICustomerSaga\n{\n    private IIntentRecognition _intentRecognition;\n\n    public SomeState State { get; set; }\n    \n    [UsedImplicitly]\n    public AddressChangeSaga(IIntentRecognition intentRecognition)\n    {\n        _intentRecognition = intentRecognition;\n    }\n\n    [OnDeserialized]\n    private void OnDeserialized(StreamingContext context)\n    {\n        _intentRecognition = Conversation.Container.Resolve&#x3C;IIntentRecognition>();\n    }\n    ...\n}\n</code></pre>\n<p>The deserialize hook is where things are ugly. The bot framework does not seem to use AutoFac to pull a bot state item\nback into life, hence we cannot trust our dependencies to be correctly injected in this situation. That is where the deserialize hook comes into play and <em>\"injects\"</em> the dependencies into the Saga. Thankfully this doesn't cause much problems in testing since there we can create the Saga as usual through its constructor.</p>\n<p>Finally, let us look into the Saga's Start method:</p>\n<pre><code class=\"language-csharp\">public async Task&#x3C;ProcessResponse> Start(string input)\n{\n    var intent = await _intentRecognition.FigureOutIntent(input);\n    switch (intent)\n    {\n        case UserIntent.Greeting:\n            return new PromptRespons\n                Prompt = BotTexts.GreetingText, \n                Continuation = nameof(Start) \n            };\n        case UserIntent....:\n            return new PromptResponse { \n                Prompt = BotTexts.QuestionForNameText, \n                Continuation = nameof(FindCustomer) \n            };\n    }\n    return new TerminateDialog { Text = \"Woa, you got me there \\U0001F937.\" };\n}\n</code></pre>\n<p>As you can see the <em>soul</em> of the dialog is now decoupled from the Dialog's mechanics. The <code>nameof</code> helps us to alleviate the pain of necessary reflection by keeping refactoring support going and helping us pick the right method to continue to.</p>\n<p>Where we still need to keep an eye on is that the type of the argument to the continuation matches the requirements, e.g. here, after a user has provided us with an address:</p>\n<pre><code class=\"language-csharp\">private async Task&#x3C;ProcessResponse> AddressObtained(Place place)\n{\n    try\n    {\n        ...\n        await _someService.UpdateAddress(place);\n        return new TerminateDialog { Text = BotTexts.AddressUpdatedAndProcessFinishedText };\n    }\n    catch (Exception)\n    {\n        return new TerminateDialog { Text = BotTexts.FailedToStoreAddressText };\n    }\n}\n</code></pre>\n<p>It seems like quite a bit of work, considering that <code>IDialog</code> implementations are indeed testable by virtue of all dependencies being interfaces. But consider this: A conversational interaction with a user will be full of branching, fallbacks, a lot of dispatching and state keeping. I am farily convinced that it makes sense to decouple conversation logic\nfrom the bot infrastructure, because stuff will get <strong>complicated quite quickly</strong> and what better way to tame complexity than to separate concerns. </p>","frontmatter":{"date":"June 25, 2017","path":null,"title":"Separating MS Bot's soul from its body","tags":["dotnet","programming","software-development","cloud"]}}},"pageContext":{"title":"Separating MS Bot's soul from its body"}}