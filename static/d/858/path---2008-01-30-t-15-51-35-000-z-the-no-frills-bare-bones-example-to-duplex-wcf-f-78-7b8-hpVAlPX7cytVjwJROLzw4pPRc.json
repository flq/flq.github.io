{"data":{"markdownRemark":{"html":"<p>Can a WCF client call a WCF service and have the server call back with whatever? Oh, yes. Can you get an example how it's done? Indeed.</p>\n<p>Are these good examples? Well, you can get <a href=\"http://www.microsoft.com/downloads/thankyou.aspx?familyId=2611a6ff-fd2d-4f5b-a672-c002f1c09ccd&#x26;displayLang=en\">MS samples for WCF</a> (which in their entirety are really helpful) or <a href=\"http://dotnetaddict.dotnetdevelopersjournal.com/wcf_alarmclock.htm\">another blog post</a> on the subject. Don't get me wrong, they work, but in my humble opinion they have shortcomings.</p>\n<ul>\n<li>They have funny classes and interfaces generated by svcutil with some really horrid artefacts  <li>The interfaces are not shared among client &#x26; server which annoys my desire for harmony and DRYness, which should be followed even in an example (or, maybe, especially in an example). </li>\n</ul>\n<p>Anyway, here's my version, which is quite reduced to just the duplex stuff.</p>\n<h2>Common bits</h2>\n<pre><code>[ServiceContract(Namespace = \"rf.services\", \n CallbackContract = typeof(IDataOutputCallback), \n SessionMode = SessionMode.Required)]\npublic interface IServerWithCallback\n{\n    [OperationContract(IsOneWay=true)]\n    void StartDataOutput();\n}\n</code></pre>\n<p>That's the Server interface which the client will use to talk to the server. Please note the _CallBackContract _property of the _ServiceContract _attribute. That's the interface that will have to be implemented by the client. The server will use it to call back.\n<code>public interface IDataOutputCallback { [OperationContract(IsOneWay = true)] void SendDataPacket(string data); }</code></p>\n<p>All this <em>IsOneWay</em> business is one way to avoid issues when you're calling back a client within the method that is being called by the client. The issues are described <a href=\"http://www.codeproject.com/KB/WCF/WCF_Duplex_UI_Threads.aspx\">here</a>.</p>\n<h2>Server</h2>\n<p>Of course we need an implementation of the service (d'oh): </p>\n<pre><code>class ServerWCallbackImpl : IServerWithCallback { \n  \n  public void StartDataOutput() { \n    IDataOutputCallback callback = OperationContext.Current.GetCallbackChannel&#x3C;IDataOutputCallback>(); \n    for (int i = 0; i &#x26;lt; 10; i++) { \n      Random r = new Random(); \n      int interval = r.Next(500,3000); \n      System.Threading.Thread.Sleep(interval); \n      callback.SendDataPacket(\"Packet \" + i.ToString()); \n    } \n    callback.SendDataPacket(\"Last packet is this one :)\"); \n  }\n\n}\n</code></pre>\n<p>The important line is the very first one. The rest is just a crappy example to get some funny callback side-effects. Next we have the configuration of the thing...</p>\n<pre><code>&#x3C;system.serviceModel>\n  &#x3C;services>\n    &#x3C;service name=\"ServerPart.ServerWCallbackImpl\">\n      &#x3C;endpoint address=\"net.tcp://localhost:9080/DataService\" binding=\"netTcpBinding\"\n          bindingConfiguration=\"\" name=\"DataEndpoint\" contract=\"CommonParts.IServerWithCallback\" />\n    &#x3C;/service>\n  &#x3C;/services>\n&#x3C;/system.serviceModel>\n</code></pre>\n<p>And some boilerplate to get it running e.g. in a command-line:</p>\n<pre><code>ServiceHost svc = new ServiceHost(typeof(ServerWCallbackImpl)); \nsvc.Open(); \nConsole.WriteLine(\"Listening according to configuration\"); \nConsole.ReadKey(); \n</code></pre>\n<p>If you want to save yourself the configuration etry in the app.config file, you can also set up the ServiceHost programmatically:</p>\n<pre><code>ServiceHost duplex = new ServiceHost(typeof(ServerWCallbackImpl)); \nduplex.AddServiceEndpoint(typeof(IServerWithCallback), new NetTcpBinding(), \"net.tcp://localhost:9080/DataService\"); \nduplex.Open(); \n</code></pre>\n<h2>Client</h2>\n<p>Want to call the server? Well, first you could go and configure it:</p>\n<pre><code>&#x3C;system.serviceModel>\n    &#x3C;client>\n      &#x3C;endpoint address=\"net.tcp://localhost:9080/DataService\" binding=\"netTcpBinding\"\n            bindingConfiguration=\"\" contract=\"CommonParts.IServerWithCallback\" name=\"Callback\">\n      &#x3C;/endpoint>\n    &#x3C;/client>\n&#x3C;/system.serviceModel>\n</code></pre>\n<p>Then it'll make sense to provide an implementation of the Callback interface:</p>\n<pre><code>class CallbackImpl : IDataOutputCallback { \n\n  public void SendDataPacket(string data) { \n    Console.WriteLine(data); } #endregion \n  }\n</code></pre>\n<p>Brill! Finally the boilerplate to kickstart the thing:</p>\n<pre><code>DuplexChannelFactory&#x3C;IServerWithCallback> cf = \n  new DuplexChannelFactory&#x3C;IServerWithCallback>( new CallbackImpl(), \"Callback\"); \nIServerWithCallback srv = cf.CreateChannel(); \nsrv.StartDataOutput(); \n</code></pre>\n<p>Again, if you prefer working without a configuration entry, you can set this up programmatically, too:</p>\n<pre><code>DuplexChannelFactory&#x3C;IServerWithCallback> cf = \n  new DuplexChannelFactory&#x3C;IServerWithCallback>(\n  new CallbackImpl(), \n  new NetTcpBinding(), \n  new EndpointAddress(\"net.tcp://localhost:9080/DataService\"));\n</code></pre>\n<p>That's it, you shouldn't need more, honest, dude. No generated class in sight, all interfaces are the same throughout Client and Server. Distribute over projects/threads/app domains at your leisure and enjoy.</p>\n<p><strong>Update</strong>: <a href=\"/public/assets/RF.WCF.Callback.zip\">Here is a small vs2008 solution</a> that shows the programmatic setup of this blog post.</p>","frontmatter":{"date":"January 30, 2008","path":null,"title":"The no frills, bare-bones example to Duplex WCF","tags":["download","dotnet","libs-and-frameworks"]}}},"pageContext":{"title":"The no frills, bare-bones example to Duplex WCF"}}