{"data":{"markdownRemark":{"html":"<h2>2D Historization series</h2>\n<ol>\n<li>[2D or bitemporal Historization: A primer][1]</li>\n<li>[2D-Historization in a graph database][2]</li>\n<li>Simplify the bitemporal Neo4J query with a user-defined function</li>\n</ol>\n<p>In the previous post we have seen how we can translate the logic of\ncorrectly describing the historical events from the first post into a Cypher query.</p>\n<p>To remind you, it looks like this:</p>\n<pre><code>MATCH (pd:PersonData)-[r]-(p) \nWHERE p.id = 665544 AND r.recorded &#x3C;= 30\nWITH { data: pd, recorded: r.recorded, actual: r.actual } as data\nWITH data ORDER BY data.recorded DESC\nWITH reduce(relevant = [], d in collect(data) | \nCASE \nWHEN last(relevant) IS NULL OR d.actual &#x3C; last(relevant).actual THEN relevant+d \nELSE relevant END) \nAS data\nUNWIND data AS final \nRETURN final.actual, final.data\n</code></pre>\n<p>It is certainly a bit unwieldy, considering that you want historical data\nmaybe not only from a single node, but other ones, too.\nA good idea seems to be to let the query writer pick out those nodes that require\nconsideration and then have a function that contains the logic of picking up\nthe correct ones. Let us do just that.</p>\n<p>In Neo4J you can also [write \"stored procedures\"][3] and \"user-defined functions\" (<strong>UDF</strong>).\nDepending on your upbringing you may dislike the idea of putting \"logic\" into the\ndatabase engine. However, there are two differences to stored procedures and functions\nas we know them from Oracle and Sql server:</p>\n<ul>\n<li>We can write the Neo4J code to be run as procedure / function in Java\n(or some other JVM language). Depending on how you write the other parts\nof your application this may considerably help in traslating your skills to the\nDB.</li>\n<li>Neo4J [provides infrastructure][4] that allows you to fire up an embedded instance\nand use it within your tests to actually <strong>test your procedures / functions</strong>\nclose to real-life scenarios.</li>\n</ul>\n<p>With that in mind you may feel that not much speaks against encapsulating some\ntechnical aspect of your DB model into a function.</p>\n<p>The implementation of the UDF is pretty straightforward:</p>\n<pre><code class=\"language-java\">import org.neo4j.graphdb.GraphDatabaseService;\nimport org.neo4j.procedure.Name;\nimport org.neo4j.procedure.UserFunction;\n...\n\npublic class Bitemp\n{\n\n  @Context\n  public GraphDatabaseService db;\n\n  /**\n    * Creates a bitemporal projection for a list of maps\n    * @param data a list of maps of the form { data: node, recorded: int, actual: int }\n    * @return The stream of resulting paths throughout the object.\n    */\n  @UserFunction(\"bitemp.projection\")\n  public List&#x3C;Map> bitempProjection(\n          @Name(\"data\") List&#x3C;Map> data)\n  {\n\n      List&#x3C;Map> sorted = StreamSupport.stream(data.spliterator(), false)\n              .sorted((o1, o2) -> (int) ((Long) o2.get(\"recorded\") - (Long) o1.get(\"recorded\")))\n              .collect(Collectors.toList());\n\n      ArrayList&#x3C;Map> result = new ArrayList&#x3C;>();\n      for (Map n : sorted) {\n          if (result.size() == 0)\n          {\n              result.add(n);\n              continue;\n          }\n          Map reference = result.get(result.size() - 1);\n          if ((long)n.get(\"actual\") &#x3C; (long)reference.get(\"actual\"))\n              result.add(n);\n      }\n\n      return result;\n  }\n}\n</code></pre>\n<p>Of note is the  <code>UserFunction</code>-annotation, which did not exist until recent\nversions of Neo4J.\nBefore you had to define your user procedures as, well, procedures, making the\ncall of your procedures from within Cypher a little bit more involved (<code>CALL...YIELD</code>).</p>\n<p>Also remember that all numbers defined on nodes / relationships will appear as\n<strong>Long</strong>s.</p>\n<p>Finally, there is a <code>sort</code>-method on the <code>List</code>-interface, however, the implementation\nthat Neo4J passes to you appears to not implement it, hence the external sort\nvia the <code>Stream</code>-utilities.</p>\n<p>The function assumes that you send in data of a certain shape. It will then\nbe able to sort the nodes correctly and dismiss those nodes that are \"invisible\"\nwithin the given set.</p>\n<p>By compiling our UDF and adding the resulting jar to Neo4J's <strong>plugins</strong> folder,\nwe can start using it:</p>\n<pre><code class=\"language-cypher\">MATCH (pd:PersonData)-[r]-(p) \nWHERE p.id = 665544 AND r.recorded &#x3C;= 30\nWITH collect({ data: pd, recorded: r.recorded, actual: r.actual }) AS data\nUNWIND bitemp.projection(data) AS final\nRETURN final.actual, final.data\n</code></pre>\n<p>As you can see we have a nice distribution of responsibilities:\nQuery the correct set of data you are interested in, and use the function\nto project them correctly.</p>\n<p>For completeness' sake we can also provide a function that gives us the current\nstate for some query:</p>\n<pre><code class=\"language-java\">/**\n  * Returns the current state out of a list of maps\n  * @param data a list of maps of the form { data: node, recorded: int, actual: int }\n  * @return The Map that is currently valid or none if nothing is valid right now.\n  */\n@UserFunction(\"bitemp.current\")\npublic Map bitempCurrent(@Name(\"data\") List&#x3C;Map> data)\n{\n    long today = getTodaysActual();\n    return StreamSupport.stream(bitempProjection(data).spliterator(), false)\n            .filter(n ->  (long)n.get(\"actual\") &#x3C;= today)\n            .findFirst()\n            .orElse(null);\n}\n\nprivate long getTodaysActual() {\n    Node n = db.findNodes(Label.label(\"Today\")).next();\n    return (Long)n.getProperty(\"value\");\n}\n</code></pre>\n<p>This function uses the previously established UDF as well as a node labelled\n<strong>\"Today\"</strong> which should contain the numeric value of today (this can obviously\nbe solved differently, typically by using something like Epoch in seconds).\nSince the data already comes out newest to oldest from the <code>bitempProjection</code>-\nmethod, we can just pick the first item where the actual date is smaller than\ntoday.</p>\n<p>With that we can get the current state of our person:</p>\n<pre><code>MATCH (pd:PersonData)-[r]-(p {id: 665544})\nWITH p, collect({ data: pd, recorded: r.recorded, actual: r.actual }) as data\nRETURN p, bitemp.current(data).data\n</code></pre>\n<p><img src=\"/public/assets/2DHistory6.png\"></p>\n<p>[1]: {% post<em>url 2016-12-18-2D-Historization-A-primer %}\n[2]: {% post</em>url 2017-01-26-2D-Historization-in-a-graph-database %}\n[3]: <a href=\"http://neo4j.com/docs/developer-manual/current/extending-neo4j/procedures/\">http://neo4j.com/docs/developer-manual/current/extending-neo4j/procedures/</a>\n[4]: <a href=\"http://neo4j.com/docs/developer-manual/current/extending-neo4j/procedures/#_writing_integration_tests\">http://neo4j.com/docs/developer-manual/current/extending-neo4j/procedures/#<em>writing</em>integration_tests</a></p>","frontmatter":{"date":"January 30, 2017","path":null,"title":"Simplify the bitemporal Neo4J query with a user-defined function","tags":["software-development","patterns","programming"]}}},"pageContext":{"title":"Simplify the bitemporal Neo4J query with a user-defined function"}}