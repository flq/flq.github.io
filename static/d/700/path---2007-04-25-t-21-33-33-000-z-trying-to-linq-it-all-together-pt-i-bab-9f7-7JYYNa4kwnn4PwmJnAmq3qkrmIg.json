{"data":{"markdownRemark":{"html":"<p>Yeah, yeah, we've all done our <strong><em>from thingy in stuff where thingy.Age > 26</em></strong>, etc., etc.</p>\n<p>I wanted to try something else for starters. I fired up my March CTP Orcas and got myself a Person (as usual, I can relate to them). The list I create for testing looks as follows:</p>\n<pre><code class=\"language-csharp\">public static Person[] CreatePeopleList() {\n  return new Person[] {\n    new Person { Name = \"Arthur\", Posn = Position.Boss, Salary=10000},\n    new Person { Name = \"Selma\", Posn = Position.Middleman, Salary=6000},\n    new Person { Name = \"Buttocks\", Posn = Position.Middleman, Salary=5500},\n    new Person { Name = \"Shawn\", Posn = Position.Peasant, Salary=4000},\n    new Person { Name = \"Burgess\", Posn = Position.Peasant, Salary=3800},\n  };\n}\n</code></pre>\n<p>Bog standard hierarchy in any company. My aim now was to get a total of the salaries grouped by the available positions. The new capabilities indeed allow to quickly express such a thing, albeit I suppose I am becoming a lambda fan, since that was my first result:</p>\n<pre><code class=\"language-csharp\">Person[] pees = Person.CreatePeopleList();\nvar salaryDistribution =\npees.GroupBy(p => p.Posn)\n  .Select(group => \n            new { \n              Position = group.Key, \n              TotalSalary = group.Sum(p => p.Salary) \n            });\n\nsalaryDistribution.ToList()\n  .ForEach(entry => \n             Console.WriteLine(\"Position {0} earns {1} bucks\",entry.Position,entry.TotalSalary));\n</code></pre>\n<p>Those funny <strong>Select()</strong> and <strong>GroupBy()</strong> all come from the <strong>System.Linq</strong> namespace and are extension methods to your well-known IEnumerable&#x3C;> interface. In other words, all arrays, collections, etc. can benefit from LINQ functionality.</p>\n<p>First question: Is the code understandable? I hope so. In this specific case </p>\n<ul>\n<li><strong>GroupBy()</strong> returns an Enumerable of Type <code>IGrouping&#x3C;Position,Person></code>.</li>\n<li>This thing has a Key and can again in turn be enumerated, here it results in returning all Persons grouped under that key.</li>\n<li>In other words, I can now apply the <strong>Select()</strong>. This one is quite similar to a <code>IEnumerable -> IEnumerable</code>mapping.</li>\n<li>The Select on the group by then returns the <code>IGrouping&#x3C;Position,Person></code> objects from which the key (Person's Position) can be extracted.</li>\n<li>Since it is in itself also enumerable we can now use the <strong>Sum()</strong> method (also a new LINQ method) which will generate a sum over all provided elements.</li>\n<li>From all this stuff I finally generate an anonymous type containing the position and the sum of salaries under that position.</li>\n</ul>\n<p>So far, so nice. I spared myself of writing the same code with C#2.0 capabilities, but I would expect it to be roughly  5-8 lines more. We don't really need funny keywords to get the power of LINQ, ...[snip]</p>\n<h2>Update from 29.04.07 - The following lines lead to wrong conclusions. For a better picture read the <a href=\"%7B%25%20post_url%202007-4-29-Trying-to-LINQ-it-all-together-Pt-I-Epilogue%20%25%7D\">next post</a></h2>\n<p>In fact in this case a bug stopped me in my attempt to express this query with the available keywords select, group, etc.</p>\n<p>That is as far as I got:</p>\n<pre><code>var salarySums =\n  from p in pees\n  group p by p.Posn into groups\n  from grp in groups\n  select grp.Key;\n</code></pre>\n<p>The error you'll get:</p>\n<pre><code>'Popular.Person' does not contain a definition for 'Key' and no extension method 'Key' accepting a first argument of type 'Popular.Person' could be found \n(are you missing a using directive or an assembly reference?)\n</code></pre>\n<p>Oops, did I miss something? Heck, no, you would expect groups to be an IEnumerable containing <code>IGrouping&#x3C;Position,Person></code>, just like what I did with the lambdas further up. That is in fact what the current documentation also expects and when I copy the doc's group by example into my source code it fails by the same reason: The compiler thinks that groups is an IEnumerable containing...Persons. This is plain wrong and I will see if I get it to Microsoft somehow, if it hasn't already happened.</p>\n<p>To sum it up for today: I think the LINQ methods are very practical but I have the feeling that I will favour the lambda-based usage over the keyword-based one. In this case the keyword-based query would have gotten pretty convoluted. Time will tell what is more readable / maintainable/ powerful!</p>","frontmatter":{"date":"April 25, 2007","path":null,"title":"Trying to LINQ it all together (Pt. I)","tags":["software-development","dotnet","libs-and-frameworks"]}}},"pageContext":{"title":"Trying to LINQ it all together (Pt. I)"}}