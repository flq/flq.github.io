{"data":{"markdownRemark":{"html":"<h2>Functional space-invaders series</h2>\n<ol>\n<li><a href=\"/2013/09/17/FunSpIns-a-recap-of-Rob-Ashtons-lessons-Das-Intro\">A recap of Rob Ashton's lessons - Das Intro</a></li>\n<li><a href=\"/2013/09/18/FunSpIns-Drawing-a-Rectangle\">Drawing a Rectangle</a></li>\n<li>Moving a Rectangle</li>\n<li><a href=\"/2013/09/20/FunSpIns-No-attributes-No-vectors-A-tiny-Workflow-and-more-squares\">No attributes, No vectors, A tiny Workflow and more squares</a></li>\n<li><a href=\"/2013/09/23/FunSpIns-State-the-World-the-Loop\">State, the World, the Loop</a></li>\n<li><a href=\"/2013/09/24/FunSpIns-The-hero-must-move-the-enemies-must-move-smarter\">The hero must move, the enemies must move smarter</a></li>\n<li><a href=\"/2013/09/25/FunSpIns-The-hero-shoots\">The hero shoots</a></li>\n<li><a href=\"/2013/09/26/FunSpIns-Collisions-the-dead-and-a-not-so-grateful-ending\">Collisions, the dead, and a (not so) grateful ending</a></li>\n</ol>\n<blockquote>\n<p>Inspired by Rob Ashton's series \"<a href=\"http://codeofrob.com/entries/learn-functional-programming-with-me---moving-the-square.html\">Learn functional programming with me</a>\"\nLast time a square got drawn, this time moving it would be nice. Rob's approach was based on a recursive function call,\none of the basic tools in FP to essentially do loops.</p>\n</blockquote>\n<p>Another way to consider the movement would be to look at it as a list of numbers, or coordinates, that dictate at which position\nthe rectangle should be drawn. One weapon of choice in Haskell for sequences of things are <a href=\"http://learnyouahaskell.com/starting-out#im-a-list-comprehension\">list comprehensions</a>.</p>\n<blockquote>\n<p>Incidentally I learned about list comprehensions in Erlang, which look very similar to Haskell's </p>\n</blockquote>\n<p>Hence, from a given sequence I would create Rectangles that were ready to be drawn onto a screen:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[(Just (Rect x 25 50 50)) | x &lt;- [1..450]]</code></pre></div>\n<p>and for each one of those I would want to draw it on the screen, hence I prepared myself this function:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">fillDo canvas rect = do \n FX.fillRect canvas Nothing (Pixel 0)\n FX.fillRect canvas rect (Pixel 0xFFFFFF)\n FX.flip canvas</code></pre></div>\n<h2>The do-notation</h2>\n<p>all SDL operations happen in the IO monad, which can be seen nicely when we look at the type of the involved functions:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">FX.fillRect :: Surface -&gt; Maybe Rect -&gt; Pixel -&gt; IO Bool\nFX.flip :: Surface -&gt; IO ()</code></pre></div>\n<p>If we want to work with them, we will need to work in that context ourselves. Haskell has a number of functions to work with Monads, one of them being <strong>(>>)</strong>. Its type is</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">(&gt;&gt;) :: Monad m =&gt; m a -&gt; m b -&gt; m b</code></pre></div>\n<p><sup>*) Within the same monad, given a one-in, one-out function, return the output of the function</sup> </p>\n<p>It looks and sounds trivial, but actually allows to chain functions together that happen in the same context. i.e. something like</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">-- putStr :: String -&gt; IO ()\nputStr &quot;Hello&quot; &gt;&gt; \nputStr &quot; &quot;\n--becomes\ndo\n  putStr &quot;Hello&quot;\n  putStr &quot; &quot;</code></pre></div>\n<h2>List + fillDo = ...</h2>\n<p>My initial attempt was to take my list of Rectangles and map the fillDo over it:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">map (fillDo canvas) [(Just (Rect x 25 50 50)) | x &lt;- [1..450]]</code></pre></div>\n<p>Note the use of currying - (fillDo canvas) returns a function that takes a rect as a parameter and returns <strong>IO ()</strong>.</p>\n<p>Alas, it wouldn't compile. After some thinking and googling, the issue dawned on me: every function inside a do block\nmust return into the same context with which we started off. Alas, the last line of code did not return an <strong>IO sth</strong>, but\nrather <strong>[IO sth]</strong>, an array of things in the IO context. What I wanted was actually <strong>IO [sth]</strong>.</p>\n<blockquote>\n<p>Once you get the hang out of it, Haskell errors can be quite understandable. This one was...</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Couldn&#39;t match expected type `IO a0&#39; with actual type `[b0]&#39;\nIn the return type of a call of `map&#39;\nIn a stmt of a &#39;do&#39; block:\n...</code></pre></div>\n<p>Thankfully there is a version of <strong>map</strong> with the kind of signature that we need:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">mapM :: Monad m =&gt; (a -&gt; m b) -&gt; [a] -&gt; m [b]</code></pre></div>\n<p><sup>*) Given a function taking a's and returning b's within m and an array of a's, give me the resulting array of b's, within the m context</sup></p>\n<p>Bingo, small change and here's the full program:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">module Main where\n\n  import Graphics.UI.SDL as FX\n\n  main :: IO ()\n  main = do\n    init\n    canvas &lt;- FX.getVideoSurface\n    mapM (fillDo canvas) [Rect x 25 50 50 | x &lt;- [1..450]]\n    delay 1000\n    FX.quit\n    where\n      fillDo canvas rect = do \n        FX.fillRect canvas Nothing (Pixel 0)\n        FX.fillRect canvas (Just rect) (Pixel 0xFFFFFF)\n        FX.flip canvas\n      init = do\n        FX.init [InitVideo]\n        FX.setVideoMode 640 480 32 []</code></pre></div>\n<p>So far I do not want to go full steam ahead and implement the <strong>logic/render/repeat</strong> thing, since, to be honest, I don't quite see where this is heading. Even so,  there is some potential looming for separating logic from rendering as the production of the rectangle <em>\"path\"</em> can be looked at independent of <em>IO</em>. </p>\n<h3>PS</h3>\n<p>we saved ourselves the \"white smear\" stage by adding that canvas cleaning code in the <strong>fillDo</strong> (<em>FX.fillRect canvas Nothing (Pixel 0)</em>)</p>","frontmatter":{"date":"September 19, 2013","path":null,"title":"FunSpIns - Moving a Rectangle","tags":["software-development","haskell","fun-spin"]}}},"pageContext":{"title":"FunSpIns - Moving a Rectangle"}}