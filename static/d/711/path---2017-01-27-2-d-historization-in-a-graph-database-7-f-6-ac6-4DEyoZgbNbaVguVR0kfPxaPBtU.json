{"data":{"markdownRemark":{"html":"<h3>2D Historization series</h3>\n<ol>\n<li><a href=\"/2016/12/18/2d-or-bitemporal-historization-a-primer\">2D or bitemporal Historization: A primer</a></li>\n<li>2D-Historization in a graph database</li>\n<li><a href=\"/2017/01/30/simplify-the-bitemporal-neo4j-query-with-a-user-defined-function\">Simplify the bitemporal Neo4J query with a user-defined function</a></li>\n</ol>\n<blockquote>\n<p><em>Note:</em>\nThis text assumes that you know a little bit about graph databases\nand Neo4J in particular. If you don't know Neo4J, please have a read\nat <a href=\"https://neo4j.com/docs/developer-manual/current/introduction/\">Neo4J's documentation</a></p>\n</blockquote>\n<p>The <a href=\"/2016/12/18/2d-or-bitemporal-historization-a-primer\">introduction to 2D-historization</a> dealt with the theory behind representing\nand reading state changes of your data in a model where we keep the time when\nthe state change was recorded together with the actual time, the time where we want\nthe state change to be applied in the context of whatever it is the application\nis representing.</p>\n<p>My point of orientation when implementing 2D-historized data was Ian Robinson's\n<a href=\"http://iansrobinson.com/2014/05/13/time-based-versioned-graphs/\">post on time-based versioned graphs</a></p>\n<p>In here we find the following principles when representing data in the graph:</p>\n<ul>\n<li>We extract the immutable data about some entity into a single <strong>node</strong>. This\nwould typically be the data that uniquely identifies the entity. Under certain\ncircumstances this may be just some id, but depending on your case, more data\ncould be stored in that node</li>\n<li>Any data that can change over time is extracted to another node, attached\nto the immutable one via a relationship that stores the <strong>actual</strong> and\n<strong>recorded</strong> time when the data node was created.</li>\n<li>Repeat for any additional changes that are introduced to the entity.</li>\n</ul>\n<p>Here is some cypher to create an example:</p>\n<div class=\"gatsby-highlight\" data-language=\"cypher\"><pre class=\"language-cypher\"><code class=\"language-cypher\">CREATE (p:Person { id: 112245 })\nCREATE (pd:PersonData { name: &#39;Joe Bloggs&#39; })-[:EXPANDS { recorded: 10, actual: 10}]-&gt;(p)\nCREATE (pd2:PersonData { name: &#39;Joe Gonzalez&#39; })-[:EXPANDS { recorded: 20, actual: 30}]-&gt;(p)</code></pre></div>\n<p>Consider the <em>actual</em> and <em>recorded</em> values to be e.g. days since inception...</p>\n<p><img src=\"/assets/2DHistory3.png\"></p>\n<p>The query to get the right history of PersonData changes is pretty straightforward:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">MATCH (pd:PersonData)-[r]-(p) \nWHERE p.id = 112245\nAND r.recorded &lt;= 30\nRETURN r.recorded, r.actual, pd.name\nORDER BY r.recorded DESC</code></pre></div>\n<p><em>(assuming existence of only the EXPANDS relationship)</em></p>\n<p>However, we've previously seen that some entries may be cancelled out,\ne.g. when you record a future state and later on you record a new state\nthat will be valid before the previously recorded one.</p>\n<p>We can consider the following example:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">CREATE (p:Person { id: 665544 })\nCREATE (pd:PersonData { name: &#39;A. Brannigan&#39; })-[:EXPANDS { recorded: 10, actual: 10}]-&gt;(p)\nCREATE (pd2:PersonData { name: &#39;A. Durington&#39; })-[:EXPANDS { recorded: 20, actual: 40}]-&gt;(p)\nCREATE (pd3:PersonData { name: &#39;A. Lovegood&#39; })-[:EXPANDS { recorded: 30, actual: 30}]-&gt;(p)</code></pre></div>\n<p>The logic how such state changes should be considered is explained\n<a href=\"/2016/12/18/2d-or-bitemporal-historization-a-primer\">in the previous blog post</a>. To recap:</p>\n<ul>\n<li>move backwards along the recorded time axis.</li>\n<li>add events to the history whose <strong>actual</strong> time lies before the last state\ncollected</li>\n<li>ignore those whose <strong>actual</strong> time lies beyond the last state collected.</li>\n</ul>\n<p>Can we express this in Cypher?\nWell, it's not pretty, but it's possible<sup>*)</sup>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">MATCH (pd:PersonData)-[r]-(p) \nWHERE p.id = 665544 AND r.recorded &lt;= 30\nWITH { data: pd, recorded: r.recorded, actual: r.actual } as data\nWITH data ORDER BY data.recorded DESC\nWITH reduce(relevant = [], d in collect(data) | \nCASE \nWHEN last(relevant) IS NULL OR d.actual &lt; last(relevant).actual THEN relevant+d \nELSE relevant END) \nAS data\nUNWIND data AS final \nRETURN final.actual, final.data</code></pre></div>\n<p>Depending at which point in time you look at the state you now get two different\nhistories:</p>\n<p><img src=\"/assets/2DHistory4.png\"></p>\n<p>or</p>\n<p><img src=\"/assets/2DHistory5.png\"></p>\n<p>What the query does is to </p>\n<ul>\n<li>identify the immutable node we are interested in and establish the data\nwe will be considering</li>\n<li>order it descending based on the recorded time </li>\n<li><a href=\"http://neo4j.com/docs/developer-manual/current/cypher/functions/list/#functions-reduce\">reducing</a> the data, thereby rejecting those states that have been\ncancelled by subsequent state entries.</li>\n</ul>\n<p>As is often the case with graphs, there are quite a few ways you can go about storing data\nwith meaningful relationships. Other representations could be</p>\n<ul>\n<li>Putting the emphasis entering the queries purely through a point in time.\nIn this case you could try and construct a representation with the help of\na <a href=\"http://graphaware.com/neo4j/2014/08/20/graphaware-neo4j-timetree.html\">time tree</a>.</li>\n<li>Putting the emphasis on business transactions that summarize all\nstate changes contained in said transaction.</li>\n</ul>\n<p>As usual with graphs, think in advance the kind of questions\nyou will want to ask :)</p>\n<p>*)\n<em>Disclaimer: I am no cypher expert. The query expresses the logic outlined in the first blog post with some additional noise, some compaction may  still be possible.</em></p>","fields":{"slug":"/2017/01/27/2d-historization-in-a-graph-database"},"frontmatter":{"date":"January 27, 2017","path":null,"title":"2D-Historization in a graph database","tags":["patterns","programming","neo4j"]}}},"pageContext":{"title":"2D-Historization in a graph database","previous":{"fields":{"slug":"/2017/01/18/an-outsiders-guide-to-gerrymandering","published":true},"frontmatter":{"title":"An outsider's guide to gerrymandering","tags":["loosely-coupled","mathematics"],"date":"2017/01/18"}},"next":{"fields":{"slug":"/2017/01/30/simplify-the-bitemporal-neo4j-query-with-a-user-defined-function","published":true},"frontmatter":{"title":"Simplify the bitemporal Neo4J query with a user-defined function","tags":["programming","neo4j","java"],"date":"2017/01/30"}}}}