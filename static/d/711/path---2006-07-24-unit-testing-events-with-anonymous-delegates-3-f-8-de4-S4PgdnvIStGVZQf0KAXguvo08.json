{"data":{"markdownRemark":{"html":"<p>The other day I figured out that anonymous delegates can also help you to test an event while staying nicely contained within a single test method. </p>\n<p>The following is one of the unit tests of the FixedUndoStack class which you can find at my downloads section:</p>\n<pre><code>  [Test]\n  public void TestOnPopEvent() {\n\n  string stackElement = \"\";\n  int wasCalled = 0;\n\n  stack.OnPop += delegate(object o, OnPopEventArguments&#x3C;string> e) {\n    Assert.AreEqual(stackElement, e.Item);\n    wasCalled++;\n  };\n\n  stackElement = \"three\";\n  stack.Pop();\n  Assert.AreEqual(1,wasCalled);\n\n  stackElement = \"two\";\n  stack.Pop();\n  Assert.AreEqual(2, wasCalled);\n\n  stackElement = \"one\";\n  stack.Pop();\n  Assert.AreEqual(3, wasCalled);\n\n  // The next pop should not raise an event anymore\n  stackElement = \"asjhgdvb\"; \n  stack.Pop();\n  Assert.AreEqual(3, wasCalled);\n}\n</code></pre>\n<p>Since anonymous methods run in the context of the enclosing method, you can modify locals of the test function. </p>\n<p>The int wasCalled is used to check whether the event really fired, while the test needs to prepare any ensuing comparisons just before you expect the event.</p>","frontmatter":{"date":"July 24, 2006","path":null,"title":"Unit testing events with anonymous delegates","tags":["software-development","dotnet"]}}},"pageContext":{"title":"Unit testing events with anonymous delegates"}}