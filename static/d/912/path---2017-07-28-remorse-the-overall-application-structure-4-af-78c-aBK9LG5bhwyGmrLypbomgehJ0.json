{"data":{"markdownRemark":{"html":"<p>Before you look at remorse, you should consider learning about the basic building blocks of a redux application:</p>\n<ul>\n<li>View components : You will find that the view in this application is stateless. You notice that in the fact that all react components are written as functions, that is, they depend on their input and other stateless functions</li>\n<li>Reducer : They reduce an action, together with the the previous state, to a new state which describes the view</li>\n<li>Actions: Every change that the UI undergoes is triggered by some action in the application. </li>\n</ul>\n<p>In the context of remorse we have trivial actions, e.g.</p>\n<pre><code class=\"language-javascript\">forceStopTraining() {\n  clearInterval(timer);\n  return {\n    type: \"TRAINING_STOPPED\"\n  };\n}\n</code></pre>\n<p>or complex ones (see e.g. <code>evaluateUserInput</code> in <a href=\"https://github.com/flq/remorse/blob/master/src/Training/TrainingActions.js#L79\">Training/TrainingActions.js</a>).</p>\n<p>Let's have a look at the overall structure of <a href=\"http://realfiction.net/remorse\">remorse</a>:</p>\n<p><img src=\"/public/assets/remorse-dir-structure.png\" alt=\"dir tree remorse\"></p>\n<p>Generally speaking, code is separated by feature:</p>\n<ul>\n<li><strong>Typing</strong>: Here you type &#x26; listen morse code</li>\n<li><strong>TrainingData</strong>: Shows tables and charts with regard to your progress</li>\n<li><strong>Training</strong>: Contains the training screens, <strong>Reading</strong> and <strong>Writing</strong></li>\n</ul>\n<p>One of the decisions early on was to decide whether the reading and writing screen would be different or just the same code base. The pros / cons are obvious.</p>\n<ul>\n<li>Different: The screens can easily progress independently, the danger being more boilerplate code, duplication etc.</li>\n<li>Same: Less code, but extension points with regard to the differences need to be introduced, making the code a little bit more complex.</li>\n</ul>\n<p>Since the two screens are indeed very similar at this point in time, I decided for the latter, hence the Training folder with sub folders.</p>\n<p>This means that some items require specifics, which are bundled in the <strong>Reading/Writing specifics</strong> files. Let's have a look at one:</p>\n<pre><code class=\"language-javascript\">import createTrainingActions from \"../TrainingActions\";\n...\nconst Actions = createTrainingActions({\n  trainDataStorageKey: APP_READ_TRAINDATA_KEY,\n  nextLetterProvider,\n  inputFromKey,\n  expectedInputFromCurrentTrainingSet: morseCodeToChar\n});\nexport default Actions;\n</code></pre>\n<p><code>createTrainingActions</code> then creates a closure and the actions it returns become bound to the training specifics, e.g.</p>\n<pre><code class=\"language-javascript\">export default function createTrainingActions({\n  trainDataStorageKey,\n  ...\n}) {\n  ...\n  return {\n    saveTraining() {\n      ...\n      storeObject(trainDataStorageKey, trainingData);\n    }\n  }\n</code></pre>\n<p>The training view can now get training specific actions like such:</p>\n<pre><code class=\"language-javascript\">import TrainingScreen from \"../TrainingScreen\";\nimport Actions from \"./TrainingSpecifics\";\n\nconst WriteTraining = connect(function(s) {\n  return s.train.currentTraining || {};\n}, Actions)(TrainingScreen);\n</code></pre>\n<p>The features are tied back together in the <code>AppReducer</code>:</p>\n<pre><code class=\"language-javascript\">import { combineReducers } from \"redux\";\nimport train from \"./Training/TrainingReducer\";\nimport typing from \"./TypingScreen/TypingReducer\";\n\n\nconst appReducer = combineReducers({ typing, train });\nexport default appReducer;\n</code></pre>\n<p>Notice that there is no reducer for displaying the training data. This is because the training data screen runs independently of the redux infrastructure. This is because it is (sort of) legitimate to have the routing run independently of the redux application itself. Of course it depends on what you want to be able to do, but for this application there were no major drawbacks in doing so. So, since looking at training data is purely a readonly screen and any changes are just navigational changes, it runs without connected components (connected here means components wired up to the redux infrastructure).</p>\n<p>And finally, App.js ties the different features together:</p>\n<pre><code class=\"language-html\">&#x3C;BrowserRouter basename={process.env.REACT_APP_BASENAME}>\n    &#x3C;Provider store={store}>\n        &#x3C;div id=\"root\">\n        &#x3C;Navigation />\n        &#x3C;Route path=\"/typing\" component={TypingScreen} />\n        &#x3C;Route path=\"/test-writing-morse\" component={WritingScreen} />\n        &#x3C;Route path=\"/test-reading-morse\" component={ReadingScreen} />\n        &#x3C;Route path=\"/training-data\" component={TrainingDataScreen} />\n        &#x3C;/div>\n    &#x3C;/Provider>\n&#x3C;/BrowserRouter>\n</code></pre>","frontmatter":{"date":"July 28, 2017","path":null,"title":"remorse - the overall application structure","tags":["web","programming","react","javascript"]}}},"pageContext":{"title":"remorse - the overall application structure"}}