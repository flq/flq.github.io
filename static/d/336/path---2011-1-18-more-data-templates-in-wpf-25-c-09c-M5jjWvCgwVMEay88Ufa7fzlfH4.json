{"data":{"markdownRemark":{"html":"<p>Imagine you want to fill a toolbar through its ItemsSource and appropriate DataTemplates and not all commands are created equal. Some commands should be shown as Buttons, or ToggleButtons or whatever Visual tree you may come up with. In such a situation you can use a DataTemplateSelector. How to implement one (not exceedingly complicated) is <a href=\"http://www.switchonthecode.com/tutorials/wpf-tutorial-how-to-use-a-datatemplateselector\">described here</a>. Alas, it requires you to leave the realms of XAML. One idea is then to have a XAML-friendly template selector. The idea isn’t new, one implementation <a href=\"http://zhebrun.blogspot.com/2008/09/are-you-tired-to-create.html\">can be found here</a>. However I wanted something even simpler: A XAML-based template selector that is only driven by the DataType specified on the template. The API shown makes it possible to have the XAML look like this:</p>\n<pre><code>     &#x3C;ToolBar ItemsSource=\"{Binding Path=Control.Commands}\">\n        &#x3C;ToolBar.ItemTemplateSelector>\n            &#x3C;local:DataTemplateChoice>\n                &#x3C;DataTemplate DataType=\"{x:Type cmd:CommandA}\">\n                    &#x3C;Button Height=\"30\" Width=\"30\" Command=\"{Binding Command}\">\n                        &#x3C;Image Source=\"{Binding SymbolResourceName, \n                            Converter={StaticResource imgConv}}\" />\n                    &#x3C;/Button>\n                &#x3C;/DataTemplate>\n                &#x3C;DataTemplate DataType=\"{x:Type cmd:CommandB}\">\n                    &#x3C;ToggleButton Height=\"30\" Width=\"30\" \n                                    Command=\"{Binding Command}\" \n                                    IsChecked=\"{Binding IsActive, Mode=OneWayToSource}\">\n                        &#x3C;Image Source=\"{Binding SymbolResourceName, \n                            Converter={StaticResource imgConv}}\" />\n                    &#x3C;/ToggleButton>\n                &#x3C;/DataTemplate>\n                &#x3C;StaticResourceExtension ResourceKey=\"BasicCommandInfoDisplay\" />\n            &#x3C;/local:DataTemplateChoice>\n        &#x3C;/ToolBar.ItemTemplateSelector>\n    &#x3C;/ToolBar>\n</code></pre>\n<p>The DataTemplateChoice is a container for an unlimited number of DataTemplates. The implementation is rather simple:</p>\n<pre><code>    [ContentProperty(\"Templates\")]\n    public class DataTemplateChoice : DataTemplateSelector\n    {\n        public DataTemplateChoice()\n        {\n            Templates = new DataTemplates();\n        }\n\n        public DataTemplates Templates { get; private set; }\n\n        public override DataTemplate SelectTemplate(object item, DependencyObject container)\n        {\n            var dt = Templates.GetMatchFor(item.GetType());\n            return dt ?? base.SelectTemplate(item, container);\n        }\n    }\n</code></pre>\n<p>Rather important for comfort is the specification of the <em>ContentPropertyAttribute</em>. That way the XAML compiler knows which property to target per default, thereby allowing to write straight into the <em>DataTemplateChoice</em> and ensuring that the content ends up in the <em>Templates</em> property.</p>\n<p>Finally we need the <em>DataTemplates</em> class, which is pretty much just a list with a method to pick out a <em>DataTemplate</em>:</p>\n<pre><code>    public class DataTemplates : List&#x3C;DataTemplate>\n    {\n        internal DataTemplate GetMatchFor(Type objectType)\n        {\n            var dataTemplate = this.FirstOrDefault(t => MatchViaDataType(t, objectType));\n            return dataTemplate;\n        }\n\n        private static bool MatchViaDataType(DataTemplate arg, Type objectType)\n        {\n            var type = arg.DataType as Type;\n            return type != null &#x26;amp;&#x26;amp; type.IsAssignableFrom(objectType);\n        }\n    }\n</code></pre>\n<p>And that’s that! Make sure to specify the <em>DataType</em> on the DataTemplates you add. Via the StaticResourceExtension you can add DataTemplates specified elsewhere. The selection is similar to the catch blocks of a try: Move down from specific to more general. And finally, specifying an interface as DataType will work without problems due to usage of <em>IsAssignableFrom</em>.</p>\n<p><a href=\"http://dotnetshoutout.com/realfiction-More-DataTemplates-In-WPF\"><img src=\"http://dotnetshoutout.com/image.axd?url=http%3A%2F%2Frealfiction.net%2Fgo%2F198\" alt=\"Shout it\"></a></p>","frontmatter":{"date":"February 18, 2011","path":null,"title":"More. DataTemplates. In. WPF.","tags":["dotnet","libs-and-frameworks"]}}},"pageContext":{"title":"More. DataTemplates. In. WPF."}}