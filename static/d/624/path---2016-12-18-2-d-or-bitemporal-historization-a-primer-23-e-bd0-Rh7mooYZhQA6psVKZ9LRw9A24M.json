{"data":{"markdownRemark":{"html":"<h2>2D Historization series</h2>\n<ol>\n<li>2D or bitemporal Historization: A primer</li>\n<li><a href=\"/2017/01/26/2D-Historization-in-a-graph-database\">2D-Historization in a graph database</a></li>\n<li><a href=\"/2017/01/30/Simplifying-the-Neo4J-query-with-a-user-defined-function\">Simplify the bitemporal Neo4J query with a user-defined function</a></li>\n</ol>\n<p>When it comes to <strong>time</strong> &#x26; software systems, there are three major categories:</p>\n<h5>A system that needs no notion of time</h5>\n<p>A primitive filesystem manages what is contained right now. It does not care about what files you had one month ago, and it certainly wouldn't know what files you'll have in a month.</p>\n<h5>A system that contains historical data</h5>\n<p>More &#x26; more systems fall into that category. Whenever we interact with software that is interested in us as a <strong>customer</strong> or as a <strong>product</strong>, it will like to keep past information about us, not only to provide us with e.g. our order history, but to identify patterns within our interaction with software.</p>\n<h5>A system that allows past and future alterations</h5>\n<p>In a number of systems we need to define changes that will be happening in the future, as well as changes that are retrofitted to have happened in the past. Your boss may have decided three weeks ago that you will get more stash starting 2017. This may have already been recorded in the book-keeping software system of your choice. </p>\n<p>Sometimes you may be presented with new information about past events and you want to enter it into the system at the specified date. Martin Fowler <a href=\"http://martinfowler.com/eaaDev/timeNarrative.html\">has written about this</a> already. The <em>take away</em> of such systems is that we need to record two times for those system changes that we are interested in. Martin calls this the <strong>recorded</strong> and <strong>actual</strong> time. The <em>recorded</em> time is the time at which the new information enters the system. The <em>actual</em> time is the one that is relevant to the business modeled by the software.</p>\n<p>Such a system now allows us to record changes that occur in the future or in the past. The 2-dimensional nature of such a time point also allows us to ask questions like <em>\"How did the state look like one month ago?\"</em></p>\n<p>Let us reason about such 2D-time-modeling or bitemporal history of our domain with code:</p>\n<pre><code class=\"language-fsharp\">type TimePoint&#x3C;'S> = {\n    recorded : int;\n    actual : int;\n    state : 'S;\n}\n</code></pre>\n<p>Any state shall be contained with information when this state was recorded as well as when its validity starts. Often the actual state changes will have a granularity of <strong>days</strong>, while changes may occur multiple times in a day, forcing a higher granularity on the recorded field. We'll just use ints for now (think <em>Epoch</em>).</p>\n<p>When we make a query as to the state of the system we will need to specify for which point in time we want the answer. Hence, our historical data will only show states alongside their <strong>actual</strong> dates:</p>\n<pre><code class=\"language-fsharp\">type HistoryEntry&#x3C;'S> = {\n    time : int;\n    state : 'S;\n}\n\ntype History&#x3C;'S> = HistoryEntry&#x3C;'S> list\n</code></pre>\n<p>A situation where we successively store changes may look like that:</p>\n<pre><code class=\"language-fsharp\">let chain1 = [\n    { recorded = 1; actual = 1; state = \"First\" };\n    { recorded = 2; actual = 5; state = \"Second\" };\n    { recorded = 3; actual = 7; state = \"Third\" };\n]\n</code></pre>\n<p>Illustrating such data is typically done with 2 axes: </p>\n<p><img src=\"/public/assets/2DHistory1.png\"></p>\n<p>The dashed line shows our <em>\"projection\"</em> of the history, which is drawn below. Also noteworthy is the fact that we define states open-ended. This is because the end of some state may be different depending on the time at which you project your history. If you look at the above example with <code>date = 2</code>, State <strong>\"Second\"</strong> will have indefinite validity, while the shown projections ends it when <strong>\"Third\"</strong> is introduced. Indeed, the \"end\" of some state may typically be a business concern rather than something that needs to be forced upon the modeling of bitemporal history</p>\n<p>Let's solidify the way we can project History from our states with code. </p>\n<ol>\n<li>Given a point in time</li>\n<li>Go backwards from that point along the recorded axis</li>\n<li>Collect all relevant states.</li>\n</ol>\n<pre><code class=\"language-fsharp\">let recorded = 2 // the time at which we look at the state\nlet history = \n    chain1\n    |> List.sortByDescending (fun tp -> tp.recorded)\n    |> List.skipWhile (fun tp -> tp.recorded > recorded)\n    |> List.fold foldHistory []\n</code></pre>\n<p><code>foldHistory</code> collects all those states that need to be considered.</p>\n<pre><code class=\"language-fsharp\">let foldHistory&#x3C;'S> history timePoint = \n    let newPoint = fun () -> { time = timePoint.actual; state = timePoint.state }\n    match history with\n    | [] -> newPoint() :: history\n    | historyEntry::rest -> match (historyEntry, timePoint) with\n                        | MustBeConsidered -> newPoint() :: history\n                        | CanBeIgnored -> history\n</code></pre>\n<p>Given a certain condition, a new <code>HistoryEntry</code> <em>must be considered</em> and will be prepended to the list of already collected history entries. What is that condition? Consider the following state changes:</p>\n<pre><code class=\"language-fsharp\">let chain2 = [\n    { recorded = 1; actual = 1; state = \"First\" };\n    { recorded = 2; actual = 7; state = \"Second\" };\n    { recorded = 3; actual = 5; state = \"Third\" };\n]\n</code></pre>\n<p><img src=\"/public/assets/2DHistory2.png\"></p>\n<p>State <strong>\"Second\"</strong> is being superseded by a new state. In other words, depending at which point in time you look at the state of the system, State <strong>\"First\"</strong> is either followed by <strong>\"Second\"</strong> or <strong>\"Third\"</strong>.</p>\n<p>Hence <em>\"Collecting the relevant states\"</em> means that while we move backwards along the <strong>recorded</strong> axis, only those states whose <strong>actual</strong> value is smaller than the one of the previously collected state will be considered.</p>\n<pre><code class=\"language-fsharp\">let (|MustBeConsidered|CanBeIgnored|) (reference, newTime) = \n  if (newTime.actual &#x3C;= reference.time) then MustBeConsidered else CanBeIgnored\n</code></pre>\n<p>Performing such logic in code, in-memory may prohibit itself when some object undergoes hundreds or thousands of changes throughout its lifetime. Having to keep time as a 2-Dimensional record complicates matters a lot in terms of e.g. persistence. </p>\n<p>However, the logic behind it is fairly straightforward. </p>","frontmatter":{"date":"December 18, 2016","path":null,"title":"2D or bitemporal Historization: A primer","tags":["software-development","patterns","programming"]}}},"pageContext":{"title":"2D or bitemporal Historization: A primer"}}