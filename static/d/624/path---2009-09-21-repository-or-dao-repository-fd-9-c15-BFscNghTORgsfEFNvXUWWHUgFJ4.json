{"data":{"markdownRemark":{"html":"<p>Fine, fine, the title is a blatant copy from <a href=\"http://fabiomaulo.blogspot.com\">Fabio Maulo</a>'s equally titled <a href=\"http://fabiomaulo.blogspot.com/2009/09/repository-or-dao-repository.html\">blog post</a>.</p>\n<p>Then again, this was the direct inspiration for understanding how the data access should look like in the mini-Blog engine I am cooking up. I decided to implement a repository just like Fabio recommends (but doesn't follow himself if you watch the comments) and see how far it gets me while already pointing out some shortcomings and how to overcome them. </p>\n<p>The basic idea is to have a repository that looks like this: </p>\n <pre class=\"sh_csharp\">\npublic interface IRepository&lt;T&gt; : \n  ICollection&lt;T&gt;, IQueryable&lt;T&gt;\n</pre>\n<p>Fabio already showed us how to implement the queryable - by exposing the LINQ to NHibernate capabilities through your repository. LINQ to NH is available in a version 1.0 provider. It may not support all things that could be thought about when writing LINQ queries but so far it has not disappointed...here's a simple query from one of my tests...</p>\n<p>`\nvar repC = new Repository<Content>(factory);</p>\n<p>var result =\n(from content in repC\nwhere content.Comments.Any(cn => cn.CommenterName == \"Foo\")\nselect new { content.Id, content.Title }).ToArray();\n`</p>\n<p>Any code that uses a repository is ridiculously easy to unit test. Fleshing out a test repository means e.g. writing the following class:</p>\n<pre class=\"sh_csharp\">\npublic class TestRepository&lt;T&gt; : List&lt;T&gt;, IRepository&lt;T&gt;\n</pre>\n<p>which leaves you implementing the queryable interface. For this we have the extension method <em>AsQueryable</em>, e.g.:</p>\n<p><code class=\"language-text\">public Expression Expression\n{\n  get { return this.AsQueryable().Expression; }\n}</code></p>\n<p>What Fabio did not show was the implementation of the ICollection interface. Here's the signature of ICollection as a reminder:</p>\n<pre class=\"sh_csharp\">\npublic interface ICollection&lt;T&gt; : IEnumerable&lt;T&gt;, IEnumerable\n{\n  void Add(T item);\n  void Clear();\n  bool Contains(T item);\n  void CopyTo(T[] array, int arrayIndex);\n  bool Remove(T item);\n  int Count { get; }\n  bool IsReadOnly { get; }\n}\n</pre>\n<p>Hence, the <em>ICollection</em> gives you semantics to add and remove items from it and know the count. What it doesn't give you is List semantics which adds capabilities based on an index.</p>\n<p>Implementation of <em>ReadOnly</em> is pretty clear: <strong>return false</strong>. Implementation of <em>CopyTo</em> and <em>Clear</em> is also pretty straight forward in my implementation:</p>\n<p>`\npublic void Clear()\n{\nthrow new InvalidOperationException(\"Repository does not allow truncate\");\n}</p>\n<p>public void CopyTo(T[] array, int arrayIndex)\n{\nthrow new InvalidOperationException(\"An anachronistic remnant that is not implemented\");\n}\n`</p>\n<p><em>Add</em> maps pretty well to a Save operation, thus the implementation uses the Session's save. However, the Session's save has the nice notion of returning the Primary key that was given to the newly saved entity while <em>Add</em>'s return signature is <strong>void</strong>.</p>\n<p>Getting to know the Id is quite practical, if only to reference the same entity again in Unit Tests involving DB interaction. Therefore, the IRepository&#x3C;T> interface gets the following addition:</p>\n<p><code class=\"language-text\">new int Add(T item);</code></p>\n<p>Note that the generic type argument of Repository is restricted to my base class for persisted objects, <em>Entity</em>, which comes along with an <em>Id</em>-property of type int. Hence, it should be safe to limit myself to int as the primary key.</p>\n<p>As a result, the implementation looks as follows:</p>\n<p>`\npublic int Add(T item)\n{\nreturn (int)sessionFactory\n.GetCurrentSession().Save(item);\n}</p>\n<p>void ICollection<T>.Add(T item)\n{\nint i = Add(item);\n}\n`</p>\n<p>Making the <em>ICollection</em> implementation explicit makes the two <em>Add</em>s distinguishable for the compiler. Usually the <em>void Add</em> will be hidden and Add will return you with the id assigned to your object. If something depends purely on the ICollection interface, only the collection semantics will be available</p>\n<p>Implementing <em>Contains</em> is somewhat trickier - possibly a reason why NHibernate's LINQ Provider does not support LINQ's <em>Contains</em> method. Since you are looking p a dehydrated object on the DB, what does Contains mean when you enter the collection with a fresh instance? </p>\n<p>One possible answer would be to check whether the object passed in is associated with the current session...</p>\n<p><code class=\"language-text\">return sessionFactory.GetCurrentSession().Contains(item)</code></p>\n<p>I have opted for a simple Id-comparison - here <em>Contains</em> states whether an item is contained that has the same primary key as the one of the item passed in (remember that the type argument of the Repository is restricted to be an Entity):</p>\n<p><code class=\"language-text\">public virtual bool Contains(T item)\n{\n  //LINQNH does not do contains. \n  //Implement whether the Id exists in DB\n  return (from e in this \n          where e.Id == item.Id \n          select e.Id).Count() &gt; 0;\n}</code></p>\n<p><em>Remove</em> maps quite logically to a Delete:</p>\n<p><code class=\"language-text\">public bool Remove(T item)\n{\n  sessionFactory.GetCurrentSession().Delete(item);\n  return true;\n}</code></p>\n<p>This time NH's return value is void, while the Collection supposedly wants you to state whether a Remove did happen or not. In this simple implementation I do not want to bother.</p>\n<p>Finally we may return a <em>Count</em> which maps quite nicely to SQL's count:</p>\n<p><code class=\"language-text\">public int Count\n{\n  get { \n    return sessionFactory\n      .GetCurrentSession().Linq&lt;T&gt;().Count(); \n  }\n}</code></p>\n<p>As a final touch, simple retrieval by Id is not as simple as it should be. I include the following into the IRepository interface:</p>\n<p><code class=\"language-text\">T this[int id] { get; }</code></p>\n<p>With an equally brief implementation:</p>\n<p><code class=\"language-text\">public T this[int id]\n{\n  get\n  {\n    return sessionFactory\n      .GetCurrentSession().Get&lt;T&gt;(id);\n  }\n}</code></p>\n<p>There is the first version of a Repository that <em>mostly</em> acts like an in-memory collection of objects. It can be queried with LINQ and objects can be added or removed.</p>\n<p>Hang on...Mostly?</p>\n<p>Yes. It is still up to powers beyond the repository to ensure that e.g. in mutating operations the NHibernate Session that is used gets its stuff written to the DB. That is, it is the responsibility of repository users to ensure transactional security, flushing, etc.</p>\n<p>Remember those nasty Stored Procs written by demented people that would commit after doing some stuff, not caring about the bigger picture? Same applies here.</p>\n<p>For now it seems that the repository will cover a number of common DB needs for the targetted project - thanks goes to Fabio for the nice inspiration!</p>","frontmatter":{"date":"September 21, 2009","path":null,"title":"Repository or DAO?: Repository","tags":["programminf","libs-and-frameworks","csharp","patterns"]}}},"pageContext":{"title":"Repository or DAO?: Repository","previous":{"fields":{"slug":"/2009/08/08/intermezzo-xsl-2-0-on-net"},"frontmatter":{"title":"Intermezzo: XSL 2.0 on .NET","tags":["software-development","dotnet","tools"],"date":"2009/08/07"}},"next":{"fields":{"slug":"/2009/09/25/how-can-i-get-rid-of-this-goto"},"frontmatter":{"title":"How can I get rid of this goto?","tags":["software-development","csharp"],"date":"2009/09/24"}}}}