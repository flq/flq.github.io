{"data":{"markdownRemark":{"html":"<p>Can a WCF client call a WCF service and have the server call back with whatever? Oh, yes. Can you get an example how it's done? Indeed.</p>\n<p>Are these good examples? Well, you can get <a href=\"http://www.microsoft.com/downloads/thankyou.aspx?familyId=2611a6ff-fd2d-4f5b-a672-c002f1c09ccd&#x26;displayLang=en\">MS samples for WCF</a> (which in their entirety are really helpful) or <a href=\"http://dotnetaddict.dotnetdevelopersjournal.com/wcf_alarmclock.htm\">another blog post</a> on the subject. Don't get me wrong, they work, but in my humble opinion they have shortcomings.</p>\n<ul>\n<li>They have funny classes and interfaces generated by svcutil with some really horrid artefacts  <li>The interfaces are not shared among client &#x26; server which annoys my desire for harmony and DRYness, which should be followed even in an example (or, maybe, especially in an example). </li>\n</ul>\n<p>Anyway, here's my version, which is quite reduced to just the duplex stuff.</p>\n<h2>Common bits</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[ServiceContract(Namespace = &quot;rf.services&quot;, \n CallbackContract = typeof(IDataOutputCallback), \n SessionMode = SessionMode.Required)]\npublic interface IServerWithCallback\n{\n    [OperationContract(IsOneWay=true)]\n    void StartDataOutput();\n}</code></pre></div>\n<p>That's the Server interface which the client will use to talk to the server. Please note the _CallBackContract _property of the _ServiceContract _attribute. That's the interface that will have to be implemented by the client. The server will use it to call back.\n<code class=\"language-text\">public interface IDataOutputCallback { [OperationContract(IsOneWay = true)] void SendDataPacket(string data); }</code></p>\n<p>All this <em>IsOneWay</em> business is one way to avoid issues when you're calling back a client within the method that is being called by the client. The issues are described <a href=\"http://www.codeproject.com/KB/WCF/WCF_Duplex_UI_Threads.aspx\">here</a>.</p>\n<h2>Server</h2>\n<p>Of course we need an implementation of the service (d'oh): </p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class ServerWCallbackImpl : IServerWithCallback { \n  \n  public void StartDataOutput() { \n    IDataOutputCallback callback = OperationContext.Current.GetCallbackChannel&lt;IDataOutputCallback&gt;(); \n    for (int i = 0; i &amp;lt; 10; i++) { \n      Random r = new Random(); \n      int interval = r.Next(500,3000); \n      System.Threading.Thread.Sleep(interval); \n      callback.SendDataPacket(&quot;Packet &quot; + i.ToString()); \n    } \n    callback.SendDataPacket(&quot;Last packet is this one :)&quot;); \n  }\n\n}</code></pre></div>\n<p>The important line is the very first one. The rest is just a crappy example to get some funny callback side-effects. Next we have the configuration of the thing...</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;system.serviceModel&gt;\n  &lt;services&gt;\n    &lt;service name=&quot;ServerPart.ServerWCallbackImpl&quot;&gt;\n      &lt;endpoint address=&quot;net.tcp://localhost:9080/DataService&quot; binding=&quot;netTcpBinding&quot;\n          bindingConfiguration=&quot;&quot; name=&quot;DataEndpoint&quot; contract=&quot;CommonParts.IServerWithCallback&quot; /&gt;\n    &lt;/service&gt;\n  &lt;/services&gt;\n&lt;/system.serviceModel&gt;</code></pre></div>\n<p>And some boilerplate to get it running e.g. in a command-line:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">ServiceHost svc = new ServiceHost(typeof(ServerWCallbackImpl)); \nsvc.Open(); \nConsole.WriteLine(&quot;Listening according to configuration&quot;); \nConsole.ReadKey(); </code></pre></div>\n<p>If you want to save yourself the configuration etry in the app.config file, you can also set up the ServiceHost programmatically:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">ServiceHost duplex = new ServiceHost(typeof(ServerWCallbackImpl)); \nduplex.AddServiceEndpoint(typeof(IServerWithCallback), new NetTcpBinding(), &quot;net.tcp://localhost:9080/DataService&quot;); \nduplex.Open(); </code></pre></div>\n<h2>Client</h2>\n<p>Want to call the server? Well, first you could go and configure it:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;system.serviceModel&gt;\n    &lt;client&gt;\n      &lt;endpoint address=&quot;net.tcp://localhost:9080/DataService&quot; binding=&quot;netTcpBinding&quot;\n            bindingConfiguration=&quot;&quot; contract=&quot;CommonParts.IServerWithCallback&quot; name=&quot;Callback&quot;&gt;\n      &lt;/endpoint&gt;\n    &lt;/client&gt;\n&lt;/system.serviceModel&gt;</code></pre></div>\n<p>Then it'll make sense to provide an implementation of the Callback interface:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class CallbackImpl : IDataOutputCallback { \n\n  public void SendDataPacket(string data) { \n    Console.WriteLine(data); } #endregion \n  }</code></pre></div>\n<p>Brill! Finally the boilerplate to kickstart the thing:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">DuplexChannelFactory&lt;IServerWithCallback&gt; cf = \n  new DuplexChannelFactory&lt;IServerWithCallback&gt;( new CallbackImpl(), &quot;Callback&quot;); \nIServerWithCallback srv = cf.CreateChannel(); \nsrv.StartDataOutput(); </code></pre></div>\n<p>Again, if you prefer working without a configuration entry, you can set this up programmatically, too:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">DuplexChannelFactory&lt;IServerWithCallback&gt; cf = \n  new DuplexChannelFactory&lt;IServerWithCallback&gt;(\n  new CallbackImpl(), \n  new NetTcpBinding(), \n  new EndpointAddress(&quot;net.tcp://localhost:9080/DataService&quot;));</code></pre></div>\n<p>That's it, you shouldn't need more, honest, dude. No generated class in sight, all interfaces are the same throughout Client and Server. Distribute over projects/threads/app domains at your leisure and enjoy.</p>\n<p><strong>Update</strong>: <a href=\"/public/assets/RF.WCF.Callback.zip\">Here is a small vs2008 solution</a> that shows the programmatic setup of this blog post.</p>","frontmatter":{"date":"January 30, 2008","path":null,"title":"The no frills, bare-bones example to Duplex WCF","tags":["download","dotnet","libs-and-frameworks"]}}},"pageContext":{"title":"The no frills, bare-bones example to Duplex WCF"}}