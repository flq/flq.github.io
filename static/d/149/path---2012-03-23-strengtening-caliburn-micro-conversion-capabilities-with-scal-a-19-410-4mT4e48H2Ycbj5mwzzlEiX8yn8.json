{"data":{"markdownRemark":{"html":"<p>If one looks into how <a href=\"http://caliburnmicro.codeplex.com/\">Caliburn.Micro</a> performs binding between models and views, a number of methods must be considered that play a role.</p>\n<ul>\n<li>Conventions play a role how bindings are derived from naming and involved elements</li>\n<li>VM getter / setter situation plays a role about the supported Binding directions</li>\n<li>Does the VM implement anything Validation-specific?</li>\n<li>Is there a type mismatch between the binding source and target? (classic example: Boolean -> Visibility)</li>\n</ul>\n<p>Especially for the last one Scal introduces a configuration hook to provide your own Value Converters. Check out the usage in the sample application:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Converters.ApplyDefaults();\n...\npublic static ConverterConfiguration ApplyDefaults(this ConverterConfiguration config)\n{\n    config\n        .Add&lt;bool, Visibility, BooleanToVisibilityConverter&gt;()\n        .Add&lt;string, ImageSource, PathToImageSourceConverter&gt;();\n    return config;\n}</code></pre></div>\n<p>This is supported by replacing a certain method deep in the bowels of <a href=\"https://github.com/flq/scal\">Scal</a>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">public class ValueConverterManagement\n{\n    private readonly Dictionary&lt;Tuple&lt;Type, Type&gt;, IValueConverter&gt; _converters;\n\n    public ValueConverterManagement(AppModel model)\n    {\n        ConventionManager.ApplyValueConverter = ApplyConverter;\n        _converters =  model.Converters.ToDictionary(k =&gt; Tuple.Create(k.Item1, k.Item2), v =&gt; v.Item3);\n    }\n\n    private void ApplyConverter(Binding binding, DependencyProperty dProp, PropertyInfo vmProp)\n    {\n        var t = Tuple.Create(vmProp.PropertyType, dProp.PropertyType);\n        _converters.Get(t).Do(v =&gt; binding.Converter = v);\n    }\n}</code></pre></div>\n<p>The <strong>ConventionManager</strong> is a Caliburn.Micro class that (<em>through the CM-typical override mechanism of replacing static Func-fields</em>) provides a hook into the binding operations. The key to a value converter is the pair of bound ViewModel-Type to the target UIElement type.</p>\n<p>An additional way to leverage Caliburn.Micro's Binding routine is through the <strong>ScalBinding</strong> markup extension:</p>\n<p><code class=\"language-text\">&lt;TextBlock x:Name=&quot;Hello&quot; Visibility=&quot;{svc:ScalBinding IsVisible}&quot;&gt;&lt;/TextBlock&gt;</code></p>\n<p>This markup extension will call into the relevant CM Binding-related methods beyond those that deal with the Convention-based binding. That way, the binding shown above will use Scal's knowledge of known value converters to map the <strong>Visibility</strong> property to the <strong>IsVisible</strong> bool.</p>","frontmatter":{"date":"March 23, 2012","path":null,"title":"Strengtening Caliburn.Micro conversion capabilities with Scal","tags":["software-development","dotnet","libs-and-frameworks"]}}},"pageContext":{"title":"Strengtening Caliburn.Micro conversion capabilities with Scal","previous":{"fields":{"slug":"/2012/03/22/membus-v2-news"},"frontmatter":{"title":"membus v2 news","tags":["software-development","dotnet","membus"],"date":"2012/03/22"}},"next":{"fields":{"slug":"/2013/02/26/objectivity-does-not-exist"},"frontmatter":{"title":"Objectivity does not exist","tags":["physics","loosely-coupled"],"date":"2013/02/26"}}}}