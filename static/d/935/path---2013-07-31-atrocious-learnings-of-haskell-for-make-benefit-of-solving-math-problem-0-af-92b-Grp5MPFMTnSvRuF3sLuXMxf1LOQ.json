{"data":{"markdownRemark":{"html":"<p>Monday evening's <em>original</em> plan was to read up on <a href=\"http://www.haskell.org/haskellwiki/Applications_and_libraries/Concurrency_and_parallelism\">Concurrency stuff</a> in Haskell. Alas, the site was down. My focus shifted towards twitter and then to this tweet:</p>\n<blockquote class=\"twitter-tweet\"><p><a href=\"https://twitter.com/search?q=%23Ruby&amp;src=hash\">#Ruby</a> or <a href=\"https://twitter.com/search?q=%23Python&amp;src=hash\">#Python</a>? If I could learn only one, which one would it be? <a href=\"https://twitter.com/search?q=%23twestion&amp;src=hash\">#twestion</a></p>&mdash; Dennis Traub (@DTraub) <a href=\"https://twitter.com/DTraub/statuses/361919012088709120\">July 29, 2013</a></blockquote>\n<script async src=\"//platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n<p>So I did a Google Search on ruby vs. python and stumbled across <a href=\"http://danvk.org/josephus.html\">The Josephus problem, implemented in Perl, ruby and Python</a>.</p>\n<p>The Josephus problem is also <a href=\"http://en.wikipedia.org/wiki/Josephus_problem\">described in wikipedia (WP)</a> and boils down to a mathematical problem of permutation. If you don't feel like following the links, here's a short definition taken from WP:</p>\n<blockquote>\n<p>There are people standing in a circle waiting to be executed. The counting out\nbegins at some point in the circle and proceeds around the circle in a fixed\ndirection. In each step, a certain number of people are skipped and the next person\nis executed.\nThe elimination proceeds around the circle\n(which is becoming smaller and smaller as the executed people are removed),\nuntil only the last person\nremains, who is given freedom.</p>\n</blockquote>\n<h3>Challenge accepted</h3>\n<p>The following gist contains my attempt at finding a Haskell-based solution, followed by an implementation as found on the aforementioned Wikipedia-article.</p>\n<script src=\"https://gist.github.com/flq/6112258.js\"></script>\n<p>As you can see, my solution is basically <em>atrocious</em>. It works, but it is wordy and has some troubles regarding getting the next person in line. To my defence, it was late Monday evening, and my first attempts did look somewhat similar to the clean solution, but I didn't manage the final leap.</p>\n<p>What the shown solution does is <strong>providing a function that, through <em>unfolding</em> generates a list of survivors until the list of dead people has grown to the original total of people minus 1 - the remaining survivor must be the final one</strong></p>\n<p>Compare that to the solution provided from <strong>line 32</strong> onwards. The key to the understanding is the function\n\nkillnext :: Int -> [a] -> [a]\nkillnext k people = take (length people - 1) (drop k (cycle people))</p>\n<p>let's try it with k = 4 and 5 people...</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">k = 3\npeople = [1,2,3,4,5]\ntake 4 (drop 3 (cycle [1,2,3,4,5])) =&gt; \ntake 4 [4,5,1,2,3,...] \t=&gt;\n[4,5,1,2]</code></pre></div>\n<p>So, in the next run, it gets called with the list of people that were obtained through the previous run:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">k = 3\npeople = [4,5,1,2]\ntake 3 (drop 3 (cycle [4,5,1,2])) =&gt; \ntake 3 [2,4,5,1...] \t=&gt;\n[2,4,5]</code></pre></div>\n<p>Still 3 guys left...another go!</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">take 2 (drop 3 (cycle [2,4,5])) =&gt; \ntake 2 [2,4,5,2,4,...]\n[2,4]</code></pre></div>\n<p>Phew, almost there...</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">take 1 (drop 3 (cycle [2,4])) =&gt; \ntake 1 [4,4,4,4,4,...]\n[4]</code></pre></div>\n<p>Finally the breaking condition of the recursion kicks in and <strong>head [4] => 4</strong>. Did our manual solving go correctly?</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">*Josephus Data.List&gt; lastSurvivor 5\n4\n*Josephus Data.List&gt; josephus 5 3\n4</code></pre></div>\n<p>Hence, we have <strong>4 lines of code</strong> to solve the Josephus problem of which one line takes some work to be understood.</p>\n<p>Trying to program in a functional language means that whatever experience you have in an <em>imperative language</em> (yes, C# is an imperative language) will only get you so far. Effective functional programming must be learned as much as any other form of programming. While I still don't have a systematic approach to solving a problem functionally, the process already feels quite different. </p>\n<p>In C# I lay out a structure of things that will collaborate towards a goal, a process which helps you and your brain drag along, happily converging towards a solution. Every line of code in a functional solution seems to require more effort, as it appears to convey more behaviour.</p>\n<p>The next time I think I will try some testing framework in Haskell and see if I can also manage a piecewise approach towards a solution functionally. </p>","frontmatter":{"date":"July 30, 2013","path":null,"title":"Atrocious Learnings of Haskell for Make Benefit of solving Math Problem","tags":["software-development","haskell"]}}},"pageContext":{"title":"Atrocious Learnings of Haskell for Make Benefit of solving Math Problem","previous":{"fields":{"slug":"/2013/07/26/exploring-haskells-type-system-a-roman-number-type"},"frontmatter":{"title":"Exploring Haskell's type system - A Roman number type","tags":["software-development","haskell"],"date":"2013/07/26"}},"next":{"fields":{"slug":"/2013/08/05/combat-fatty-wpf-vms-controller"},"frontmatter":{"title":"Combat fatty WPF VMs - Controller","tags":["dotnet","libs-and-frameworks"],"date":"2013/08/05"}}}}