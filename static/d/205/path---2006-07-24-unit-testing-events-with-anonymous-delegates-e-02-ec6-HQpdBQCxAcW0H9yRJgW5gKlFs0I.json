{"data":{"markdownRemark":{"html":"<p>The other day I figured out that anonymous delegates can also help you to test an event while staying nicely contained within a single test method. </p>\n<p>The following is one of the unit tests of the FixedUndoStack class which you can find at my downloads section:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">  [Test]\n  public void TestOnPopEvent() {\n\n  string stackElement = &quot;&quot;;\n  int wasCalled = 0;\n\n  stack.OnPop += delegate(object o, OnPopEventArguments&lt;string&gt; e) {\n    Assert.AreEqual(stackElement, e.Item);\n    wasCalled++;\n  };\n\n  stackElement = &quot;three&quot;;\n  stack.Pop();\n  Assert.AreEqual(1,wasCalled);\n\n  stackElement = &quot;two&quot;;\n  stack.Pop();\n  Assert.AreEqual(2, wasCalled);\n\n  stackElement = &quot;one&quot;;\n  stack.Pop();\n  Assert.AreEqual(3, wasCalled);\n\n  // The next pop should not raise an event anymore\n  stackElement = &quot;asjhgdvb&quot;; \n  stack.Pop();\n  Assert.AreEqual(3, wasCalled);\n}</code></pre></div>\n<p>Since anonymous methods run in the context of the enclosing method, you can modify locals of the test function. </p>\n<p>The int wasCalled is used to check whether the event really fired, while the test needs to prepare any ensuing comparisons just before you expect the event.</p>","frontmatter":{"date":"July 24, 2006","path":null,"title":"Unit testing events with anonymous delegates","tags":["software-development","dotnet"]}}},"pageContext":{"title":"Unit testing events with anonymous delegates"}}