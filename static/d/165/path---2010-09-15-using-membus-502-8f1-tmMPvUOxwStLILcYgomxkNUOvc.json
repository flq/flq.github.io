{"data":{"markdownRemark":{"html":"<p>Usage of MemBus always goes through the IBus interface:</p>\n<pre><code>public interface IBus : IDisposable\n{\n    void Publish(object message);\n    IDisposable Subscribe&#x3C;M>(Action&#x3C;M> subscription);\n    IDisposable Subscribe&#x3C;M>(Action&#x3C;M> subscription, ISubscriptionShaper customization);\n    IDisposable Subscribe&#x3C;M>(Action&#x3C;M> subscription, Action&#x3C;ISubscriptionCustomizer&#x3C;M>> customization);\n    IObservable&#x3C;M> Observe&#x3C;M>();\n}\n</code></pre>\n<p>Whenever you want to...well...publish a message, you use the Publish method. It will accept an instance of anything.</p>\n<p>Subscribing is a more open thing. Note that the IBus interface helps in subscribing through a method. There is also the possibility of registering Handlers, i.e. instances whose purpose is to handle messages of a certain type. This will be the subject of another post.</p>\n<p>The standard subscription takes a method, returning an IDisposable. Please note that MemBus by default follows the pattern that we will see in the future by IObservable implementations – When you dispose the returned object it is ensured that your subscription is removed from MemBus. I have planned in the future a weak-reference based alternative that will allow you to forget about subscriptions, but for now it is the responsibility of the subscriber to remove subscriptions:</p>\n<pre><code>var d = bus.Subscribe&#x3C;MessageA>(msg => received++);\nbus.Publish(new MessageA());\nreceived.ShouldBeEqualTo(1);\nd.Dispose();\nbus.Publish(new MessageA());\nreceived.ShouldBeEqualTo(1);\n</code></pre>\n<p>The other overloads are variations of subscribing. The overload with the subscription customizer will allow you to change the rules by which you get messages. So far it will allow you to do filtering and to specify that a call on your subscription happens on the dispatcher thread, which makes it useful for UI operations.</p>\n<p>The lines </p>\n<pre><code>bus.Subscribe&#x3C;MessageB>(subscription, c=>c.SetFilter(msg=>msg.Id == \"A\"));\nbus.Subscribe&#x3C;MessageB>(subscription, c => c.DispatchOnUiThread());\n</code></pre>\n<p>show you the syntax.</p>\n<p>More about the ISubscriptionShaper overload when talking about the extension points of MemBus.</p>\n<p>The Observe method opens to you the new and wonderful world of the <a href=\"http://msdn.microsoft.com/en-us/devlabs/ee794896.aspx\">reactive framework</a>. It returns to you an Observable from which you obtain push-based notification of incoming instances of the desired type. Here’s a small example of using the filtering capabilities:</p>\n<pre><code>var messages = \n    from msg in bus.Observe&#x3C;MessageA>() \n    where msg.Name == \"A\" \n    select msg;\n\nusing (messages.Subscribe(msg => msgCount++))\n{\n    bus.Publish(new MessageA {Name = \"A\"});\n    bus.Publish(new MessageA {Name = \"B\"});\n    bus.Publish(new MessageA {Name = \"A\"});\n    msgCount.ShouldBeEqualTo(2);\n}\n</code></pre>","frontmatter":{"date":"September 15, 2010","path":null,"title":"Using MemBus","tags":["patterns","csharp","membus"]}}},"pageContext":{"title":"Using MemBus"}}