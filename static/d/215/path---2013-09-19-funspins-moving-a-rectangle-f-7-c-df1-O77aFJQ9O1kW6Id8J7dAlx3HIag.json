{"data":{"markdownRemark":{"html":"<h2>Functional space-invaders series</h2>\n<ol>\n<li><a href=\"/2013/09/17/FunSpIns-a-recap-of-Rob-Ashtons-lessons-Das-Intro\">A recap of Rob Ashton's lessons - Das Intro</a></li>\n<li><a href=\"/2013/09/18/FunSpIns-Drawing-a-Rectangle\">Drawing a Rectangle</a></li>\n<li>Moving a Rectangle</li>\n<li><a href=\"/2013/09/20/FunSpIns-No-attributes-No-vectors-A-tiny-Workflow-and-more-squares\">No attributes, No vectors, A tiny Workflow and more squares</a></li>\n<li><a href=\"%7B%25%20post_url%202013-9-23-FunSpIns-State-the-World-the-Loop%20%25%7D\">State, the World, the Loop</a></li>\n<li><a href=\"%7B%25%20post_url%202013-9-24-FunSpIns-The-hero-must-move-the-enemies-must-move-smarter%20%25%7D\">The hero must move, the enemies must move smarter</a></li>\n<li><a href=\"%7B%25%20post_url%202013-9-25-FunSpIns-The-hero-shoots%20%25%7D\">The hero shoots</a></li>\n<li><a href=\"%7B%25%20post_url%202013-9-26-FunSpIns-Collisions-the-dead-and-a-not-so-grateful-ending%20%25%7D\">Collisions, the dead, and a (not so) grateful ending</a></li>\n</ol>\n<blockquote>\n<p>Inspired by Rob Ashton's series \"<a href=\"http://codeofrob.com/entries/learn-functional-programming-with-me---moving-the-square.html\">Learn functional programming with me</a>\"\nLast time a square got drawn, this time moving it would be nice. Rob's approach was based on a recursive function call,\none of the basic tools in FP to essentially do loops.</p>\n</blockquote>\n<p>Another way to consider the movement would be to look at it as a list of numbers, or coordinates, that dictate at which position\nthe rectangle should be drawn. One weapon of choice in Haskell for sequences of things are <a href=\"http://learnyouahaskell.com/starting-out#im-a-list-comprehension\">list comprehensions</a>.</p>\n<blockquote>\n<p>Incidentally I learned about list comprehensions in Erlang, which look very similar to Haskell's </p>\n</blockquote>\n<p>Hence, from a given sequence I would create Rectangles that were ready to be drawn onto a screen:</p>\n<pre><code>[(Just (Rect x 25 50 50)) | x &#x3C;- [1..450]]\n</code></pre>\n<p>and for each one of those I would want to draw it on the screen, hence I prepared myself this function:</p>\n<pre><code>fillDo canvas rect = do \n FX.fillRect canvas Nothing (Pixel 0)\n FX.fillRect canvas rect (Pixel 0xFFFFFF)\n FX.flip canvas\n</code></pre>\n<h2>The do-notation</h2>\n<p>all SDL operations happen in the IO monad, which can be seen nicely when we look at the type of the involved functions:</p>\n<pre><code>FX.fillRect :: Surface -> Maybe Rect -> Pixel -> IO Bool\nFX.flip :: Surface -> IO ()\n</code></pre>\n<p>If we want to work with them, we will need to work in that context ourselves. Haskell has a number of functions to work with Monads, one of them being <strong>(>>)</strong>. Its type is</p>\n<pre><code>(>>) :: Monad m => m a -> m b -> m b\n</code></pre>\n<p><sup>*) Within the same monad, given a one-in, one-out function, return the output of the function</sup> </p>\n<p>It looks and sounds trivial, but actually allows to chain functions together that happen in the same context. i.e. something like</p>\n<pre><code>-- putStr :: String -> IO ()\nputStr \"Hello\" >> \nputStr \" \"\n--becomes\ndo\n  putStr \"Hello\"\n  putStr \" \"\n</code></pre>\n<h2>List + fillDo = ...</h2>\n<p>My initial attempt was to take my list of Rectangles and map the fillDo over it:</p>\n<pre><code>map (fillDo canvas) [(Just (Rect x 25 50 50)) | x &#x3C;- [1..450]]\n</code></pre>\n<p>Note the use of currying - (fillDo canvas) returns a function that takes a rect as a parameter and returns <strong>IO ()</strong>.</p>\n<p>Alas, it wouldn't compile. After some thinking and googling, the issue dawned on me: every function inside a do block\nmust return into the same context with which we started off. Alas, the last line of code did not return an <strong>IO sth</strong>, but\nrather <strong>[IO sth]</strong>, an array of things in the IO context. What I wanted was actually <strong>IO [sth]</strong>.</p>\n<blockquote>\n<p>Once you get the hang out of it, Haskell errors can be quite understandable. This one was...</p>\n</blockquote>\n<pre><code>Couldn't match expected type `IO a0' with actual type `[b0]'\nIn the return type of a call of `map'\nIn a stmt of a 'do' block:\n...\n</code></pre>\n<p>Thankfully there is a version of <strong>map</strong> with the kind of signature that we need:</p>\n<pre><code>mapM :: Monad m => (a -> m b) -> [a] -> m [b]\n</code></pre>\n<p><sup>*) Given a function taking a's and returning b's within m and an array of a's, give me the resulting array of b's, within the m context</sup></p>\n<p>Bingo, small change and here's the full program:</p>\n<pre><code>module Main where\n\n  import Graphics.UI.SDL as FX\n\n  main :: IO ()\n  main = do\n    init\n    canvas &#x3C;- FX.getVideoSurface\n    mapM (fillDo canvas) [Rect x 25 50 50 | x &#x3C;- [1..450]]\n    delay 1000\n    FX.quit\n    where\n      fillDo canvas rect = do \n        FX.fillRect canvas Nothing (Pixel 0)\n        FX.fillRect canvas (Just rect) (Pixel 0xFFFFFF)\n        FX.flip canvas\n      init = do\n        FX.init [InitVideo]\n        FX.setVideoMode 640 480 32 []\n</code></pre>\n<p>So far I do not want to go full steam ahead and implement the <strong>logic/render/repeat</strong> thing, since, to be honest, I don't quite see where this is heading. Even so,  there is some potential looming for separating logic from rendering as the production of the rectangle <em>\"path\"</em> can be looked at independent of <em>IO</em>. </p>\n<h3>PS</h3>\n<p>we saved ourselves the \"white smear\" stage by adding that canvas cleaning code in the <strong>fillDo</strong> (<em>FX.fillRect canvas Nothing (Pixel 0)</em>)</p>","frontmatter":{"date":"September 19, 2013","path":null,"title":"FunSpIns - Moving a Rectangle","tags":["software-development","haskell","fun-spin"]}}},"pageContext":{"title":"FunSpIns - Moving a Rectangle"}}