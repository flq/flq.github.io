{"data":{"markdownRemark":{"html":"<p>My last post on primitive obsession has been <a href=\"/2015/12/30/NMeasure-and-the-global-warming\">a while ago</a>, whose predecessor is [even older][2].</p>\n<p>Primitives are still bad. The following illustrative code just happened to me two days ago (it didn't reach production, but hey):</p>\n<pre><code class=\"language-csharp\">public class Program\n{\n    public static string UserId => \"u-123\";\n    public static string ProductId => \"p-abc\";\n    \n    public static void Order(string userId, string productId)\n        => System.Console.WriteLine($\"User {userId} ordered {productId}\");\n    \n    public static void Main() => Order(ProductId, UserId);\n}\n</code></pre>\n<p>See the problem? Because we are the dealing with ids as strings, the compiler can't help us when we use APIs the wrong way. When you use the API correctly in unit tests it so can happen that confusing such IDs may only turn up in integration or, as the <em>very last resort</em>, production.</p>\n<p>The same mistake can happen to us in other languages, too. Here's the example in F#:</p>\n<pre><code class=\"language-fsharp\">let getUserId = \"u-123\"\nlet getProductId = \"p-ABC\"\n\nlet order userId productId = \n    printfn \"user %s orders %s\" userId productId\n\n[&#x3C;EntryPoint>]\nlet main argv =\n    order getProductId getUserId\n    0\n</code></pre>\n<p>The compiler happily does its job, no surprises. Obviously I chose F# as second example for a reason. Here, the barrier to type even singular primitives to provide improved compile time safety is considerably lower. Enter [<strong>Discriminated Unions</strong>][3].</p>\n<p>They are something like the crack of type-safe pattern matching, or state representations on steroids or whatever you like to call them. Let's use them in our example:</p>\n<pre><code class=\"language-fsharp\">type UserId = UserId of string\ntype ProductId = ProductId of string\n\nlet getUserId = UserId \"u-123\"\nlet getProductId = ProductId \"p-ABC\"\n\nlet order (UserId userId) (ProductId productId) =\n    printfn \"user %s orders %s\" userId productId\n\n[&#x3C;EntryPoint>]\nlet main argv =\n    order getUserId getProductId\n    0\n</code></pre>\n<p>In this case the <code>userId</code> and <code>productId</code>are still essentially strings, but you can only get at them by acknowledging the type that is guarding those primitive values. It is hard to conceive and even smaller encoding of semantics with regard to some primitive value, which is why I highly approve of this use case of discriminated unions and often miss them in C#.</p>\n<p>[2]: {% post_url 2010-11-30-Dealing-with-primitive-obsession-this-time-Measurements %}\n[3]: <a href=\"https://fsharpforfunandprofit.com/posts/discriminated-unions/\">https://fsharpforfunandprofit.com/posts/discriminated-unions/</a></p>","frontmatter":{"date":"June 23, 2018","path":null,"title":"Primitive Confusion","tags":["programming","fsharp","csharp"]}}},"pageContext":{"title":"Primitive Confusion"}}