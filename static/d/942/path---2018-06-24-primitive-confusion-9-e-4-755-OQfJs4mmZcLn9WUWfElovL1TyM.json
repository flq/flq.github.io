{"data":{"markdownRemark":{"html":"<p>My last post on primitive obsession has been <a href=\"/2015/12/30/NMeasure-and-the-global-warming\">a while ago</a>, whose predecessor is <a href=\"/dealing-with-primitive-obsession-this-time-measurements\">even older</a>.</p>\n<p>Primitives are still bad. The following illustrative code just happened to me two days ago (it didn't reach production, but hey):</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre class=\"language-csharp\"><code class=\"language-csharp\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Program</span>\n<span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">string</span> UserId <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token string\">\"u-123\"</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">string</span> ProductId <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token string\">\"p-abc\"</span><span class=\"token punctuation\">;</span>\n\t\n\t<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">Order</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">string</span> userId<span class=\"token punctuation\">,</span> <span class=\"token keyword\">string</span> productId<span class=\"token punctuation\">)</span>\n\t\t<span class=\"token operator\">=</span><span class=\"token operator\">></span> System<span class=\"token punctuation\">.</span>Console<span class=\"token punctuation\">.</span><span class=\"token function\">WriteLine</span><span class=\"token punctuation\">(</span>$<span class=\"token string\">\"User {userId} ordered {productId}\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\n\t<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">Main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token function\">Order</span><span class=\"token punctuation\">(</span>ProductId<span class=\"token punctuation\">,</span> UserId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>See the problem? Because we are the dealing with ids as strings, the compiler can't help us when we use APIs the wrong way. When you use the API correctly in unit tests it so can happen that confusing such IDs may only turn up in integration or, as the <em>very last resort</em>, production.</p>\n<p>The same mistake can happen to us in other languages, too. Here's the example in F#:</p>\n<div class=\"gatsby-highlight\" data-language=\"fsharp\"><pre class=\"language-fsharp\"><code class=\"language-fsharp\"><span class=\"token keyword\">let</span> getUserId <span class=\"token operator\">=</span> <span class=\"token string\">\"u-123\"</span>\n<span class=\"token keyword\">let</span> getProductId <span class=\"token operator\">=</span> <span class=\"token string\">\"p-ABC\"</span>\n\n<span class=\"token keyword\">let</span> order userId productId <span class=\"token operator\">=</span> \n    printfn <span class=\"token string\">\"user %s orders %s\"</span> userId productId\n\n<span class=\"token punctuation\">[</span><span class=\"token operator\">&lt;</span>EntryPoint<span class=\"token operator\">></span><span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">let</span> main argv <span class=\"token operator\">=</span>\n    order getProductId getUserId\n    <span class=\"token number\">0</span></code></pre></div>\n<p>The compiler happily does its job, no surprises. Obviously I chose F# as second example for a reason. Here, the barrier to type even singular primitives to provide improved compile time safety is considerably lower. Enter <a href=\"https://fsharpforfunandprofit.com/posts/discriminated-unions/\"><strong>Discriminated Unions</strong></a>.</p>\n<p>They are something like the crack of type-safe pattern matching, or state representations on steroids or whatever you like to call them. Let's use them in our example:</p>\n<div class=\"gatsby-highlight\" data-language=\"fsharp\"><pre class=\"language-fsharp\"><code class=\"language-fsharp\"><span class=\"token keyword\">type</span> UserId <span class=\"token operator\">=</span> UserId <span class=\"token keyword\">of</span> string\n<span class=\"token keyword\">type</span> ProductId <span class=\"token operator\">=</span> ProductId <span class=\"token keyword\">of</span> string\n\n<span class=\"token keyword\">let</span> getUserId <span class=\"token operator\">=</span> UserId <span class=\"token string\">\"u-123\"</span>\n<span class=\"token keyword\">let</span> getProductId <span class=\"token operator\">=</span> ProductId <span class=\"token string\">\"p-ABC\"</span>\n\n<span class=\"token keyword\">let</span> order <span class=\"token punctuation\">(</span>UserId userId<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>ProductId productId<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span>\n    printfn <span class=\"token string\">\"user %s orders %s\"</span> userId productId\n\n<span class=\"token punctuation\">[</span><span class=\"token operator\">&lt;</span>EntryPoint<span class=\"token operator\">></span><span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">let</span> main argv <span class=\"token operator\">=</span>\n    order getUserId getProductId\n    <span class=\"token number\">0</span></code></pre></div>\n<p>In this case the <code class=\"language-text\">userId</code> and <code class=\"language-text\">productId</code>are still essentially strings, but you can only get at them by acknowledging the type that is guarding those primitive values. It is hard to conceive and even smaller encoding of semantics with regard to some primitive value, which is why I highly approve of this use case of discriminated unions and often miss them in C#.</p>","frontmatter":{"date":"June 23, 2018","path":null,"title":"Primitive Confusion","tags":["programming","fsharp","csharp"]}}},"pageContext":{"title":"Primitive Confusion"}}