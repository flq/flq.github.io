{"data":{"markdownRemark":{"html":"<p>In one of our current objects we are using WCF as Client-Server communication. Contracts and endpoints are easily defined: We are using a common interface assembly from which the contracts are derived and setting the endpoint URLs is a matter of providing an address root. Currently the ABC of WCF is set up programmatically: The targetted architecture allowed it and it ensures a set up of WCF clients and servers with a minimum of configuration.</p>\n<p>Where shortcomings in a programmatic, low-config approach have come up is in the binding configuration: It defines the transport mechanisms and things like maximum message sizes, receive and send timeouts and the like - Things that are likely to change between a test, development and production system. In WCF examples out there you will usually see an all-or-nothing approach when it comes to configuration. Set up addresses, contracts, bindings, behaviours, etc.</p>\n<p>However, the following code will allow you to obtain bindings configuration from the config file while setting up the rest programmatically:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">public static class BindingFactory\n{\n    public static Binding GetFromConfig(string configurationName)\n    {\n        var bingingsSection = BindingsSection.GetSection(ConfigurationManager\n          .OpenExeConfiguration(ConfigurationUserLevel.None));\n        var bindingType = (from b in bingingsSection.BindingCollections\n                        where b.ConfiguredBindings.Count &gt; 0 &amp;&amp; b.ContainsKey(configurationName)\n                        select b.BindingType).FirstOrDefault();\n        var binding = bindingType != null ? \n          Activator.CreateInstance(bindingType, configurationName) : \n          null;\n        return (Binding)binding;\n    }\n}</code></pre></div>\n<p>It obtains the Bindings section from the configuration file of the current executable. Such a file may look as follows:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;\n&lt;configuration&gt;\n  &lt;system.serviceModel&gt;\n    &lt;bindings&gt;\n      &lt;netTcpBinding&gt;\n        &lt;binding name=&quot;netTcp&quot; sendTimeout=&quot;00:05:00&quot; /&gt;\n      &lt;/netTcpBinding&gt;\n    &lt;/bindings&gt;\n  &lt;/system.serviceModel&gt;\n&lt;/configuration&gt;</code></pre></div>\n<p>The BindingFactory gives you access to bindings defined in the application config file and you can use it in a programmatic scenario as follows:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">serviceHost.AddServiceEndpoint(\n  typeof (IServerWithCallback),\n  BindingFactory.GetFromConfig(&quot;netTcp&quot;),\n  &quot;net.tcp://localhost:9080/DataService&quot;);</code></pre></div>\n<p>There is an issue right now in that the Binding Factory is Binding-agnostic, while the endpoint address provided is not (Why, btw? â€“ What about binding-agnostic endpoint addresses which may be mapped to actual addresses somewhere else?), but changing the whole channel probably merits some other code changes here &#x26; there.</p>","fields":{"slug":"/2010/07/30/wcf-externalize-binding-configuration-only"},"frontmatter":{"date":"July 30, 2010","path":null,"title":"WCF: Externalize Binding Configuration Only","tags":["libs-and-frameworks","csharp"]}}},"pageContext":{"title":"WCF: Externalize Binding Configuration Only","previous":{"fields":{"slug":"/2010/07/16/respond_to-in-net"},"frontmatter":{"title":"respond_to in .NET","tags":["ruby","csharp"],"date":"2010/07/16"}},"next":{"fields":{"slug":"/2010/07/30/wie-ich-rest-meiner-ehefrau-erkl-auml;rte"},"frontmatter":{"title":"Wie ich REST meiner Ehefrau erkl&auml;rte","tags":["software-development","loosely-coupled","web"],"date":"2010/07/30"}}}}