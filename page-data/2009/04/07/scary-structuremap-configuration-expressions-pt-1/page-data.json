{"componentChunkName":"component---src-templates-article-template-js","path":"/2009/04/07/scary-structuremap-configuration-expressions-pt-1","result":{"data":{"markdownRemark":{"html":"<p>\"Most scary StructureMap Configuration Expression\"â„¢ so far...\n<csharp>\nForRequestedType<ISession>()\n.InterceptConstructionWith(wcfCachePolicy)\n.AddInstances(instanceExpression =>\ninstanceExpression.Conditional(\ncond =>\n{\ncond.TheDefault.Is.ConstructedBy(\nctx =>\nctx.GetInstance<ISessionFactory>()\n.OpenSession(\nnew IsisNHInterceptor(ctx.GetInstance<IRequestContext>())));\ncond.If(ctx => ctx.ParentType.Name.Contains(\"ReadOnly\")).ThenIt.Is.\nConstructedBy(\nctx =>ctx.GetInstance<ISessionFactory>().OpenSession());\n}));\n</csharp></p>\n<p>The idea: In order to correctly talk to a decidedly legacy-i Database correct, write operations need to set a number of session variables for the used connection. This is done by an NHibernate Session interceptor. The convention is then that the Repository using the NHibernate session does not contain the text \"ReadOnly\" in its class name. If it does, the repository promises to only read the database which is unlikely (I hope) to trigger any..err..triggers. In this case the Interceptor isn't necessary.</p>","fields":{"slug":"/2009/04/07/scary-structuremap-configuration-expressions-pt-1"},"frontmatter":{"date":"April 07, 2009","path":null,"title":"Scary StructureMap configuration expressions Pt.1","tags":["csharp","libs-and-frameworks"]}}},"pageContext":{"title":"Scary StructureMap configuration expressions Pt.1","previous":{"fields":{"slug":"/2009/03/27/comfortable-command-line-argument-parsing","published":true},"frontmatter":{"title":"Comfortable command line argument parsing","tags":["software-development","dotnet"],"date":"2009/03/27"}},"next":{"fields":{"slug":"/2009/04/17/how-much-does-linq-take-take","published":true},"frontmatter":{"title":"How much does Linq.Take take?","tags":["dotnet","libs-and-frameworks"],"date":"2009/04/17"}}}}}