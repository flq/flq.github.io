{"componentChunkName":"component---src-templates-article-template-js","path":"/2009/03/07/another-beacon-in-a-sea-of-expressions","result":{"data":{"mdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Another beacon in a sea of expressions\",\n  \"layout\": \"post\",\n  \"tags\": [\"software-development\", \"download\", \"dotnet\", \"libs-and-frameworks\"],\n  \"date\": \"2009-03-07T15:57:43.000Z\",\n  \"redirect_from\": \"/go/139/\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"A prosaic introduction to the subject of .NET expressions. These were introduced with .NET 3.5 and are featured most prominently in LINQ. Over \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/go/118\"\n  }, \"here\"), \" I implemented a use case with the aid of expressions.\"), mdx(\"p\", null, \"In my current project I am using expressions to be able to analyze what the user of some API wants to express. From the expression\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"text\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-text\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\"\n  }, \"Expression<Function<Person,object>> e = p => p. FirstName + \\\",\\\" + p.LastName\"))), mdx(\"p\", null, \"I want to know that properties \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"FirstName\"), \" and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"LastName\"), \" are being used to generate the return value. While developing the things for this to work I came across two things that really helped me:\"), mdx(\"h2\", null, \"A debugger visualizer for expressions\"), mdx(\"p\", null, \"There is one available as part of the Visual Studio samples (under \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Microsoft Visual Studio 9.0\\\\Samples\\\\1033\\\\CSharpSamples.zip\\\\LinqSamples\\\\ExpressionTreeVisualizer\"), \") or downloadable from \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://code.msdn.microsoft.com/csharpsamples\"\n  }, \"here\"), \".\"), mdx(\"p\", null, \"You will need to compile the visualizer and place it under \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"VS9.0\\\\Common7\\\\Packages\\\\Debugger\\\\Visualizers\"), \".\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/assets/expressiontreevisualizer.jpg\",\n    \"alt\": \"visualization of a simple expression\"\n  })), mdx(\"h2\", null, \"The expression Visitor\"), mdx(\"p\", null, \"At the end of \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://blogs.msdn.com/mattwar/archive/2007/07/31/linq-building-an-iqueryable-provider-part-ii.aspx\"\n  }, \"this post here\"), \" on \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://blogs.msdn.com/mattwar/\"\n  }, \"The Wayward Weblog\"), \". I have taken exactly that code and just made a run with R# over it. \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/assets/ExpressionVisitor.cs\"\n  }, \"Grab it over here\"), \". The class is extremely useful when you are checking up on complex expression trees. The class ensures that all nodes of the tree are visited and that you can actually replace certain parts of it. \"), mdx(\"p\", null, \"You would typically create a class that inherits from the ExpressionVisitor, override the methods that are interesting to you and provide some entry point that accepts an expression which is subsequently passed to the protected base class's Visit method. \"), mdx(\"p\", null, \"As an example, I wanted to parse an expression that gets a DataSet as arguments and represents access to a number of fields on a number of rows stemming from said DataSet. In this case I was only interested in any MemberAccess and it was sufficient to just override that method and insert my logic:\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"csharp\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-csharp\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token keyword\"\n  }, \"protected\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token keyword\"\n  }, \"override\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token return-type class-name\"\n  }, \"Expression\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token function\"\n  }, \"VisitMemberAccess\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"(\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token class-name\"\n  }, \"MemberExpression\"), \" m\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \")\"), \"\\n\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"{\"), \"\\n  \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token keyword\"\n  }, \"if\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"(\"), \"m\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \".\"), \"Member\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \".\"), \"DeclaringType\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \".\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token function\"\n  }, \"IsSubclassOf\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"(\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token keyword\"\n  }, \"typeof\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"(\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token type-expression class-name\"\n  }, \"DataRow\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \")\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \")\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"&&\"), \"\\n      \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"!\"), \"m\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \".\"), \"Type\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \".\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token function\"\n  }, \"IsSubclassOf\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"(\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token keyword\"\n  }, \"typeof\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"(\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token type-expression class-name\"\n  }, \"DataRow\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \")\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \")\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \")\"), \"\\n  \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"{\"), \"\\n    datasetFieldName \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"=\"), \" m\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \".\"), \"Member\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \".\"), \"Name\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \";\"), \"\\n    tableName \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"=\"), \" m\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \".\"), \"Member\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \".\"), \"DeclaringType\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \".\"), \"Name\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \".\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token function\"\n  }, \"Replace\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"(\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token string\"\n  }, \"\\\"Row\\\"\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \",\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token string\"\n  }, \"\\\"\\\"\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \")\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \";\"), \"\\n  \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"}\"), \"\\n  \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token keyword\"\n  }, \"else\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token keyword\"\n  }, \"if\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"(\"), \"m\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \".\"), \"Member\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \".\"), \"DeclaringType\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \".\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token function\"\n  }, \"IsSubclassOf\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"(\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token keyword\"\n  }, \"typeof\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"(\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token type-expression class-name\"\n  }, \"DataSet\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \")\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \")\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \")\"), \"\\n  \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"{\"), \"\\n    dataSetName \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"=\"), \" m\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \".\"), \"Member\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \".\"), \"DeclaringType\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \".\"), \"Name\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \";\"), \"\\n    entryTable \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"=\"), \" m\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \".\"), \"Member\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \".\"), \"Name\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \";\"), \"\\n  \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"}\"), \"\\n  \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token function\"\n  }, \"persistField\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"(\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \")\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \";\"), \"\\n  \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token keyword\"\n  }, \"return\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token keyword\"\n  }, \"base\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \".\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token function\"\n  }, \"VisitMemberAccess\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"(\"), \"m\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \")\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \";\"), \"\\n\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"}\")))), mdx(\"p\", null, \"As a last example, to show off the tree modifying features of the class to change an expression, the following 2 methods change\"), mdx(\"p\", null, mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"Expression<Func<SomeDataSet,object>> e = ds => ds.Master[0].FirstName + \\\",\\\" + ds.Master[0].GetAddresses()[0].City;\"), \"\\nto\\n\", mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"Expression<Func<DataRow,object>> e = r => ((MasterRow)r).FirstName + \\\",\\\" + ((MasterRow)r).GetAddresses()[0].City;\")), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"text\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-text\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\"\n  }, \"protected override Expression VisitMethodCall(MethodCallExpression m)\\n{\\n  if (m.Method.Name == \\\"get_Item\\\")\\n    return Expression.Convert(dataRowParameter, m.Type);\\n  return base.VisitMethodCall(m);\\n}\\n\\nprotected override Expression VisitLambda(LambdaExpression lambda)\\n{\\n  if (visitedMainLambdaBody) \\n    return base.VisitLambda(lambda);\\n  visitedMainLambdaBody = true; // sort of. This is somewhat recursive...\\n  Expression body = Visit(lambda.Body);\\n  List<ParameterExpression> @params =\\n    new List<ParameterExpression> { dataRowParameter };\\n\\n  return Expression.Lambda<Func<DataRow, object>>(body, @params);\\n}\"))));\n}\n;\nMDXContent.isMDXComponent = true;","fields":{"slug":"/2009/03/07/another-beacon-in-a-sea-of-expressions"},"frontmatter":{"date":"March 07, 2009","path":null,"title":"Another beacon in a sea of expressions","tags":["software-development","download","dotnet","libs-and-frameworks"]}}},"pageContext":{"title":"Another beacon in a sea of expressions","previous":{"fields":{"slug":"/2009/01/31/playing-lotto-with-linq","published":true},"frontmatter":{"title":"Playing Lotto with LINQ","tags":["dotnet","geekdom","loosely-coupled"],"date":"2009/01/30"}},"next":{"fields":{"slug":"/2009/03/11/cycling-through-a-number-range","published":true},"frontmatter":{"title":"cycling through a number range","tags":["programming","dotnet","geekdom","mathematics","csharp"],"date":"2009/03/11"}}}},"staticQueryHashes":["256249292","2581731408","3764592887"]}