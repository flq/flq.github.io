{"componentChunkName":"component---src-templates-article-template-js","path":"/2009/03/27/comfortable-command-line-argument-parsing","result":{"data":{"markdownRemark":{"html":"<p>Once in a while you may want to write a command line tool which may have to accept commad line arguments. In comes a nice little bit of source code that is part of the great output of the Mono project. Documentation is available <a href=\"http://www.ndesk.org/doc/ndesk-options/NDesk.Options/OptionSet.html\">here</a> and the <a href=\"http://anonsvn.mono-project.com/viewvc/trunk/mcs/class/Mono.Options/Mono.Options/\">source code</a> can be taken, used directly, modified and it (obviously) compiles without any issues from .NET Framework 2.0 onwards.</p>\n<p>An example is within the docs, in the following an example of how I intend to use it for a tool to be built that will extract information via the Team Foundation Server API:</p>\n<csharp>\nstruct Args\n{\n  public bool ShowHelp;\n  public bool IncludeBugs;\n  public string FSId;\n<p>  public override string ToString()\n{\nreturn string.Format(\"show help: {0}, include bugs: {1}, passed fsid: {2}\",\nShowHelp, IncludeBugs, FSId);\n}\n}\n</csharp></p>\n<p>This is a simple structure to capture the input from the arguments. Now comes the usage of the Options class:</p>\n<csharp>\nArgs args = new Args();\nvar options =\n  new OptionSet\n    {\n      {\"h|help|?\", \"Prints out usage\", v => args.ShowHelp = v != null},\n      {\"b|includeBugs\", \"Also consider bugs for scanning\", v => args.IncludeBugs = v != null},\n      {\"fsid=\", \"Specify the functional spec ID, e.g. XYZ2\", v => args.FSId = v}\n    };\n</csharp>\n<p>This tells the Options API which args can be accepted. Finally comes the parsing, with <strong>input</strong> being the string array containing any arguments passed in...</p>\n<csharp>\ntry\n{\n  options.Parse(input);\n  Console.WriteLine(args.ToString());\n}\ncatch (OptionException)\n{\n  showHelp(options);\n}\n<p>if (args.ShowHelp) showHelp(options);\n</csharp></p>\n<p>Finally the showHelp method which uses the Options' <strong>WriteOptionDescriptions</strong> method...</p>\n<csharp>\nprivate static void showHelp(OptionSet options)\n{\n  Console.WriteLine(\"Intended usage:\");\n  options.WriteOptionDescriptions(Console.Out);\n}\n</csharp>\n<p>Based on this program, the showHelp method prints out the following:</p>\n<p><code class=\"language-text\">Intended usage:\n  -h, --help, -?             Prints out usage\n  -b, --includeBugs          Also consider bug items for scanning\n      --fsid=VALUE           Specify the functional spec ID, e.g. XYZ2</code></p>\n<p>This style of parsing and obtaining the values allows the user to use the tool without thinking much about it. It will parse...</p>\n<p>tool /h, tool --help or tool -?, tool /b /fsid:Bla or tool --includeBugs -fsid=Bla</p>\n<p>Not bad, and readily available...</p>","fields":{"slug":"/2009/03/27/comfortable-command-line-argument-parsing"},"frontmatter":{"date":"March 27, 2009","path":null,"title":"Comfortable command line argument parsing","tags":["software-development","dotnet"]}}},"pageContext":{"title":"Comfortable command line argument parsing","previous":{"fields":{"slug":"/2009/03/11/cycling-through-a-number-range","published":true},"frontmatter":{"title":"cycling through a number range","tags":["programming","dotnet","geekdom","mathematics","csharp"],"date":"2009/03/11"}},"next":{"fields":{"slug":"/2009/04/07/scary-structuremap-configuration-expressions-pt-1","published":true},"frontmatter":{"title":"Scary StructureMap configuration expressions Pt.1","tags":["csharp","libs-and-frameworks"],"date":"2009/04/07"}}}}}