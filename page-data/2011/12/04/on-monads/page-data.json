{"componentChunkName":"component---src-templates-article-template-js","path":"/2011/12/04/on-monads","result":{"data":{"mdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"On Monads\",\n  \"layout\": \"post\",\n  \"tags\": [\"programming\", \"dotnet\", \"haskell\"],\n  \"date\": \"2011-12-04T12:00:00.000Z\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component '\" + name + \"' was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"The following was written by me as a comment on a \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://lostechies.com/derickbailey/2010/09/30/monads-in-c-which-part-is-the-monad/\"\n  }), \"post from Derick Bailey regarding Monads\"), \". Since then,\\nthe comments have disappeared, presumably because they moved to the disqus commenting system. While I managed to migrate my comments\\nlostechies apparently is unable to do so - sad, considering that the comments on a blog post often add a lot of value.\")), mdx(\"p\", null, \"When you move on in the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://en.wikipedia.org/wiki/Monad_(functional_programming)\"\n  }), \"very same wikipedia article\"), \" \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"(Concepts/Definition)\"), \" (\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"about monads - ed.\"), \"), I think it all becomes a lot clearer. A monad is defined by\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"\\\"A type construction that defines, for every underlying type, how to obtain a corresponding monadic type.\\\"\")), mdx(\"p\", null, \"The mere ability to say that for every T you can construct a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Maybe(Of T)\"), \" should satisfy this condition.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"\\\"A unit function that maps a value in an underlying type to a value in the corresponding monadic type.\\\"\")), mdx(\"p\", null, \"This is quite clearly your extension method \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"\\\"ToMaybe()\\\"\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"\\\"A binding operation of polymorphic type (M t)->(t->M u)->(M u)\\\"\")), mdx(\"p\", null, \"Looks weird, but check out the signature of your e.g. \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"\\\"If\\\"\"), \" \"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"text\"\n  }, mdx(\"pre\", _extends({\n    parentName: \"div\"\n  }, {\n    \"className\": \"language-text\"\n  }), mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"Maybe<TInput> If<TInput>(this Maybe<TInput> maybe, Func<TInput,bool> func)\"))), mdx(\"p\", null, \"Input is a type of your \\\"nested\\\" monadic type system. Then comes a mapping from a non-monadic type to a monadic one. This doesn't become apparent in the function signature, but you will notice that the \\\"Func\\\" is used to construct an instance in the monadic type system. \"), mdx(\"p\", null, \"Finally the result is an instance of the Monadic type system. Hence, your \\\"If\\\" is the \\\"bind\\\" part of the monad. In this case \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"\\\"t\\\" = \\\"u\\\"\"), \", but in your definition of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"\\\"Get\\\"\"), \", \\\"t\\\" and \\\"u\\\" can be different types.\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"text\"\n  }, mdx(\"pre\", _extends({\n    parentName: \"div\"\n  }, {\n    \"className\": \"language-text\"\n  }), mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"Maybe<TResult> Get<TInput, TResult>(\\n    Maybe<TInput> maybe, Func<TInput, TResult> func)\"))), mdx(\"p\", null, \"Chaining comes automatically, since the output of a bind is part of the Monadic type system and you have ensured that for every type \\\"t\\\" or \\\"u\\\" (sticking to the above definition) there is a mapping to the monadic type system.\"), mdx(\"p\", null, \"As another example LINQ is \\\"almost\\\" monadic. What it has missing is a unit function from T -> IEnumerable which you can provide easy enough:\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"text\"\n  }, mdx(\"pre\", _extends({\n    parentName: \"div\"\n  }, {\n    \"className\": \"language-text\"\n  }), mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"public IEnumerable<T> ToEnumerable(this T obj) { yield return obj; }\"))), mdx(\"p\", null, \"You'll probably recognize that e.g. the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"\\\"Select\\\"\"), \" has a very similar structure, with the monadic type system being \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"IEnumerable(Of T)\"), \". Again, method chaining follows from the mere definition of a monad. It looks similar to a fluent interface but I wouldn't confuse the two, as it doesn\\u2019t help and in fluent interfaces you often just return the instance on which you called the method, sparing you the use of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"\\\";\\\"\")), mdx(\"p\", null, \"That's my 2 cents, almost a blog post in itself :)\"));\n}\n;\nMDXContent.isMDXComponent = true;","fields":{"slug":"/2011/12/04/on-monads"},"frontmatter":{"date":"December 04, 2011","path":null,"title":"On Monads","tags":["programming","dotnet","haskell"]}}},"pageContext":{"title":"On Monads","previous":{"fields":{"slug":"/2011/11/27/in-built-conventions-in-fubumvc","published":true},"frontmatter":{"title":"In-built conventions in Fubumvc","tags":["software-development","dotnet","web","libs-and-frameworks"],"date":"2011/11/27"}},"next":{"fields":{"slug":"/2011/12/05/defining-contiguous-activities-with-idisposable","published":true},"frontmatter":{"title":"defining contiguous activities with IDisposable","tags":["software-development","dotnet","patterns","fsharp"],"date":"2011/12/05"}}}}}