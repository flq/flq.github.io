{
    "componentChunkName": "component---src-templates-article-template-js",
    "path": "/2011/11/18/the-wpf-stack-du-jour",
    "result": {"data":{"mdx":{"excerpt":"For the past year i've had plenty of possibility to get my head around WPF as a UI technology. \nIn that time a number of frameworks have crystallizedâ€¦","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"The WPF stack du jour\",\n  \"layout\": \"post\",\n  \"tags\": [\"dotnet\", \"libs-and-frameworks\"],\n  \"date\": \"2011-11-18T21:00:00.000Z\",\n  \"redirect_from\": \"/go/206/\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"For the past year i've had plenty of possibility to get my head around WPF as a UI technology.\\nIn that time a number of frameworks have crystallized that in their combination makes writing good WPF Apps, let's say, bearable:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"http://caliburnmicro.codeplex.com/\"\n  }, \"Caliburn.Micro\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://github.com/structuremap/structuremap\"\n  }, \"StructureMap\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://github.com/flq/MemBus\"\n  }, \"Membus\"))), mdx(\"h2\", null, \"Caliburn.Micro:\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"What it brings to the table\"), \": \"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Conventional wiring of ViewModel->View, \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"conventional and extendable wiring of UI elements to elements of the Viewmodel, \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Interfaces that allow you to cleanly describe the lifecycles of your ViewModels, \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"a nice hook to get your favorite DI Container doing instantiation work for you\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A nice attached property to get out of corner cases when needing View events in ViewModels.\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"What it should bring to the table\"), \": Not much really, I prefer that thing to stay low-profile.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"What it shouldn't bring to the table\"), \": I can't find a use case for the coroutine implementation, I don't need the event aggregator (see MemBus), it's unlikely I'll ever need all those default conductors already defined.\"), mdx(\"h2\", null, \"StructureMap\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"What it brings to the table\"), \": Fufils all instantiation needs you'll ever have, served to you in a non-ceremomial way that puts the current MEF incarnation to shame.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"What it should bring to the table\"), \": Some funky things I am beginning to desire after a couple of years of DI Container usage.\"), mdx(\"h2\", null, \"MemBus\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"What it brings to the table\"), \": Fulfils all \\\"event aggregation\\\" needs you'll ever have. Seamless wiring of ViewModels to messages, in-built mechsnism to ensure messages are processed on the UI thread or processed in the background, extensible to allow your own interesting scenarios around app-internal messaging.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"What it should bring to the table\"), \": I am still wondering whether correlated messaging could be useful (publishing a message with id x and then receiving messages in the context of that id)\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"What it doesn't need to bring to the table\"), \": Funny enough there is quite a bit of API I don't need anymore, because it can be expressed in a different way that seems more attractive and maintainable. I'll probably mark those bits as obsolete.\"), mdx(\"p\", null, \"This \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"package\"), \", sprinkled with a number of goodies which I usually don't bother making a dll of (for example the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/2011/02/18/more-datatemplates-in-wpf\"\n  }, \"DataTemplateChoice\"), \", or an attached property to influence Focus from the ViewModel, or a key binding service with a simple API that saves me the trouble to know the goddamn visual tree all the time) allows for a pretty quick development speed while maintaining a fairly clean overall structure and keeping a number of hooks and tools around to tackle more challenging stuff.\"));\n}\n;\nMDXContent.isMDXComponent = true;","fields":{"slug":"/2011/11/18/the-wpf-stack-du-jour"},"frontmatter":{"date":"2011-11-18","path":null,"title":"The WPF stack du jour","tags":["dotnet","libs-and-frameworks"]}}},"pageContext":{"title":"The WPF stack du jour","previous":{"fields":{"slug":"/2011/11/17/new-tooling-new-posts","published":true},"frontmatter":{"title":"New Tooling, new Posts","tags":["software-development","loosely-coupled"],"date":"2011/11/17"}},"next":{"fields":{"slug":"/2011/11/21/a-custom-modelbinder-in-fubumvc-to-access-json-dynamically","published":true},"frontmatter":{"title":"A custom ModelBinder in FubuMVC to access JSON dynamically","tags":["software-development","web","libs-and-frameworks"],"date":"2011/11/21"}}}},
    "staticQueryHashes": ["256249292","2581731408"]}