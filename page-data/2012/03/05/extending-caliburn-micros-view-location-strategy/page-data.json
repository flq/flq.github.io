{"componentChunkName":"component---src-templates-article-template-js","path":"/2012/03/05/extending-caliburn-micros-view-location-strategy","result":{"data":{"mdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Extending Caliburn-Micro's view location strategy\",\n  \"layout\": \"post\",\n  \"tags\": [\"WPF\", \"patterns\", \"libs-and-frameworks\"],\n  \"date\": \"2012-03-05T14:00:00.000Z\",\n  \"redirect_from\": \"/go/215/\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/flq/Scal\"\n  }, \"Scal\"), \" (containing name parts of \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"S\"), \"tructureMap and \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Cal\"), \"iburn.Micro) is a project into which flows the way I like to work with Caliburn.Micro (CM). Scal brings together what I like to use in a reasonable sized WPF app - its Nuget dependencies are...manifold:\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/assets/scal_deps.png\",\n    \"alt\": \"Scal dependencies\"\n  })), mdx(\"sup\", null, \"(CM is added directly to the Nuget package such as to avoid the install script which would be more confusing than helpful in the context of Scal)\"), mdx(\"p\", null, \"This post is about an addition in Scal that extends how \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://caliburnmicro.codeplex.com/\"\n  }, \"Caliburn.Micro\"), \" typically joins Views to ViewModels. While still being in its infancy, one cannot deny that it is heavily inspired by \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/DarthFubuMVC/fubumvc\"\n  }, \"FubuMVC\"), \"'s ability to be able to register how certain properties of ViewModels should be rendered in HTML. This was something that I was missing in CM.\"), mdx(\"p\", null, \"Caliburn's matching of Views to ViewModels is ultimately based on matching the name of the View to the name of the ViewModel. I wanted something that would allow me to choose a View based on other information provided by the ViewModel, e.g. saying that a DateTime property should be rendered in a certain way.\"), mdx(\"p\", null, \"Thankfully, CM has a very interesting way to provide extensibility by providing many methods doing the core work as static Fields of delegate types. That way, you can override CMs behavior in many ways.\"), mdx(\"p\", null, \"In Scal you will find a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/flq/Scal/blob/master/Scal/ViewLocation/ViewLocationManagement.cs\"\n  }, \"ViewLocationManagement\"), \" that overrides CMs way of getting from ViewModels to Views:\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"text\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-text\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\"\n  }, \"ViewLocator.LocateForModel = Locate;\\n...\\nprivate UIElement Locate(object viewModel, DependencyObject visualParent, object context)\\n{\\n    var lCtx = new LocationContext(viewModel, visualParent, context);\\n    var view = _locators.Select(l => l.LocateView(lCtx)).MaybeFirst();\\n\\n    return view.MustHaveValue(ConstructFailureElement(viewModel));            \\n}\"))), mdx(\"p\", null, \"The action of getting the correct UIElement for a Model is now delegated to classes that implement the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/flq/Scal/blob/master/Scal/ViewLocation/IViewLocator.cs\"\n  }, \"IViewLocator\"), \" interface:\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"text\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-text\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\"\n  }, \"public interface IViewLocator\\n{\\n    Maybe<UIElement> LocateView(LocationContext locationContext);\\n}\"))), mdx(\"p\", null, \"The first view locator required in this context is one that provides the default CM functionality. This is easily done by ensuring that the original implementation is not lost:\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"text\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-text\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\"\n  }, \"_original = ViewLocator.LocateForModel;\\n...\\npublic Maybe<UIElement> LocateView(LocationContext ctx)\\n{\\n    var ui = _original(ctx.Model, ctx.VisualParent, ctx.CaliburnContext.Value);\\n\\n    if (ui is TextBlock && ((TextBlock)ui).Text.StartsWith(\\\"Cannot find view for\\\"))\\n        return Maybe<UIElement>.None;\\n    return ui.ToMaybe();\\n}\"))), mdx(\"p\", null, \"This class contains a strange check with regard to the returning element - unfortunately I rely on a CM \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"implementation detail\"), \" in how it returns a UIElement when it couldn't locate a View. The \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/flq/Scal/blob/master/Scal/ViewLocation/CaliburnMicroLocator.cs\"\n  }, \"CaliburnMicroLocator\"), \" ensures this is correctly mapped to \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"I do not have a UIElement!\")), mdx(\"p\", null, \"With the interface and a chain of responsibility in place \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Scal\"), \" can now allow to extend how Views are located in different ways. For this Scal introduces a place where you can configure such things (Again, inspired by FubuMVC). The Scal \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/flq/Scal/blob/master/SampleApp/AppConfiguration.cs\"\n  }, \"sample app configuration\"), \" e.g. contains the following lines:\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"text\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-text\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\"\n  }, \"ViewLocation\\n    .ModelsMatching<DateTime>(m => \\n      m.Use((b, ctx) => b.Start<DatePicker>(ctx.Model).StaticStyle(\\\"EditableDate\\\").BindSelectedDate()))\\n    .ModelsMatching<CustomerNumber>(m => m.FromMatchingDataTemplate());\"))), mdx(\"p\", null, \"The API is rather crude at this point in that it only allows to match on a property type, but it allows you to work even more with \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"ContentControls\"), \" on the Xaml level and get a more consistent output for things. A future release will allow to check requirements based on the LocationContext. This contains information that should in many cases of CM usage give information about the parent ViewModel, the property being bound and the parent UIElement.\"));\n}\n;\nMDXContent.isMDXComponent = true;","fields":{"slug":"/2012/03/05/extending-caliburn-micros-view-location-strategy"},"frontmatter":{"date":"March 05, 2012","path":null,"title":"Extending Caliburn-Micro's view location strategy","tags":["WPF","patterns","libs-and-frameworks"]}}},"pageContext":{"title":"Extending Caliburn-Micro's view location strategy","previous":{"fields":{"slug":"/2011/12/31/tired-of-null-references-abolish-them-with-maybe","published":true},"frontmatter":{"title":"Tired of Null references? abolish them with Maybe","tags":["csharp","programming","dotnet","patterns"],"date":"2011/12/31"}},"next":{"fields":{"slug":"/2012/03/22/membus-v2-news","published":true},"frontmatter":{"title":"membus v2 news","tags":["own-software","dotnet","membus"],"date":"2012/03/22"}}}},"staticQueryHashes":["256249292","2581731408","3764592887"]}