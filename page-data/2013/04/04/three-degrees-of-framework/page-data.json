{"componentChunkName":"component---src-templates-article-template-js","path":"/2013/04/04/three-degrees-of-framework","result":{"data":{"mdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Three degrees of Framework\",\n  \"layout\": \"post\",\n  \"tags\": [\"software-development\", \"patterns\"],\n  \"date\": \"2013-04-04T07:12:51.000Z\",\n  \"redirect_from\": \"/go/221/\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"In case it would not be obvious, there is a ton of things out there that can be reused in the form of packages. Those packages would roughly fall into any of the following categories where a single framework can obviously fall into several categories at once.\"), mdx(\"h3\", null, \"3 degrees of framework\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"A framework that you interact with by \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"calling on to its API\"), \".\", mdx(\"br\", null), \"\\nStrictly speaking, such a piece of code is not a framework but a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"library\"), \". Many things that are typically related to the infrastructure of your application have to be done by yourself. The \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"library\"), \" provides you with some useful functionality that you do not want to create yourself. This could be things like parsing markdown, connection string builders & the like. Since most responsibility lies within your application such a library may not use \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"low-level\"), \" concurrency mechanisms. Higher level abstractions are available these days to provide concurrency at a level controllable by the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"caller\"), \" in the form of Promises (\", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Tasks\"), \" in .NET).Arguably, such libraries should not interfere too much with the lifecycle of objects, but certain libraries do have caching of runtime-constructed artefacts for performance reasons (e.g. \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://json.codeplex.com\"\n  }, \"Newtonsoft.Json\"), \" or \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/ServiceStack/ServiceStack.Text\"\n  }, \"ServiceStack.Text\"), \").\", mdx(\"br\", null))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"A framework with which you interact by \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"inheriting from certain base classes, implementing interfaces, participate in predefined lifecycles\"), \" and the like\", mdx(\"br\", null), \"\\nYou will find many frameworks in this category that provide some kind of infrastructure into which you hook your code. Many Frameworks from Microsoft fall into this category, be it Web frameworks like ASP.NET (MVC), or Rich client frameworks like WPF, Winforms, etc. Such frameworks usually use low-level functionality in order to provide higher-level abstractions with which your code interacts. While such Frameworks can provide rich environments, testing code that is meant to run \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"on top\"), \" of such a framework can be a chore, e.g. when to obtain a certain infrastructural possibility you have to inherit from some class which has dependencies that are required and are complex to set up. \", mdx(\"br\", null))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"A framework which employs \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"predefined conventions\"), \" in order to cut on configuration time, or the need to implement certain interfaces or inherit from base classes. Such a framework is not necessarily much different from one described in \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"(2)\"))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"A framework which \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"lets you define in what way you want to make use of the framework's functionality\"), mdx(\"br\", null), \"\\nThis kind of writing a framework has the most potential for you to be able to write code which has no dependencies on the used framework. This can only be achieved by applying \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"conventions\"), \" as well as applying \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"dependency injection\"), \" - given carefully chosen abstractions you can write code which you can happily test run but which does play nice with the framework of choice. The drawback for the framework developer is increased effort in designing a sound Meta-API (In the sense that you use such an API to tell the framework how you intend to interact with the runtime API). As a Framework user, though, I am happy when I can use a framework that fulfils the definition of \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"(4)\"), \".\"))), mdx(\"p\", null, \"Interestingly, in terms of .NET Microsoft itself provides very little that falls into Category 4. This area has been pioneered by Non-MS Open Source. \"));\n}\n;\nMDXContent.isMDXComponent = true;","fields":{"slug":"/2013/04/04/three-degrees-of-framework"},"frontmatter":{"date":"2013-04-04","path":null,"title":"Three degrees of Framework","tags":["software-development","patterns"]}}},"pageContext":{"title":"Three degrees of Framework","previous":{"fields":{"slug":"/2013/03/25/complexity-is-subjective","published":true},"frontmatter":{"title":"Complexity is subjective","tags":["physics","software-development"],"date":"2013/03/25"}},"next":{"fields":{"slug":"/2013/04/25/words-you-should-avoid-if-youre-not-a-mathematician","published":true},"frontmatter":{"title":"Words you should avoid if you're not a mathematician","tags":["loosely-coupled","mathematics"],"date":"2013/04/25"}}}},"staticQueryHashes":["256249292","2581731408"]}