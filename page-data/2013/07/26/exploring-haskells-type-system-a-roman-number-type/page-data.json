{"componentChunkName":"component---src-templates-article-template-js","path":"/2013/07/26/exploring-haskells-type-system-a-roman-number-type","result":{"data":{"mdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Exploring Haskell's type system - A Roman number type\",\n  \"layout\": \"post\",\n  \"tags\": [\"programming\", \"haskell\"],\n  \"date\": \"2013-07-26T20:50:57.000Z\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar Gist = makeShortcode(\"Gist\");\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Once in a while I need a break from my day-to-day job in C# land. Don't get me wrong, I like the language, but it doesn't cover \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"all\"), \" of my intellectual needs.\\nMore specifically, if I\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Need some functional, imperfect chaos, which gets much done nonetheless, or in \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"http://www.hanselman.com/blog/JavaScriptIsAssemblyLanguageForTheWebSematicMarkupIsDeadCleanVsMachinecodedHTML.aspx\"\n  }, \"Scott Hanselman's words\"), \", if I want to do some assembly language, I go and visit \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"JavaScript\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Need purity, the most amazing compiler that ruthlessly cracks down on any typing (in the computing sense) error you do, the serenity of a perfect universe that simulates dirt only if it has to, then I visit \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Haskell\"), \".\")), mdx(\"p\", null, \"This time it was Haskell's turn - the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://realfiction.net/go/92\"\n  }, \"last time\"), \" I delved into Haskell, I hadn't really touched its type system, only used those already in place. This time I wanted to rectify that.\"), mdx(\"h2\", null, \"Behold - the Roman number\"), mdx(Gist, {\n    id: \"6273665\",\n    file: \"roman.hs\",\n    mdxType: \"Gist\"\n  }), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Disclaimer:\"), \" \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"I may have only implemented a subset of the proper rules of how to write Roman numbers. If you use this type to calculate the altitude of your plane, and it doesn't work, don't sue me, because I give no guarantees as to the 100% correctness of the code\")), mdx(\"p\", null, \"The Roman number \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"cough\"), \" system \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"cough\"), \" had no extraordinary mathematical capabilities - I am not aware of any systematic approach that would let you add two Roman numbers. Their only purpose must have been to attach a word to a number.\"), mdx(\"p\", null, \"The interesting parts with regard to the type system are \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"lines 8-22\"), \". What is defined here is\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"What a \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"Roman\"), \" is : It has two constructors that take a String or an Int\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"That a \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"Roman\"), \" can be shown, which makes it interesting e.g. in the interactive mode of Haskell\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"That two \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"Romans\"), \" can be compared\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"That a \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"Roman\"), \" behaves like a \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"Num\"), \" type\")), mdx(\"p\", null, \"The rest is really just a fair enough implementation of how to get from something like \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"MCMLXXXIV\"), \" to \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"1984\"), \".\"), mdx(\"p\", null, \"The (probably quite inaccurate) conclusions I take away from this quick splash into Haskell-land\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Haskell classes can be compared somewhat to interfaces, but they can carry default implementations\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Haskell data can have what could be compared to multiple constructors, but later on we can actually match on how data was constructed\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Not used here, but Haskell has a decent record syntax (yes, I am pointing at you, \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"http://learnyousomeerlang.com/a-short-visit-to-common-data-structures\"\n  }, \"Erlang\"), \") \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The capabilities, or traits, or contracts or whatever you like to call them are much cleaner defined. Not every \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"thing\"), \" is by default equatable. Not every \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"thing\"), \" is by default displayable.\")), mdx(\"p\", null, \"All in all, once again, refreshing, and purifying ;)\"));\n}\n;\nMDXContent.isMDXComponent = true;","fields":{"slug":"/2013/07/26/exploring-haskells-type-system-a-roman-number-type"},"frontmatter":{"date":"July 26, 2013","path":null,"title":"Exploring Haskell's type system - A Roman number type","tags":["programming","haskell"]}}},"pageContext":{"title":"Exploring Haskell's type system - A Roman number type","previous":{"fields":{"slug":"/2013/05/27/a-knee-shot-involving-structuremap-a-closure-and-a-leaking-implementation-detail","published":true},"frontmatter":{"title":"A knee-shot involving StructureMap, a closure and a leaking implementation detail","tags":["programming","dotnet"],"date":"2013/05/27"}},"next":{"fields":{"slug":"/2013/07/31/atrocious-learnings-of-haskell-for-make-benefit-of-solving-math-problem","published":true},"frontmatter":{"title":"Atrocious Learnings of Haskell for Make Benefit of solving Math Problem","tags":["programming","haskell"],"date":"2013/07/30"}}}},"staticQueryHashes":["256249292","2581731408","3764592887"]}