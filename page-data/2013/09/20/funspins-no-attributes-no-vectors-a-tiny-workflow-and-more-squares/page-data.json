{"componentChunkName":"component---src-templates-article-template-js","path":"/2013/09/20/funspins-no-attributes-no-vectors-a-tiny-workflow-and-more-squares","result":{"data":{"mdx":{"excerpt":"Inspired by Rob Ashton's series \" Learn   functional   programming with me \" This post kind of covers 3 of Rob's posts, as, frankly, I can't say muchâ€¦","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"FunSpIns - No attributes, No vectors, A tiny Workflow and more squares\",\n  \"layout\": \"post\",\n  \"tags\": [\"programming\", \"haskell\"],\n  \"date\": \"2013-09-20T14:00:00.000Z\",\n  \"topic\": \"fun-spin\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar TopicToc = makeShortcode(\"TopicToc\");\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(TopicToc, {\n    topicId: \"fun-spin\",\n    header: \"Functional space-invaders series\",\n    mdxType: \"TopicToc\"\n  }), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Inspired by Rob Ashton's series \\\"\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://codeofrob.com/entries/learn-functional-programming-with-me---attributes-and-vectors.html\"\n  }, \"Learn\"), \" \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://codeofrob.com/entries/learn-functional-programming-with-me---improving-my-workflow.html\"\n  }, \"functional\"), \" \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://codeofrob.com/entries/learn-functional-programming-with-me---adding-lots-more-state.html\"\n  }, \"programming with me\"), \"\\\"\")), mdx(\"p\", null, \"This post kind of covers 3 of Rob's posts, as, frankly, I can't say much about attributes - in Rob's case it refers to the DOM, which we don't have here.\\nWhy he would mention Vectors? I don't know, maybe to sound fancy ;)  \"), mdx(\"p\", null, \"When it comes to the working workflow in Haskell, my tool of choice right now is the interactive haskell (\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"ghci\"), \") - saying \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"em\", {\n    parentName: \"strong\"\n  }, \":load game\")), \" (provided I have a game.hs lying around) will either tell me that all is cool or throw relevant compiler errors at me, which usually is some form of elaborate type mismatch (\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"90%\"), \") or a syntax error (\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"9%\"), \") with an error margin of \", \"\\xB1\", \"1%.\"), mdx(\"p\", null, \"As to drawing lots of enemies, functional approaches should be somewhat similar. The permutation thing that Rob does with the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"(for [x \", \"[...]\", \"] [y \", \"[...]\", \"])\"), \" is also achieved with list comprehensions, just that you have to specify two ranges to feed the output. Here is a function to give us a grid of squares:\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"haskell\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-haskell\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-haskell\"\n  }, mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token hvariable\"\n  }, \"enemyGrid\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"(\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token hvariable\"\n  }, \"originX\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \",\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token hvariable\"\n  }, \"originY\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \")\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"(\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token hvariable\"\n  }, \"rows\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \",\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token hvariable\"\n  }, \"cols\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \")\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"=\"), \" \\n\\t\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token builtin\"\n  }, \"map\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token hvariable\"\n  }, \"toRect\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"[\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"(\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token hvariable\"\n  }, \"x\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \",\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token hvariable\"\n  }, \"y\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \")\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"|\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token hvariable\"\n  }, \"x\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"<-\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token builtin\"\n  }, \"take\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token hvariable\"\n  }, \"cols\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"[\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token hvariable\"\n  }, \"originX\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \",\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token hvariable\"\n  }, \"originX\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"+\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token number\"\n  }, \"60\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"..\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"]\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \",\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token hvariable\"\n  }, \"y\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"<-\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token builtin\"\n  }, \"take\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token hvariable\"\n  }, \"rows\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"[\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token hvariable\"\n  }, \"originY\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \",\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token hvariable\"\n  }, \"originY\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"+\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token number\"\n  }, \"30\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"..\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"]\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"]\"), \"\\n\\t\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token keyword\"\n  }, \"where\"), \"\\n\\t\\t\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token hvariable\"\n  }, \"toRect\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"(\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token hvariable\"\n  }, \"x\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \",\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token hvariable\"\n  }, \"y\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \")\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"=\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token constant\"\n  }, \"Rect\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token hvariable\"\n  }, \"x\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token hvariable\"\n  }, \"y\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token number\"\n  }, \"20\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token number\"\n  }, \"10\")))), mdx(\"p\", null, \"Providing two comma-separated values to the Haskell range (the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"[n..m]\"), \" thing, or here, the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"[n, n+s, ..]\"), \") defines the step of the range. Due to the lazy nature of Haskell,\\nI can leave the range open ended. The \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"breaking condition\"), \" is that I just \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"take\"), \" as many values as I want (columns and rows, respectively).\"), mdx(\"p\", null, \"These little buggers need to be fed into the drawing API, which we can do as such:\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"haskell\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-haskell\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-haskell\"\n  }, mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token hvariable\"\n  }, \"canvas\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"<-\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token hvariable\"\n  }, \"FX.getVideoSurface\"), \"\\n\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token builtin\"\n  }, \"mapM\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"(\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"\\\\\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token hvariable\"\n  }, \"r\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"->\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token hvariable\"\n  }, \"FX.fillRect\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token hvariable\"\n  }, \"canvas\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"(\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token constant\"\n  }, \"Just\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token hvariable\"\n  }, \"r\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \")\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token hvariable\"\n  }, \"white\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \")\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"$\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token hvariable\"\n  }, \"enemyGrid\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"(\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token number\"\n  }, \"10\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \",\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token number\"\n  }, \"10\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \")\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"(\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token number\"\n  }, \"5\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \",\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token number\"\n  }, \"10\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \")\"), \"\\n\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token constant\"\n  }, \"FX\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \".\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token builtin\"\n  }, \"flip\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token hvariable\"\n  }, \"canvas\")))), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"mapM\"), \" is again the monadic version of map\", mdx(\"sup\", null, \"*)\"), \", required to create something wrapped in IO context. The \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"(\\\\r ->\"), \" denotes the start of a lambda, while \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"$\"), \" influences associativity such that I spare myself surrounding the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"enemyGrid\"), \" call with brackets.\"), mdx(\"sup\", null, \"*) or Select, for the LINQ folks crazy enough to have followed this so far)\"));\n}\n;\nMDXContent.isMDXComponent = true;","fields":{"slug":"/2013/09/20/funspins-no-attributes-no-vectors-a-tiny-workflow-and-more-squares"},"frontmatter":{"date":"2013-09-20","path":null,"title":"FunSpIns - No attributes, No vectors, A tiny Workflow and more squares","tags":["programming","haskell"]}}},"pageContext":{"title":"FunSpIns - No attributes, No vectors, A tiny Workflow and more squares","previous":{"fields":{"slug":"/2013/09/19/funspins-moving-a-rectangle","published":true},"frontmatter":{"title":"FunSpIns - Moving a Rectangle","tags":["programming","haskell"],"date":"2013/09/19"}},"next":{"fields":{"slug":"/2013/09/23/funspins-state-the-world-the-loop","published":true},"frontmatter":{"title":"FunSpIns - State, the World, the Loop","tags":["programming","haskell"],"date":"2013/09/23"}}}},"staticQueryHashes":["256249292","2581731408"]}