{"componentChunkName":"component---src-templates-article-template-js","path":"/2013/09/19/funspins-moving-a-rectangle","result":{"data":{"mdx":{"excerpt":"Inspired by Rob Ashton's series \" Learn functional programming with me \" Last time a square got drawn, this time moving it would be nice. Rob'sâ€¦","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"FunSpIns - Moving a Rectangle\",\n  \"layout\": \"post\",\n  \"tags\": [\"programming\", \"haskell\"],\n  \"date\": \"2013-09-19T14:00:00.000Z\",\n  \"topic\": \"fun-spin\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar TopicToc = makeShortcode(\"TopicToc\");\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(TopicToc, {\n    topicId: \"fun-spin\",\n    header: \"Functional space-invaders series\",\n    mdxType: \"TopicToc\"\n  }), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Inspired by Rob Ashton's series \\\"\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://codeofrob.com/entries/learn-functional-programming-with-me---moving-the-square.html\"\n  }, \"Learn functional programming with me\"), \"\\\"\")), mdx(\"p\", null, \"Last time a square got drawn, this time moving it would be nice. Rob's approach was based on a recursive function call,\\none of the basic tools in FP to essentially do loops.\"), mdx(\"p\", null, \"Another way to consider the movement would be to look at it as a list of numbers, or coordinates, that dictate at which position\\nthe rectangle should be drawn. One weapon of choice in Haskell for sequences of things are \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://learnyouahaskell.com/starting-out#im-a-list-comprehension\"\n  }, \"list comprehensions\"), \".\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Incidentally I learned about list comprehensions in Erlang, which look very similar to Haskell's \")), mdx(\"p\", null, \"Hence, from a given sequence I would create Rectangles that were ready to be drawn onto a screen:\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"haskell\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-haskell\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-haskell\"\n  }, \"    \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"[\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"(\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token constant\"\n  }, \"Just\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"(\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token constant\"\n  }, \"Rect\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token hvariable\"\n  }, \"x\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token number\"\n  }, \"25\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token number\"\n  }, \"50\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token number\"\n  }, \"50\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \")\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \")\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"|\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token hvariable\"\n  }, \"x\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"<-\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"[\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token number\"\n  }, \"1\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"..\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token number\"\n  }, \"450\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"]\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"]\")))), mdx(\"p\", null, \"and for each one of those I would want to draw it on the screen, hence I prepared myself this function:\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"haskell\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-haskell\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-haskell\"\n  }, \"\\t\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token hvariable\"\n  }, \"fillDo\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token hvariable\"\n  }, \"canvas\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token hvariable\"\n  }, \"rect\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"=\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token keyword\"\n  }, \"do\"), \" \\n\\t \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token hvariable\"\n  }, \"FX.fillRect\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token hvariable\"\n  }, \"canvas\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token constant\"\n  }, \"Nothing\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"(\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token constant\"\n  }, \"Pixel\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token number\"\n  }, \"0\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \")\"), \"\\n\\t \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token hvariable\"\n  }, \"FX.fillRect\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token hvariable\"\n  }, \"canvas\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token hvariable\"\n  }, \"rect\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"(\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token constant\"\n  }, \"Pixel\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token number\"\n  }, \"0xFFFFFF\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \")\"), \"\\n\\t \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token constant\"\n  }, \"FX\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \".\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token builtin\"\n  }, \"flip\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token hvariable\"\n  }, \"canvas\")))), mdx(\"h2\", null, \"The do-notation\"), mdx(\"p\", null, \"all SDL operations happen in the IO monad, which can be seen nicely when we look at the type of the involved functions:\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"haskell\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-haskell\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-haskell\"\n  }, \"    \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token hvariable\"\n  }, \"FX.fillRect\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"::\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token constant\"\n  }, \"Surface\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"->\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token constant\"\n  }, \"Maybe\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token constant\"\n  }, \"Rect\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"->\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token constant\"\n  }, \"Pixel\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"->\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token constant\"\n  }, \"IO\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token constant\"\n  }, \"Bool\"), \"\\n    \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token constant\"\n  }, \"FX\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \".\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token builtin\"\n  }, \"flip\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"::\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token constant\"\n  }, \"Surface\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"->\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token constant\"\n  }, \"IO\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"(\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \")\")))), mdx(\"p\", null, \"If we want to work with them, we will need to work in that context ourselves. Haskell has a number of functions to work with Monads, one of them being \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"(>>)\"), \". Its type is\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"haskell\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-haskell\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-haskell\"\n  }, \"    \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"(\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \">>\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \")\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"::\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token constant\"\n  }, \"Monad\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token hvariable\"\n  }, \"m\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"=>\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token hvariable\"\n  }, \"m\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token hvariable\"\n  }, \"a\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"->\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token hvariable\"\n  }, \"m\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token hvariable\"\n  }, \"b\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"->\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token hvariable\"\n  }, \"m\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token hvariable\"\n  }, \"b\")))), mdx(\"sup\", null, \"*) Within the same monad, given a one-in, one-out function, return the output of the function\"), mdx(\"p\", null, \"It looks and sounds trivial, but actually allows to chain functions together that happen in the same context. i.e. something like\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"haskell\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-haskell\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-haskell\"\n  }, mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token comment\"\n  }, \"-- putStr :: String -> IO ()\"), \"\\n\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token builtin\"\n  }, \"putStr\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token string\"\n  }, \"\\\"Hello\\\"\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \">>\"), \" \\n\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token builtin\"\n  }, \"putStr\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token string\"\n  }, \"\\\" \\\"\"), \"\\n\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token comment\"\n  }, \"--becomes\"), \"\\n\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token keyword\"\n  }, \"do\"), \"\\n\\t\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token builtin\"\n  }, \"putStr\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token string\"\n  }, \"\\\"Hello\\\"\"), \"\\n\\t\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token builtin\"\n  }, \"putStr\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token string\"\n  }, \"\\\" \\\"\")))), mdx(\"h2\", null, \"List + fillDo = ...\"), mdx(\"p\", null, \"My initial attempt was to take my list of Rectangles and map the fillDo over it:\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"text\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-text\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\"\n  }, \"map (fillDo canvas) [(Just (Rect x 25 50 50)) | x <- [1..450]]\"))), mdx(\"p\", null, \"Note the use of currying - (fillDo canvas) returns a function that takes a rect as a parameter and returns \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IO ()\"), \".\"), mdx(\"p\", null, \"Alas, it wouldn't compile. After some thinking and googling, the issue dawned on me: every function inside a do block\\nmust return into the same context with which we started off. Alas, the last line of code did not return an \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IO sth\"), \", but\\nrather \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"[IO sth]\"), \", an array of things in the IO context. What I wanted was actually \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IO \", \"[sth]\"), \".\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Once you get the hang out of it, Haskell errors can be quite understandable. This one was...\")), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"cli\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-cli\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cli\"\n  }, \"Couldn't match expected type `IO a0' with actual type `[b0]'\\nIn the return type of a call of `map'\\nIn a stmt of a 'do' block:\\n... \"))), mdx(\"p\", null, \"Thankfully there is a version of \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"map\"), \" with the kind of signature that we need:\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"text\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-text\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\"\n  }, \"mapM :: Monad m => (a -> m b) -> [a] -> m [b]\"))), mdx(\"sup\", null, \"*) Given a function taking a's and returning b's within m and an array of a's, give me the resulting array of b's, within the m context\"), mdx(\"p\", null, \"Bingo, small change and here's the full program:\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"haskell\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-haskell\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-haskell\"\n  }, mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token keyword\"\n  }, \"module\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token constant\"\n  }, \"Main\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token keyword\"\n  }, \"where\"), \"\\n\\n\\t\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token import-statement\"\n  }, mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"token keyword\"\n  }, \"import\"), \" Graphics.UI.SDL \", mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"token keyword\"\n  }, \"as\"), \" FX\"), \"\\n\\n\\t\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token hvariable\"\n  }, \"main\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"::\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token constant\"\n  }, \"IO\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"(\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \")\"), \"\\n\\t\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token hvariable\"\n  }, \"main\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"=\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token keyword\"\n  }, \"do\"), \"\\n\\t\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token builtin\"\n  }, \"init\"), \"\\n\\t\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token hvariable\"\n  }, \"canvas\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"<-\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token hvariable\"\n  }, \"FX.getVideoSurface\"), \"\\n\\t\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token builtin\"\n  }, \"mapM\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"(\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token hvariable\"\n  }, \"fillDo\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token hvariable\"\n  }, \"canvas\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \")\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"[\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token constant\"\n  }, \"Rect\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token hvariable\"\n  }, \"x\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token number\"\n  }, \"25\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token number\"\n  }, \"50\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token number\"\n  }, \"50\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"|\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token hvariable\"\n  }, \"x\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"<-\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"[\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token number\"\n  }, \"1\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"..\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token number\"\n  }, \"450\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"]\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"]\"), \"\\n\\t\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token hvariable\"\n  }, \"delay\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token number\"\n  }, \"1000\"), \"\\n\\t\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token hvariable\"\n  }, \"FX.quit\"), \"\\n\\t\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token keyword\"\n  }, \"where\"), \"\\n\\t\\t\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token hvariable\"\n  }, \"fillDo\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token hvariable\"\n  }, \"canvas\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token hvariable\"\n  }, \"rect\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"=\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token keyword\"\n  }, \"do\"), \" \\n\\t\\t\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token hvariable\"\n  }, \"FX.fillRect\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token hvariable\"\n  }, \"canvas\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token constant\"\n  }, \"Nothing\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"(\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token constant\"\n  }, \"Pixel\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token number\"\n  }, \"0\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \")\"), \"\\n\\t\\t\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token hvariable\"\n  }, \"FX.fillRect\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token hvariable\"\n  }, \"canvas\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"(\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token constant\"\n  }, \"Just\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token hvariable\"\n  }, \"rect\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \")\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"(\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token constant\"\n  }, \"Pixel\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token number\"\n  }, \"0xFFFFFF\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \")\"), \"\\n\\t\\t\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token constant\"\n  }, \"FX\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \".\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token builtin\"\n  }, \"flip\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token hvariable\"\n  }, \"canvas\"), \"\\n\\t\\t\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token builtin\"\n  }, \"init\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"=\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token keyword\"\n  }, \"do\"), \"\\n\\t\\t\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token constant\"\n  }, \"FX\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \".\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token builtin\"\n  }, \"init\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"[\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token constant\"\n  }, \"InitVideo\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"]\"), \"\\n\\t\\t\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token hvariable\"\n  }, \"FX.setVideoMode\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token number\"\n  }, \"640\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token number\"\n  }, \"480\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token number\"\n  }, \"32\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"[\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"]\")))), mdx(\"p\", null, \"So far I do not want to go full steam ahead and implement the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"logic/render/repeat\"), \" thing, since, to be honest, I don't quite see where this is heading. Even so,  there is some potential looming for separating logic from rendering as the production of the rectangle \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"\\\"path\\\"\"), \" can be looked at independent of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"IO\"), \". \"), mdx(\"h3\", null, \"PS\"), mdx(\"p\", null, \"we saved ourselves the \\\"white smear\\\" stage by adding that canvas cleaning code in the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"fillDo\"), \" (\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"FX.fillRect canvas Nothing (Pixel 0)\"), \")\"));\n}\n;\nMDXContent.isMDXComponent = true;","fields":{"slug":"/2013/09/19/funspins-moving-a-rectangle"},"frontmatter":{"date":"2013-09-19","path":null,"title":"FunSpIns - Moving a Rectangle","tags":["programming","haskell"]}}},"pageContext":{"title":"FunSpIns - Moving a Rectangle","previous":{"fields":{"slug":"/2013/09/18/funspins-drawing-a-rectangle","published":true},"frontmatter":{"title":"FunSpIns - Drawing a Rectangle","tags":["programming","haskell"],"date":"2013/09/18"}},"next":{"fields":{"slug":"/2013/09/20/funspins-no-attributes-no-vectors-a-tiny-workflow-and-more-squares","published":true},"frontmatter":{"title":"FunSpIns - No attributes, No vectors, A tiny Workflow and more squares","tags":["programming","haskell"],"date":"2013/09/20"}}}},"staticQueryHashes":["256249292","2581731408"]}