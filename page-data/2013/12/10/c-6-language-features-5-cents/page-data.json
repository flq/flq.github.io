{
    "componentChunkName": "component---src-templates-article-template-js",
    "path": "/2013/12/10/c-6-language-features-5-cents",
    "result": {"data":{"mdx":{"excerpt":"C#6 It looks like C# designers are beginning to fire their engines with regard to what language features would bring benefit to programmersâ€¦","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"C# 6 language features? 5 cents.\",\n  \"layout\": \"post\",\n  \"tags\": [\"csharp\"],\n  \"date\": \"2013-12-10T14:00:00.000Z\",\n  \"redirect_from\": \"/go/239/\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h2\", null, \"C#6\"), mdx(\"p\", null, \"It looks like C# designers are beginning to fire their engines with regard to what language features would bring benefit to programmers. Apparently there was a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://channel9.msdn.com/Forums/Coffeehouse/Mads-Torgersen--NDC-London--The-Future-of-C\"\n  }, \"presentation on NDCLondon\"), \", followed by \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://damieng.com/blog/2013/12/09/probable-c-6-0-features-illustrated\"\n  }, \"a reaction over here\"), \".\"), mdx(\"p\", null, \"Apart from the fact that every new language feature also complicates the programming (more choices, more ways that programmers misunderstand each other), there is always a call for reducing boilerplate code.\"), mdx(\"p\", null, \"There is some useful stuff in there, I would think. I especially like the idea to be able to import a static class such that its methods become available as first-class citizens.\"), mdx(\"p\", null, \"What I do miss is some way to define \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"records\"), \" as they are known in \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"F#\"), \".\"), mdx(\"p\", null, \"For your reference, an example how it could look in C#:\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"text\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-text\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\"\n  }, \"class Customer = { \\n  First : string; \\n  Last: string; \\n  SSN: uint32; \\n  AccountNumber : uint32; \\n}\"))), mdx(\"p\", null, \"this gives you\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A class with a constructor which accepts all fields to fill the defined properties\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"All properties being read-only\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Equality implementations based on the properties defined inside.\")), mdx(\"p\", null, \"I would find this useful in many cases.\"), mdx(\"h2\", null, \"Constructors are methods\"), mdx(\"p\", null, \"One thing I find annoying is that I cannot treat a constructor as a method group. If C# had chosen a ctor syntax  + instantiation somewhat like ruby...\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"text\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-text\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\"\n  }, \"class Customer {\\n  public new(string name) { ... }\\n}\\n\\nvar c = Customer.new(\\\"Arthur\\\")\"))), mdx(\"p\", null, \"Then this syntax would lend easily to a statement like that\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"text\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-text\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\"\n  }, \"DB.Query<Name>().Select(Customer.new) // instead of (s => new Customer(s))\"))), mdx(\"p\", null, \"Not sure what the right approach would be for C# but it sure would help in my code ;)\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"PS\"), \"\\n\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Yes, I know you can fake it with statics, but it would become a guidebook definition for what boilerplate code is.\")), mdx(\"h2\", null, \"Structural typing\"), mdx(\"p\", null, \"Apparently this is \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"\\\"on the radar\\\"\"), \" - many people probably mean different things with that, my personal interpretation is something like\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"text\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-text\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\"\n  }, \"class Event1 = {\\n  long CorrelationId;\\n}\\n\\nclass Event2 = {\\n  long CorrelationId;\\n}\\n\\n// Structural Typing:\\npublic void DoCorrelationStuff<T>(T thing) where T : { long CorrelationId; } \\n{\\n  Debug.WriteLine(thing.CorrelationId);\\n}\\n\\n//Can be used like\\nDoCorrelationStuff(new Event1(12334343));\\nDoCorrelationStuff(new Event1(15334746));\"))), mdx(\"p\", null, \"We shall see how far off I am ;)\"), mdx(\"h2\", null, \"dot-Ask\"), mdx(\"p\", null, \"to me the whole thing of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"customer.?address.?street\"), \" feels a bit like a Hack to live with nulls. Granted, it doesn't look like we can get rid of them in the C# world, but a pure API solution introducing a Maybe type can have a positive impact on your programming style and is more powerful than the proposed operator.\\nThe reason being that with null things you don't only want to access it, but do stuff with it, cast it, etc. - If you introduce that operator I think it could open a can of worms.\"), mdx(\"h1\", null, \"Pure functions\"), mdx(\"p\", null, \"This is something I've never heard off but which could be interesting from optimization perspectives (mark it experimental).\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"text\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-text\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\"\n  }, \"private double _foo;\\n\\npublic pure double Bla(double val) {\\n  //Compute something out of val.\\n  Debug.WriteLine(_foo); //Error: Cannot read state outside of a pure scope.\\n}\"))), mdx(\"p\", null, \"The idea is something borrowed from Haskell. However, while in Haskell purity is opt-out, I would define it as opt-in. This would mean for a method, that\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"It can only use stuff that gets passed into the method (no instance vars or any other state)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"It can only call methods that are also declared as pure.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[It cannot return null]\", \".\")), mdx(\"p\", null, \"This could lead to \"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"simpler parallelism primitives as pure functions make strong guarantees about their idempotency, reentrability, etc.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Maybe things like memoizations..?\")), mdx(\"p\", null, \"This concludes today's trip to fantasyland, off to the nitty-gritty of finding a new job!\"));\n}\n;\nMDXContent.isMDXComponent = true;","fields":{"slug":"/2013/12/10/c-6-language-features-5-cents"},"frontmatter":{"date":"2013-12-10","path":null,"title":"C# 6 language features? 5 cents.","tags":["csharp"]}}},"pageContext":{"title":"C# 6 language features? 5 cents.","previous":{"fields":{"slug":"/2013/11/11/we-became-impatient","published":true},"frontmatter":{"title":"We became impatient","tags":["loosely-coupled"],"date":"2013/11/11"}},"next":{"fields":{"slug":"/2013/12/25/membus-3-0","published":true},"frontmatter":{"title":"MemBus 3.0","tags":["own-software","membus"],"date":"2013/12/25"}}}},
    "staticQueryHashes": ["256249292","2581731408"]}