{"componentChunkName":"component---src-templates-article-template-js","path":"/2008/05/22/some-more-on-the-implicit-operator","result":{"data":{"markdownRemark":{"html":"<p>Elaborating on my <a href=\"/go/104\">past post</a> on the implicit operator in C#, here some additional information to round this thing up.</p>\n<ul>\n<li>Can you inherit the implicit operator(s)? </li>\n</ul>\n<p> No, you cannot. Within a type you could write as many implicit operator implementations as you like, but any of the two types referenced must be the enclosing type. The compiler will tell you that:\n<code class=\"language-text\">error CS0556: User-defined conversion must convert to or from the enclosing type</code>  </p>\n<p>As an example:</p>\n  <pre class=\"sh_csharp\">\n  class Foo\n  {\n    string Value { get; set; }\n\n    public static implicit operator string(Foo theFoo)\n    {\n      return theFoo.Value;\n    }\n\n    public static implicit operator Foo(string theValue)\n    {\n      return new Foo() { Value = theValue };\n    }\n  }\n\n  class Bar : Foo {\n  }\n</pre>\n<p>The type \"Bar\" cannot do anything with the operators defined on \"Foo\", hence you cannot write</p>\n<p><code class=\"language-text\">Bar b = &quot;hi&quot;;</code></p>\n<p>What compiles is this:</p>\n<p><code class=\"language-text\">Bar b = (Bar)(Foo)&quot;hi&quot;;</code></p>\n<p>But, as you might have guessed, you will get a runtime error. A \"Foo\" instance cannot be cast to\na \"Bar\" instance.</p>\n<ul>\n<li>Any chance to do that with generics?</li>\n</ul>\n<p>This contrived example will not work either:</p>\n<p>`\nclass Implicitable&#x3C;T, V> where V : Implicitable&#x3C;T,V>\n{\nT Value { get; set; }</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">public static implicit operator T(V theImplicitable)\n{\n  return theImplicitable.Value;\n}</code></pre></div>\n<p>  }\n`</p>\n<p>same error.</p>\n<p>A different restriction with its own error is when you would try this:</p>\n<p>`\nclass Bar : Foo\n{\npublic static implicit operator Foo(Bar theValue)\n{\nreturn new Bar() { Value = theValue };\n}\n}</p>\n<p>error CS0553: '...': user-defined conversions to or from a base class are not allowed\n`</p>\n<p>Which makes sense after all, as it kind of leads polymorphism ad absurdum.</p>\n<p>Lately I have come across a pattern where it appears useful to me to provide implicit operators.\nIt is the case for generic utility classes that enhance a given type in a sort of decorator style.\nYou can find an example here with the <a href=\"http://realfiction.net/go/153\">SingletonOf&#x3C;T></a>. Further examples are</p>\n<ul>\n<li>Monitored&#x3C;T> : It provides a decorator around a value of type T that, when changed through a property raises a ValueChanged event.</li>\n<li>Historized&#x3C;T> : It provides a decorator around a value of type T that keeps track in a Dictionary with timestamp when the value is changed and could be rolled back to some point in time.</li>\n</ul>\n<p>All of those provide this pattern:</p>\n<p>`\nclass Utility<T>\n{\nT Value { get; set; }</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">public static implicit operator T(Utility&lt;T&gt; u)\n{\n  return u.Value;\n}\n\npublic static implicit operator Utility&lt;T&gt;(T theValue)\n{\n  return new Utility&lt;T&gt;() { Value = theValue };\n}</code></pre></div>\n<p>  }\n`</p>\n<p>The boilerplate enables a simple instantiation like Utility&#x3C;int> i = 3; as well as enables the Utility\nto behave pretty much like the type it decorates, e.g. z = i + 5;\nHowever, that is at far as it goes. To actually enable their additional behaviour you will have to keep\nthe reference alive:</p>\n<p><code class=\"language-text\">Utility&lt;int&gt; i = 3;\ni = 5; //bad\ni.Value = 7; // good</code></p>\n<p>That's it for now. Next time, the explicit operator :)</p>","fields":{"slug":"/2008/05/22/some-more-on-the-implicit-operator"},"frontmatter":{"date":"May 22, 2008","path":null,"title":"Some more on the implicit operator","tags":["software-development","dotnet"]}}},"pageContext":{"title":"Some more on the implicit operator","previous":{"fields":{"slug":"/2008/05/20/a-simple-way-to-start-your-code-in-a-different-appdomain","published":true},"frontmatter":{"title":"A simple way to start your code in a different AppDomain","tags":["software-development","dotnet"],"date":"2008/05/20"}},"next":{"fields":{"slug":"/2008/06/16/wpf-inotifypropertychanged-proxy-success","published":true},"frontmatter":{"title":"WPF + INotifyPropertyChanged Proxy = success!","tags":["dotnet","libs-and-frameworks"],"date":"2008/06/16"}}}}}