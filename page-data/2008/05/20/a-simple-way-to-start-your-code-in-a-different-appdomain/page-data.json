{"componentChunkName":"component---src-templates-article-template-js","path":"/2008/05/20/a-simple-way-to-start-your-code-in-a-different-appdomain","result":{"data":{"markdownRemark":{"html":"<p>You may know that AppDomains in the .Net Framework are comparable to processes in that they provide an isolated execution context for the instructions executed by the CLR. However, they are also quite lightweight and what is more, you can have more than one inside an actual OS process in which a given CLR Host is running. Usually our code gets executed in a default AppDomain and we do not care about additional ones. Why should you care about AppDomains at all?</p>\n<p>Well, </p>\n<ul>\n<li>Do you have a system complex enough that you want to have subsystems with defined responsibilities and clear interfaces to the outside?</li>\n<li>Can your subsystems churn away on their work without them having to interfere with each other beyond what would be a typical service-style interface?</li>\n<li>Do you want to be able to let parts of the application run under different Security contexts?</li>\n<li>Could any of the subsystems hang up so badly that you need to completely destroy the context that was running said part of the code?</li>\n<li>Are you considering to deploy more than one executable as part of the complete application?</li>\n<li>...</li>\n</ul>\n<p>If you can answer any or all of the questions with yes, chances are that AppDomains may be useful to you.</p>\n<p>Especially if question 3 gets a yes, you may just want want to start an AppDomain as if it were some other executable. This is easily done with the following code:</p>\n<p><code class=\"language-text\">AppDomain dmn = AppDomain.CreateDomain(&quot;mydomain&quot;);\ndmn.ExecuteAssembly(&quot;MyExe.exe&quot;);</code></p>\n<p>Your executable will need an entry point as e.g. a Console application would have. This scenario does not give you a lot of advantage towards just starting the executable. If you want to e.g. instantiate a WCF ServiceHost in the other domain, you may still need to block the entry point in order for your executable to stay alive.\nThe following code allows you to specify a hook, an entry point much like an application entry point, however, you do not need to deal with the following:</p>\n<ul>\n<li>Your entry point stays alive as long as the AppDomain in which it lives is alive.</li>\n<li>Your entry point is called whenever the AppDomain it lives in unloads.</li>\n<li>Your entry point does not have to live in a different assembly than the one from which you create a new AppDomain.</li>\n</ul>\n<p>The AppDomainExpander does that...</p>\n<p>`\nclass AppDomainExpander<T> where T : DomainLifetimeHook, new()\n{\npublic void Create()\n{\nCreate(Guid.NewGuid().ToString());\n}</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">public void Create(string domainName) {\n    AppDomain dmn = AppDomain.CreateDomain(domainName);\n    string typename = typeof(DomainCommunicator).FullName;\n    string assemblyName = typeof(DomainCommunicator).Assembly.FullName;\n    var inner = (DomainCommunicator)dmn.CreateInstanceAndUnwrap(assemblyName, typename);\n    inner.Create();\n}</code></pre></div>\n<p>}\n`</p>\n<p>You can see that the code refers to a DomainCommunicator, which is a private inner class of the Expander. I will come to this type in a minute.</p>\n<p>When you instantiate the Expander you need to provide a type argument that specifies something that derives from the DomainLifetimeHook. That type looks as follows:</p>\n<p><code class=\"language-text\">abstract class DomainLifetimeHook\n{\n  internal abstract void Start();\n  internal abstract void Stop();\n}</code></p>\n<p>Those methods will already be called inside the new AppDomain, namely when it fires up and when it Unloads.\nThe DomainCommunicator then is the class that gets instantiated in the new AppDomain. Since it is an inner class of the Expander it can easily refer to the type argument provided during its instantiation. The generic constraint that T has a default constructor allows the communicator to create an instance of it and call its start method in the beginning.</p>\n<p>By attaching the event handler to the AppDomain Unload event two things are achieved: There is a defined point when Stop is called on the instantiated Hook and the DomainCommunicator instance is being referenced by the newly created AppDomain. Since T is an instance variable of the Communicator, Ts lifetime is now driven by the AppDomain:</p>\n<p>`\nclass DomainCommunicator : MarshalByRefObject\n{\nT domainHook;</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    public void Create()\n    {\n        domainHook = new T();\n        // Attaching the handler is enough to keep a reference to ourselves\n        // which in turn keeps T alive...\n        AppDomain.CurrentDomain.DomainUnload += new EventHandler(OnDomainUnload);\n        domainHook.Start();\n    }\n\n    void OnDomainUnload(object sender, EventArgs e)\n    {\n        domainHook.Stop();\n        // ...until the Domain dies: dereference myself to be more explicit\n        AppDomain.CurrentDomain.DomainUnload -= new EventHandler(OnDomainUnload);\n    }\n}</code></pre></div>\n<p>`</p>\n<p>Now, letting code run in a different AppDomain is as easy as writing this:</p>\n<p><code class=\"language-text\">var expander = new AppDomainExpander&lt;DataPointMSMQHook&gt;();\nexpander.Create();</code></p>","fields":{"slug":"/2008/05/20/a-simple-way-to-start-your-code-in-a-different-appdomain"},"frontmatter":{"date":"May 20, 2008","path":null,"title":"A simple way to start your code in a different AppDomain","tags":["software-development","dotnet"]}}},"pageContext":{"title":"A simple way to start your code in a different AppDomain","previous":{"fields":{"slug":"/2008/05/13/lazy-instantiation-one-liner-of-instance-fields-with-the-coalesce-operator","published":true},"frontmatter":{"title":"Lazy instantiation one-liner of instance fields with the coalesce operator","tags":["software-development","dotnet"],"date":"2008/05/13"}},"next":{"fields":{"slug":"/2008/05/22/some-more-on-the-implicit-operator","published":true},"frontmatter":{"title":"Some more on the implicit operator","tags":["software-development","dotnet"],"date":"2008/05/22"}}}}}