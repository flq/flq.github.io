{"componentChunkName":"component---src-templates-article-template-js","path":"/2008/06/25/so-how-expensive-is-it-to-let-ninject-make-my-object","result":{"data":{"mdx":{"excerpt":"Back  here  I made a quick and dirty performance comparison. In the comments I actually got some \"flak\" scrutinizing some of the \"design decisionsâ€¦","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"So, how expensive is it to let NInject make my object?\",\n  \"layout\": \"post\",\n  \"tags\": [\"software-development\", \"dotnet\", \"patterns\", \"libs-and-frameworks\"],\n  \"date\": \"2008-06-25T13:11:57.000Z\",\n  \"redirect_from\": \"/go/127/\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Back \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://realfiction.net/go/143\"\n  }, \"here\"), \" I made a quick and dirty performance comparison. In the comments I actually got some \\\"flak\\\" scrutinizing some of the \\\"design decisions\\\" behind the example shown. I would like to reinstate that the example was made purely for checking instantiation performance of IoC container, and that I could not be asked to use \\\"Foo\\\" and \\\"Bar\\\" or \\\"Samurai\\\" and \\\"Sword\\\" (\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://dojo.ninject.org/wiki/display/NINJECT/Dependency+Injection+With+Ninject\"\n  }, \"no worries, Nate\"), \" ;)\"), mdx(\"p\", null, \"I was pointed to the injection container \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://ninject.org/\"\n  }, \"NInject\"), \", and how the benchmark would look like when using this framework. Now that said framework has been released with a v 1.0 tag (you've got to love it just for doing that, after all, there are customers out there that you simply cannot approach with a v0.9 or a release candidate 3) I took the time to play through the code.\"), mdx(\"p\", null, \"Instead of using an XML-file you perform a programmatic binding within a special class that is treated by the kernel as a module:\"), mdx(\"p\", null, mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"  class BankAccountModule : StandardModule\\n  {\\n    public override void Load()\\n    {\\n      Bind<IExchangeRateEngine>().To<SimpleExchangeRateEngine>();\\n      Bind<BankAccount>().ToSelf();\\n    }\\n  }\")), mdx(\"p\", null, \"Instantiation of the kernel looks like this:\"), mdx(\"p\", null, mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"IKernel c = new Ninject.Core.StandardKernel(new BankAccountModule());\")), mdx(\"p\", null, \"And getting a BankAccount reference looks like that:\"), mdx(\"p\", null, mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"BankAccount acc = c.Get<BankAccount>();\")), mdx(\"p\", null, \"The time we get (for reference the Spring.NET time run today as well)\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Container construction (Spring.NET): 0.0535 / 0.0459\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Container construction (NInject): 0.0298 / 0.0293\")), mdx(\"p\", null, \"So, performance-wise NInject shows benefits due to its approach of generating dynamic methods. This is certainly not the last post on NInject as it makes a very good first impression and I need to delve a bit into some question marks.\"));\n}\n;\nMDXContent.isMDXComponent = true;","fields":{"slug":"/2008/06/25/so-how-expensive-is-it-to-let-ninject-make-my-object"},"frontmatter":{"date":"2008-06-25","path":null,"title":"So, how expensive is it to let NInject make my object?","tags":["software-development","dotnet","patterns","libs-and-frameworks"]}}},"pageContext":{"title":"So, how expensive is it to let NInject make my object?","previous":{"fields":{"slug":"/2008/06/16/wpf-inotifypropertychanged-proxy-success","published":true},"frontmatter":{"title":"WPF + INotifyPropertyChanged Proxy = success!","tags":["dotnet","libs-and-frameworks"],"date":"2008/06/16"}},"next":{"fields":{"slug":"/2008/07/31/dont-be-afraid-of-your-csproj-files-i-embracing-the-idea","published":true},"frontmatter":{"title":"Don't be afraid of your csproj-Files (I): Embracing the idea","tags":["software-development","msbuild"],"date":"2008/07/30"}}}},"staticQueryHashes":["256249292","2581731408"]}