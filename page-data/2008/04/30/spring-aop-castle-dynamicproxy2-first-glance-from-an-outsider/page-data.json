{"componentChunkName":"component---src-templates-article-template-js","path":"/2008/04/30/spring-aop-castle-dynamicproxy2-first-glance-from-an-outsider","result":{"data":{"mdx":{"excerpt":"The other day I got a presentation on Spring.NET and that it brings along quite a bit of aspect oriented Zen. My weapon of choice lately: Castleâ€¦","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Spring.AOP, Castle.DynamicProxy2 - first glance from an outsider\",\n  \"layout\": \"post\",\n  \"tags\": [\"dotnet\", \"libs-and-frameworks\"],\n  \"date\": \"2008-04-30T20:24:37.000Z\",\n  \"redirect_from\": \"/go/120/\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"The other day I got a presentation on Spring.NET and that it brings along quite a bit of aspect oriented Zen. My weapon of choice lately: Castle Windsor. Part of the project is the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Castle.DynamicProxy2\"), \" (what a name!). It provides a functionality that is similar to the one you can extract from the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Spring.AOP\"), \" Assembly.\"), mdx(\"p\", null, \"Leaving the funny word \\\"aspect\\\" behind, what do those funny named assemblies give us? They allow to generate \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"proxies\"), \" around our own objects and provide a way to inject behaviour every time our object is used, i.e. when properties / methods are accessed. Injecting behaviour means in both cases to provide a class that implements a specific interface which is passed to the proxy generator. From here on the generated proxy will call your \\\"\", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Interceptor\"), \"\\\" every time the encapsulated object is being used\"), mdx(\"p\", null, \"While I do not know where Spring.AOP is used, I know that the DynamicProxy2 assembly enables \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://www.hibernate.org/343.html\"\n  }, mdx(\"strong\", {\n    parentName: \"a\"\n  }, \"NHibernate\")), \" to let us use our domain objects as if they would be the plain thing but when brought to the session magically seem to remember the changes we do to them.\"), mdx(\"p\", null, \"You may also stumble upon another fantastic project with plenty of Mojo in it, Ayende/Oren's delicious and moist mocking tool, \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://www.ayende.com/projects/rhino-mocks/downloads.aspx\"\n  }, \"Rhino Mocks\"), \". You will see that the assembly contains the namespaces relevant to the Dynamicproxy2 - brought in there either via \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://research.microsoft.com/~mbarnett/ILMerge.aspx\"\n  }, \"ILMerge\"), \" or just getting the source and compiling it all together. It enables to generate a proxy for some interface / abstract class and by design provide an entry point to whenever such a generated proxy is being used by referencing a property or method. Ayende can then use this to build up his recording/playback/expectations framework.\"), mdx(\"p\", null, \"For this post I set up a simple project referencing both assemblies like that:\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"files/images/referencesProxies.png\",\n    \"alt\": \"Project references\"\n  })), mdx(\"p\", null, \"My aim was to get first a basic feeling what it costs performance-wise to create a proxy for some object, adding an interceptor to it and then accessing methods and properties on it. For that I created the HorridPerson class, a class so ugly, even VBA programmers may run away screaming:\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"files/images/horridPersonProxies.png\",\n    \"alt\": \"A yucky class\"\n  })), mdx(\"p\", null, \"The use of interceptors is normally comfortably accessible from within the framework of Spring.Net/Castle Windsor. The documentation how the proxy generators should be used is not readily available. Best bet in such a case are the relevant test cases. With both projects being open source and providing a decent suite of test cases, there is no excuse in not figuring out how some part of a system is meant to be used.\"), mdx(\"p\", null, \"Another infrastructural part is a wrapper to the StopWatch that allows us to get some performance pointers. For starters, we do the test with just the object without any proxies or interceptors:\"), mdx(\"p\", null, mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"      IHorridPerson p = new HorridPerson();\\n      p.AddAddress(\\\"Hurlistreet\\\", \\\"Z\\xFCrich\\\", \\\"23\\\", \\\"3232\\\", \\\"CH\\\");\\n      Console.WriteLine(p.City);\\n      Console.WriteLine(p.ReturnBirthDate()); \")), mdx(\"p\", null, \"Measuring the performance of it looks like that:\"), mdx(\"p\", null, mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"using (var s = new SimpleStopWatch(\\\"Standard Test\\\"))\\n{\\n  tests.Standard.Test(s);\\n}\")), mdx(\"p\", null, \"(Today) the code needs about 2ms in the first run, and about 1ms in subsequent runs. I say today, because yesterday the code was running a lot slower on the whole (e,g, 10ms in the first run). I am running it from the debugger, but all tests done have to live with that problem, which seems fair to me.\"), mdx(\"p\", null, \"What about DynamicProxy2? Here we need a slightly different setup:\"), mdx(\"p\", null, mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"public void Test(SimpleStopWatch sw)\\n{\\n  ProxyGenerator gen = new ProxyGenerator(new DefaultProxyBuilder());\\n  sw.Ping(\\\"After proxygen\\\");\\n  IHorridPerson p = gen.CreateInterfaceProxyWithTarget<IHorridPerson>(new HorridPerson(),\\n    new SimpleInterceptor());\\n  sw.Ping(\\\"After create class proxy\\\");\\n  p.AddAddress(\\\"Hurlistreet\\\", \\\"Z\\xFCrich\\\", \\\"23\\\", \\\"3232\\\", \\\"CH\\\");\\n  sw.Ping();\\n  Console.WriteLine(p.City);\\n  sw.Ping();\\n  Console.WriteLine(p.ReturnBirthDate()); \\n}\")), mdx(\"p\", null, \"The interesting bits are at the beginning. It also shows one of the things one needs to have to create a proxy: The proxied class should implement an interface which we can use to talk to whatever implements said interface, or, in the case of DynamicProxy2, we can create a class whose members are all virtual. That way an inheriting class can override all members in a controllable fashion that does not resort to some kind of reflection.\\nThe SimpleInterceptor is one that logs before and after invoking the object usage it is currently intercepting:\"), mdx(\"p\", null, \"`\\nclass SimpleInterceptor : IInterceptor\\n{\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"text\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-text\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\"\n  }, \"public void Intercept(IInvocation invocation)\\n{\\n  Console.WriteLine(\\\"Before proceed\\\");\\n  invocation.Proceed();\\n  Console.WriteLine(\\\"After proceed\\\");\\n}\"))), mdx(\"p\", null, \"  }\\n`\"), mdx(\"p\", null, \"The invocation holds all information about the current method call (e.g. Method Info, arguments, return value, etc.)\"), mdx(\"p\", null, \"Let's look straight at the output of the SimpleStopWatch:\"), mdx(\"p\", null, mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"::STOPWATCH/Dynamicproxy Test - (0ms) - Starting\\n::STOPWATCH/Dynamicproxy Test - (21ms) - After proxygen\\n::STOPWATCH/Dynamicproxy Test - (212ms) - After create class proxy\\nBefore proceed\\nAdding address\\nAfter proceed\\n::STOPWATCH/Dynamicproxy Test - (215ms) - Intermediate output\\nBefore proceed\\nCalling city property\\nAfter proceed\\n::STOPWATCH/Dynamicproxy Test - (217ms) - Intermediate output\\nBefore proceed\\nReturning birthdate\\nAfter proceed\\n30.04.2008 23:23:43\\n::STOPWATCH/Dynamicproxy Test - (220ms) - Ending\")), mdx(\"p\", null, \"And a second run, straight away:\"), mdx(\"p\", null, mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"::STOPWATCH/Dynamicproxy Test - (0ms) - Starting\\n::STOPWATCH/Dynamicproxy Test - (0ms) - After proxygen\\n::STOPWATCH/Dynamicproxy Test - (57ms) - After create class proxy\\nBefore proceed\\nAdding address\\nAfter proceed\\n::STOPWATCH/Dynamicproxy Test - (58ms) - Intermediate output\\nBefore proceed\\nCalling city property\\nAfter proceed\\n::STOPWATCH/Dynamicproxy Test - (61ms) - Intermediate output\\nBefore proceed\\nReturning birthdate\\nAfter proceed\\n30.04.2008 23:23:43\\n::STOPWATCH/Dynamicproxy Test - (64ms) - Ending\")), mdx(\"p\", null, \"One can see that we do pay for the usage of such a proxying scheme. While yesterday it looked a lot more extreme, the penalty today is still fairly high when comparing it to a normal object call. On the other hand, if the called methods actually do any meaningful work, the 3-4ms penalty per call may quickly dissipate. Also, it is quite apparent that once the proxy has been generated, it will be reused for other instances of the same type.\"), mdx(\"p\", null, \"Time is running out - Let us move swiftly to the Spring.AOP case. For brevity, just the first lines of the test case:\\n\", mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"public void Test(SimpleStopWatch sw)\\n{\\n  ProxyFactory factory = new ProxyFactory(new HorridPerson());\\n  sw.Ping(\\\"After factory\\\");\\n  factory.AddAdvice(new ConsoleLoggingAroundAdvice());\\n  sw.Ping(\\\"After AddAdvice\\\");\\n  IHorridPerson p = (IHorridPerson)factory.GetProxy();\\n  ...\")), mdx(\"p\", null, \"Looks slightly different and yet familiar...to make it complete here the \\\"Advice\\\":\"), mdx(\"p\", null, mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"public class ConsoleLoggingAroundAdvice : IMethodInterceptor\\n{\\n  public object Invoke(IMethodInvocation invocation)\\n  {\\n    Console.Out.WriteLine(\\\"Advice executing; calling the advised method...\\\");\\n    object returnValue = invocation.Proceed();\\n    Console.Out.WriteLine(\\\"Advice executed; advised method returned \\\" + returnValue);\\n    return returnValue;\\n  }\\n}\")), mdx(\"p\", null, \"And finally  the output:\"), mdx(\"p\", null, mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"::STOPWATCH/Spring Test - (0ms) - Starting\\n::STOPWATCH/Spring Test - (144ms) - After factory\\n::STOPWATCH/Spring Test - (148ms) - After AddAdvice\\n::STOPWATCH/Spring Test - (225ms) - After GetProxy\\nAdvice executing; calling the advised method...\\nAdding address\\nAdvice executed; advised method returned\\n::STOPWATCH/Spring Test - (245ms) - Intermediate output\\nAdvice executing; calling the advised method...\\nCalling city property\\nAdvice executed; advised method returned\\n::STOPWATCH/Spring Test - (248ms) - Intermediate output\\nAdvice executing; calling the advised method...\\nReturning birthdate\\nAdvice executed; advised method returned 30.04.2008 23:34:18\\n30.04.2008 23:34:18\\n::STOPWATCH/Spring Test - (252ms) - Ending\")), mdx(\"p\", null, \"And the second run straight away...\"), mdx(\"p\", null, mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"::STOPWATCH/Spring Test - (0ms) - Starting\\n::STOPWATCH/Spring Test - (0ms) - After factory\\n::STOPWATCH/Spring Test - (0ms) - After AddAdvice\\n::STOPWATCH/Spring Test - (1ms) - After GetProxy\\nAdvice executing; calling the advised method...\\nAdding address\\nAdvice executed; advised method returned\\n::STOPWATCH/Spring Test - (2ms) - Intermediate output\\nAdvice executing; calling the advised method...\\nCalling city property\\nAdvice executed; advised method returned\\n::STOPWATCH/Spring Test - (4ms) - Intermediate output\\nAdvice executing; calling the advised method...\\nReturning birthdate\\nAdvice executed; advised method returned 30.04.2008 23:34:18\\n30.04.2008 23:34:18\\n::STOPWATCH/Spring Test - (9ms) - Ending\")), mdx(\"p\", null, \"The second one was already quite quick. Spring.Net beats Castle Windsor when it comes to wiring up the proxy. The penalties on the method/property invocations are quite comparable. Either way, that should not be the main driver when you choose to use those assemblies to perform what people like to call aspect-oriented programming. It would interest me why the aforementioned projects chose DanymicProxy2 over the Spring.AOP solution. Either way, usually it's a good thing to have a choice, it's not like we .NET folks are usually spoiled with it (Microsoft's closest thing to the subject is ContextBoundObject: You will run away...)\"), mdx(\"p\", null, \"The solution (VS2008) is attached as download, you will have to provide the references yourself. Enjoy.\"), mdx(\"p\", null, \"[1]\", \": \"));\n}\n;\nMDXContent.isMDXComponent = true;","fields":{"slug":"/2008/04/30/spring-aop-castle-dynamicproxy2-first-glance-from-an-outsider"},"frontmatter":{"date":"2008-04-30","path":null,"title":"Spring.AOP, Castle.DynamicProxy2 - first glance from an outsider","tags":["dotnet","libs-and-frameworks"]}}},"pageContext":{"title":"Spring.AOP, Castle.DynamicProxy2 - first glance from an outsider","previous":{"fields":{"slug":"/2008/04/29/singletons-are-boring-hence-factor-out-the-concern","published":true},"frontmatter":{"title":"Singletons are boring, hence factor out the concern","tags":["software-development","dotnet","patterns"],"date":"2008/04/29"}},"next":{"fields":{"slug":"/2008/05/04/is-it-alright-to-send-messages-to-null-references","published":true},"frontmatter":{"title":"Is it alright to send messages to null references?","tags":["software-development","dotnet","patterns"],"date":"2008/05/04"}}}},"staticQueryHashes":["256249292","2581731408"]}