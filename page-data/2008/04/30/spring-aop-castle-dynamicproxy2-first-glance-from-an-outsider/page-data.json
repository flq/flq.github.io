{"componentChunkName":"component---src-templates-article-template-js","path":"/2008/04/30/spring-aop-castle-dynamicproxy2-first-glance-from-an-outsider","result":{"data":{"markdownRemark":{"html":"<p>The other day I got a presentation on Spring.NET and that it brings along quite a bit of aspect oriented Zen. My weapon of choice lately: Castle Windsor. Part of the project is the <strong>Castle.DynamicProxy2</strong> (what a name!). It provides a functionality that is similar to the one you can extract from the <strong>Spring.AOP</strong> Assembly.</p>\n<p>Leaving the funny word \"aspect\" behind, what do those funny named assemblies give us? They allow to generate <strong>proxies</strong> around our own objects and provide a way to inject behaviour every time our object is used, i.e. when properties / methods are accessed. Injecting behaviour means in both cases to provide a class that implements a specific interface which is passed to the proxy generator. From here on the generated proxy will call your \"<strong>Interceptor</strong>\" every time the encapsulated object is being used</p>\n<p>While I do not know where Spring.AOP is used, I know that the DynamicProxy2 assembly enables <a href=\"http://www.hibernate.org/343.html\"><strong>NHibernate</strong></a> to let us use our domain objects as if they would be the plain thing but when brought to the session magically seem to remember the changes we do to them.</p>\n<p>You may also stumble upon another fantastic project with plenty of Mojo in it, Ayende/Oren's delicious and moist mocking tool, <a href=\"http://www.ayende.com/projects/rhino-mocks/downloads.aspx\">Rhino Mocks</a>. You will see that the assembly contains the namespaces relevant to the Dynamicproxy2 - brought in there either via <a href=\"http://research.microsoft.com/~mbarnett/ILMerge.aspx\">ILMerge</a> or just getting the source and compiling it all together. It enables to generate a proxy for some interface / abstract class and by design provide an entry point to whenever such a generated proxy is being used by referencing a property or method. Ayende can then use this to build up his recording/playback/expectations framework.</p>\n<p>For this post I set up a simple project referencing both assemblies like that:</p>\n<p><img src=\"files/images/referencesProxies.png\" alt=\"Project references\"></p>\n<p>My aim was to get first a basic feeling what it costs performance-wise to create a proxy for some object, adding an interceptor to it and then accessing methods and properties on it. For that I created the HorridPerson class, a class so ugly, even VBA programmers may run away screaming:</p>\n<p><img src=\"files/images/horridPersonProxies.png\" alt=\"A yucky class\"></p>\n<p>The use of interceptors is normally comfortably accessible from within the framework of Spring.Net/Castle Windsor. The documentation how the proxy generators should be used is not readily available. Best bet in such a case are the relevant test cases. With both projects being open source and providing a decent suite of test cases, there is no excuse in not figuring out how some part of a system is meant to be used.</p>\n<p>Another infrastructural part is a wrapper to the StopWatch that allows us to get some performance pointers. For starters, we do the test with just the object without any proxies or interceptors:</p>\n<p><code class=\"language-text\">IHorridPerson p = new HorridPerson();\n      p.AddAddress(&quot;Hurlistreet&quot;, &quot;Zürich&quot;, &quot;23&quot;, &quot;3232&quot;, &quot;CH&quot;);\n      Console.WriteLine(p.City);\n      Console.WriteLine(p.ReturnBirthDate());</code></p>\n<p>Measuring the performance of it looks like that:</p>\n<p><code class=\"language-text\">using (var s = new SimpleStopWatch(&quot;Standard Test&quot;))\n{\n  tests.Standard.Test(s);\n}</code></p>\n<p>(Today) the code needs about 2ms in the first run, and about 1ms in subsequent runs. I say today, because yesterday the code was running a lot slower on the whole (e,g, 10ms in the first run). I am running it from the debugger, but all tests done have to live with that problem, which seems fair to me.</p>\n<p>What about DynamicProxy2? Here we need a slightly different setup:</p>\n<p><code class=\"language-text\">public void Test(SimpleStopWatch sw)\n{\n  ProxyGenerator gen = new ProxyGenerator(new DefaultProxyBuilder());\n  sw.Ping(&quot;After proxygen&quot;);\n  IHorridPerson p = gen.CreateInterfaceProxyWithTarget&lt;IHorridPerson&gt;(new HorridPerson(),\n    new SimpleInterceptor());\n  sw.Ping(&quot;After create class proxy&quot;);\n  p.AddAddress(&quot;Hurlistreet&quot;, &quot;Zürich&quot;, &quot;23&quot;, &quot;3232&quot;, &quot;CH&quot;);\n  sw.Ping();\n  Console.WriteLine(p.City);\n  sw.Ping();\n  Console.WriteLine(p.ReturnBirthDate()); \n}</code></p>\n<p>The interesting bits are at the beginning. It also shows one of the things one needs to have to create a proxy: The proxied class should implement an interface which we can use to talk to whatever implements said interface, or, in the case of DynamicProxy2, we can create a class whose members are all virtual. That way an inheriting class can override all members in a controllable fashion that does not resort to some kind of reflection.\nThe SimpleInterceptor is one that logs before and after invoking the object usage it is currently intercepting:</p>\n<p>`\nclass SimpleInterceptor : IInterceptor\n{</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">public void Intercept(IInvocation invocation)\n{\n  Console.WriteLine(&quot;Before proceed&quot;);\n  invocation.Proceed();\n  Console.WriteLine(&quot;After proceed&quot;);\n}</code></pre></div>\n<p>  }\n`</p>\n<p>The invocation holds all information about the current method call (e.g. Method Info, arguments, return value, etc.)</p>\n<p>Let's look straight at the output of the SimpleStopWatch:</p>\n<p><code class=\"language-text\">::STOPWATCH/Dynamicproxy Test - (0ms) - Starting\n::STOPWATCH/Dynamicproxy Test - (21ms) - After proxygen\n::STOPWATCH/Dynamicproxy Test - (212ms) - After create class proxy\nBefore proceed\nAdding address\nAfter proceed\n::STOPWATCH/Dynamicproxy Test - (215ms) - Intermediate output\nBefore proceed\nCalling city property\nAfter proceed\n::STOPWATCH/Dynamicproxy Test - (217ms) - Intermediate output\nBefore proceed\nReturning birthdate\nAfter proceed\n30.04.2008 23:23:43\n::STOPWATCH/Dynamicproxy Test - (220ms) - Ending</code></p>\n<p>And a second run, straight away:</p>\n<p><code class=\"language-text\">::STOPWATCH/Dynamicproxy Test - (0ms) - Starting\n::STOPWATCH/Dynamicproxy Test - (0ms) - After proxygen\n::STOPWATCH/Dynamicproxy Test - (57ms) - After create class proxy\nBefore proceed\nAdding address\nAfter proceed\n::STOPWATCH/Dynamicproxy Test - (58ms) - Intermediate output\nBefore proceed\nCalling city property\nAfter proceed\n::STOPWATCH/Dynamicproxy Test - (61ms) - Intermediate output\nBefore proceed\nReturning birthdate\nAfter proceed\n30.04.2008 23:23:43\n::STOPWATCH/Dynamicproxy Test - (64ms) - Ending</code></p>\n<p>One can see that we do pay for the usage of such a proxying scheme. While yesterday it looked a lot more extreme, the penalty today is still fairly high when comparing it to a normal object call. On the other hand, if the called methods actually do any meaningful work, the 3-4ms penalty per call may quickly dissipate. Also, it is quite apparent that once the proxy has been generated, it will be reused for other instances of the same type.</p>\n<p>Time is running out - Let us move swiftly to the Spring.AOP case. For brevity, just the first lines of the test case:\n<code class=\"language-text\">public void Test(SimpleStopWatch sw)\n{\n  ProxyFactory factory = new ProxyFactory(new HorridPerson());\n  sw.Ping(&quot;After factory&quot;);\n  factory.AddAdvice(new ConsoleLoggingAroundAdvice());\n  sw.Ping(&quot;After AddAdvice&quot;);\n  IHorridPerson p = (IHorridPerson)factory.GetProxy();\n  ...</code></p>\n<p>Looks slightly different and yet familiar...to make it complete here the \"Advice\":</p>\n<p><code class=\"language-text\">public class ConsoleLoggingAroundAdvice : IMethodInterceptor\n{\n  public object Invoke(IMethodInvocation invocation)\n  {\n    Console.Out.WriteLine(&quot;Advice executing; calling the advised method...&quot;);\n    object returnValue = invocation.Proceed();\n    Console.Out.WriteLine(&quot;Advice executed; advised method returned &quot; + returnValue);\n    return returnValue;\n  }\n}</code></p>\n<p>And finally  the output:</p>\n<p><code class=\"language-text\">::STOPWATCH/Spring Test - (0ms) - Starting\n::STOPWATCH/Spring Test - (144ms) - After factory\n::STOPWATCH/Spring Test - (148ms) - After AddAdvice\n::STOPWATCH/Spring Test - (225ms) - After GetProxy\nAdvice executing; calling the advised method...\nAdding address\nAdvice executed; advised method returned\n::STOPWATCH/Spring Test - (245ms) - Intermediate output\nAdvice executing; calling the advised method...\nCalling city property\nAdvice executed; advised method returned\n::STOPWATCH/Spring Test - (248ms) - Intermediate output\nAdvice executing; calling the advised method...\nReturning birthdate\nAdvice executed; advised method returned 30.04.2008 23:34:18\n30.04.2008 23:34:18\n::STOPWATCH/Spring Test - (252ms) - Ending</code></p>\n<p>And the second run straight away...</p>\n<p><code class=\"language-text\">::STOPWATCH/Spring Test - (0ms) - Starting\n::STOPWATCH/Spring Test - (0ms) - After factory\n::STOPWATCH/Spring Test - (0ms) - After AddAdvice\n::STOPWATCH/Spring Test - (1ms) - After GetProxy\nAdvice executing; calling the advised method...\nAdding address\nAdvice executed; advised method returned\n::STOPWATCH/Spring Test - (2ms) - Intermediate output\nAdvice executing; calling the advised method...\nCalling city property\nAdvice executed; advised method returned\n::STOPWATCH/Spring Test - (4ms) - Intermediate output\nAdvice executing; calling the advised method...\nReturning birthdate\nAdvice executed; advised method returned 30.04.2008 23:34:18\n30.04.2008 23:34:18\n::STOPWATCH/Spring Test - (9ms) - Ending</code></p>\n<p>The second one was already quite quick. Spring.Net beats Castle Windsor when it comes to wiring up the proxy. The penalties on the method/property invocations are quite comparable. Either way, that should not be the main driver when you choose to use those assemblies to perform what people like to call aspect-oriented programming. It would interest me why the aforementioned projects chose DanymicProxy2 over the Spring.AOP solution. Either way, usually it's a good thing to have a choice, it's not like we .NET folks are usually spoiled with it (Microsoft's closest thing to the subject is ContextBoundObject: You will run away...)</p>\n<p>The solution (VS2008) is attached as download, you will have to provide the references yourself. Enjoy.</p>\n<p>[1]: </p>","fields":{"slug":"/2008/04/30/spring-aop-castle-dynamicproxy2-first-glance-from-an-outsider"},"frontmatter":{"date":"April 30, 2008","path":null,"title":"Spring.AOP, Castle.DynamicProxy2 - first glance from an outsider","tags":["dotnet","libs-and-frameworks"]}}},"pageContext":{"title":"Spring.AOP, Castle.DynamicProxy2 - first glance from an outsider","previous":{"fields":{"slug":"/2008/04/29/singletons-are-boring-hence-factor-out-the-concern","published":true},"frontmatter":{"title":"Singletons are boring, hence factor out the concern","tags":["software-development","dotnet","patterns"],"date":"2008/04/29"}},"next":{"fields":{"slug":"/2008/05/04/is-it-alright-to-send-messages-to-null-references","published":true},"frontmatter":{"title":"Is it alright to send messages to null references?","tags":["software-development","dotnet","patterns"],"date":"2008/05/04"}}}}}