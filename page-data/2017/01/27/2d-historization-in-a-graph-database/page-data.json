{"componentChunkName":"component---src-templates-article-template-js","path":"/2017/01/27/2d-historization-in-a-graph-database","result":{"data":{"mdx":{"excerpt":"The  introduction to 2D-historization  dealt with the theory behind representing\nand reading state changes of your data in a model where we keep theâ€¦","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"2D-Historization in a graph database\",\n  \"layout\": \"post\",\n  \"tags\": [\"patterns\", \"programming\", \"neo4j\"],\n  \"date\": \"2017-01-27T07:00:00.000Z\",\n  \"topic\": \"neo-bitemp\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar TopicToc = makeShortcode(\"TopicToc\");\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(TopicToc, {\n    topicId: \"neo-bitemp\",\n    header: \"2D Historization series\",\n    mdxType: \"TopicToc\"\n  }), mdx(\"blockquote\", null, mdx(\"em\", null, \"Note:\"), \"This text assumes that you know a little bit about graph databases and Neo4J in particular. If you don't know Neo4J, please have a read at [Neo4J's documentation][1]\"), mdx(\"p\", null, \"The \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/2016/12/18/2d-or-bitemporal-historization-a-primer\"\n  }, \"introduction to 2D-historization\"), \" dealt with the theory behind representing\\nand reading state changes of your data in a model where we keep the time when\\nthe state change was recorded together with the actual time, the time where we want\\nthe state change to be applied in the context of whatever it is the application\\nis representing.\"), mdx(\"p\", null, \"My point of orientation when implementing 2D-historized data was Ian Robinson's\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://iansrobinson.com/2014/05/13/time-based-versioned-graphs/\"\n  }, \"post on time-based versioned graphs\")), mdx(\"p\", null, \"In here we find the following principles when representing data in the graph:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"We extract the immutable data about some entity into a single \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"node\"), \". This\\nwould typically be the data that uniquely identifies the entity. Under certain\\ncircumstances this may be just some id, but depending on your case, more data\\ncould be stored in that node\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Any data that can change over time is extracted to another node, attached\\nto the immutable one via a relationship that stores the \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"actual\"), \" and\\n\", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"recorded\"), \" time when the data node was created.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Repeat for any additional changes that are introduced to the entity.\")), mdx(\"p\", null, \"Here is some cypher to create an example:\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"sql\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-sql\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token keyword\"\n  }, \"CREATE\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"(\"), \"p:Person { id: \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token number\"\n  }, \"112245\"), \" }\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \")\"), \"\\n\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token keyword\"\n  }, \"CREATE\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"(\"), \"pd:PersonData { name: \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token string\"\n  }, \"'Joe Bloggs'\"), \" }\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \")\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"-\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"[\"), \":EXPANDS { recorded: \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token number\"\n  }, \"10\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \",\"), \" actual: \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token number\"\n  }, \"10\"), \"}\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"]\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"-\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \">\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"(\"), \"p\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \")\"), \"\\n\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token keyword\"\n  }, \"CREATE\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"(\"), \"pd2:PersonData { name: \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token string\"\n  }, \"'Joe Gonzalez'\"), \" }\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \")\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"-\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"[\"), \":EXPANDS { recorded: \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token number\"\n  }, \"20\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \",\"), \" actual: \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token number\"\n  }, \"30\"), \"}\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"]\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"-\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \">\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"(\"), \"p\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \")\")))), mdx(\"p\", null, \"Consider the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"actual\"), \" and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"recorded\"), \" values to be e.g. days since inception...\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/assets/2DHistory3.png\",\n    \"alt\": null\n  })), mdx(\"p\", null, \"The query to get the right history of PersonData changes is pretty straightforward:\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"text\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-text\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\"\n  }, \"MATCH (pd:PersonData)-[r]-(p) \\nWHERE p.id = 112245\\nAND r.recorded <= 30\\nRETURN r.recorded, r.actual, pd.name\\nORDER BY r.recorded DESC\"))), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"(assuming existence of only the EXPANDS relationship)\")), mdx(\"p\", null, \"However, we've previously seen that some entries may be cancelled out,\\ne.g. when you record a future state and later on you record a new state\\nthat will be valid before the previously recorded one.\"), mdx(\"p\", null, \"We can consider the following example:\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"text\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-text\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\"\n  }, \"CREATE (p:Person { id: 665544 })\\nCREATE (pd:PersonData { name: 'A. Brannigan' })-[:EXPANDS { recorded: 10, actual: 10}]->(p)\\nCREATE (pd2:PersonData { name: 'A. Durington' })-[:EXPANDS { recorded: 20, actual: 40}]->(p)\\nCREATE (pd3:PersonData { name: 'A. Lovegood' })-[:EXPANDS { recorded: 30, actual: 30}]->(p)\"))), mdx(\"p\", null, \"The logic how such state changes should be considered is explained\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/2016/12/18/2d-or-bitemporal-historization-a-primer\"\n  }, \"in the previous blog post\"), \". To recap:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"move backwards along the recorded time axis.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"add events to the history whose \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"actual\"), \" time lies before the last state\\ncollected\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"ignore those whose \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"actual\"), \" time lies beyond the last state collected.\")), mdx(\"p\", null, \"Can we express this in Cypher?\\nWell, it's not pretty, but it's possible\", mdx(\"sup\", null, \"*)\"), \":\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"text\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-text\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\"\n  }, \"MATCH (pd:PersonData)-[r]-(p) \\nWHERE p.id = 665544 AND r.recorded <= 30\\nWITH { data: pd, recorded: r.recorded, actual: r.actual } as data\\nWITH data ORDER BY data.recorded DESC\\nWITH reduce(relevant = [], d in collect(data) | \\nCASE \\nWHEN last(relevant) IS NULL OR d.actual < last(relevant).actual THEN relevant+d \\nELSE relevant END) \\nAS data\\nUNWIND data AS final \\nRETURN final.actual, final.data\"))), mdx(\"p\", null, \"Depending at which point in time you look at the state you now get two different\\nhistories:\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/assets/2DHistory4.png\",\n    \"alt\": null\n  })), mdx(\"p\", null, \"or\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/assets/2DHistory5.png\",\n    \"alt\": null\n  })), mdx(\"p\", null, \"What the query does is to \"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"identify the immutable node we are interested in and establish the data\\nwe will be considering\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"order it descending based on the recorded time \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"http://neo4j.com/docs/developer-manual/current/cypher/functions/list/#functions-reduce\"\n  }, \"reducing\"), \" the data, thereby rejecting those states that have been\\ncancelled by subsequent state entries.\")), mdx(\"p\", null, \"As is often the case with graphs, there are quite a few ways you can go about storing data\\nwith meaningful relationships. Other representations could be\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Putting the emphasis entering the queries purely through a point in time.\\nIn this case you could try and construct a representation with the help of\\na \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"http://graphaware.com/neo4j/2014/08/20/graphaware-neo4j-timetree.html\"\n  }, \"time tree\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Putting the emphasis on business transactions that summarize all\\nstate changes contained in said transaction.\")), mdx(\"p\", null, \"As usual with graphs, think in advance the kind of questions\\nyou will want to ask :)\"), mdx(\"p\", null, \"*)\\n\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Disclaimer: I am no cypher expert. The query expresses the logic outlined in the first blog post with some additional noise, some compaction may  still be possible.\")));\n}\n;\nMDXContent.isMDXComponent = true;","fields":{"slug":"/2017/01/27/2d-historization-in-a-graph-database"},"frontmatter":{"date":"2017-01-27","path":null,"title":"2D-Historization in a graph database","tags":["patterns","programming","neo4j"]}}},"pageContext":{"title":"2D-Historization in a graph database","previous":{"fields":{"slug":"/2017/01/18/an-outsiders-guide-to-gerrymandering","published":true},"frontmatter":{"title":"An outsider's guide to gerrymandering","tags":["loosely-coupled","mathematics"],"date":"2017/01/18"}},"next":{"fields":{"slug":"/2017/01/30/simplify-the-bitemporal-neo4j-query-with-a-user-defined-function","published":true},"frontmatter":{"title":"Simplify the bitemporal Neo4J query with a user-defined function","tags":["programming","neo4j","java"],"date":"2017/01/30"}}}},"staticQueryHashes":["256249292","2581731408"]}