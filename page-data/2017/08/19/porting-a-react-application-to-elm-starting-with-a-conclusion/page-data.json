{
    "componentChunkName": "component---src-templates-article-template-js",
    "path": "/2017/08/19/porting-a-react-application-to-elm-starting-with-a-conclusion",
    "result": {"data":{"mdx":{"excerpt":"As I threatened  over here , my main aim in writing the morse learning app  \"remorse\"  was to have a baseline to which I can compare ports to otherâ€¦","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"'Porting' a react application to elm - starting with a conclusion\",\n  \"layout\": \"post\",\n  \"tags\": [\"programming\", \"web\", \"react\"],\n  \"date\": \"2017-08-19T21:00:00.000Z\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"As I threatened \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/2017/07/26/react-redux-in-a-real-application-prelude\"\n  }, \"over here\"), \", my main aim in writing the morse learning app \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://realfiction.net/remorse\"\n  }, \"\\\"remorse\\\"\"), \" was to have a baseline to which I can compare ports to other languages. Now that I have \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/flq/elmorse\"\n  }, \"done the port\"), \" towards \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://elm-lang.org\"\n  }, \"elm\"), \"*), I would like to start with a conclusion and only in later posts do some direct comparisons between solutions.\"), mdx(\"p\", null, \"When you have developed an application based on react and redux, you know a little bit of what's coming to you in terms of how the UI is the source of messages, which changes the application state as well as triggers activities.\"), mdx(\"p\", null, \"You will find those architectural components again in elm albeit assembled into a more stringent form.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The UI raises a message\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"This message must be handled in an update function.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Handling the message, you return a tuple that contains\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The desired mutation of the application state, if any\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A desired Command to be executed which may produce a new message, if any\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"After which the UI is rendered with the new state\")), mdx(\"p\", null, \"If you happen to have written all your UI as functions in react (which actually happened in remorse without me really aiming for it), you are already in a good mindset to get into elm, since views in elm are pure in that they cannot depend on any sort of \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"internal state\"), \" but only depend on their input.\"), mdx(\"p\", null, \"Elm's rampup is quite excellent and you will be up and running in a short amount of time. I have been developing in vs code with the elm plugin by Sascha Brink, which provides some basic support to display compiler errors in place and helps you a little bit in auto-completion, etc. Granted, considering the static typing nature of elm, more could be done in this area.\"), mdx(\"h3\", null, \"Elm loves refactoring\"), mdx(\"p\", null, \"What I did wrong in a previous experiment but got right this time is to \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"not overthink your solution\"), \". That is, start messing around in \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Main.elm\"), \" and when you feel like you have to refactor, do it then. If you have a working application, refactoring in elm is quite straightfoward and when your pieces compile again, the chances of it also working again are pretty high.\"), mdx(\"h3\", null, \"Right now, I don't like the Haskell-inspired code formatting\"), mdx(\"p\", null, \"This is the standard formatting\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"text\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-text\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\"\n  }, \"ul [class \\\"grocery-list\\\"]\\n  [ li [] [text \\\"Pamplemousse\\\"]\\n  , li [] [text \\\"Ananas\\\"]\\n  , li [] [text \\\"Jus d'orange\\\"]\\n  ]\"))), mdx(\"p\", null, \"Right now I'm doing this.\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"sql\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-sql\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"ul \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"[\"), \"class \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token string\"\n  }, \"\\\"grocery-list\\\"\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"]\"), \"\\n\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"[\"), \" \\n  li \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"[\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"]\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"[\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token keyword\"\n  }, \"text\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token string\"\n  }, \"\\\"Pamplemousse\\\"\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"]\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \",\"), \"\\n  li \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"[\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"]\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"[\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token keyword\"\n  }, \"text\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token string\"\n  }, \"\\\"Ananas\\\"\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"]\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \",\"), \"\\n  li \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"[\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"]\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"[\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token keyword\"\n  }, \"text\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token string\"\n  }, \"\\\"Jus d'orange\\\"\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"]\"), \"\\n\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"]\")))), mdx(\"p\", null, \"If I wasn't working alone, I would have to adapt, and at the end of the day, formatting is only so important, but I sure don't like it.\"), mdx(\"h3\", null, \"Json Encode/Decode I don't even\"), mdx(\"p\", null, \"When I first encountered how json must be handled in Elm I was fairly disappointed. If I have defined some type, it would be great to be able to use exactly that information that I have already distilled into said type to be able to get an instance from json or the other way round. However, you will have to define encoders and decoders to perform the feat of moving to / from json.\"), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://tech.noredink.com/post/164185230948/decoding-decoders\"\n  }, \"This post\"), \", however, reminded me, that this step will lead you to develop your serialization models independently from your application types (if it's not clear what I'm saying, have a read through the post). My first attempt to let the user store the current state was to store the complete model, because in javascript it is a no-brainer to store a javascript object like that. This was an uphill battle. The next approach, checking what exactly I need to store and then map the values into the structure to store the data to json, felt much better and more productive.\"), mdx(\"h3\", null, \"Elm is opinionated\"), mdx(\"p\", null, \"Elm gives you very clear guidance on how your application works. It is clear on how you do view changes, how you perform actions and how outside data enters your application. It has an opinion on how to do json and beyond the code, it has clear opinions on how to advance the language and its ecosystem. If you approve of those opinions you should be in for a smooth ride.\"), mdx(\"p\", null, \"--\\n*) Without the trainings evaluation and charts for now\"));\n}\n;\nMDXContent.isMDXComponent = true;","fields":{"slug":"/2017/08/19/porting-a-react-application-to-elm-starting-with-a-conclusion"},"frontmatter":{"date":"2017-08-19","path":null,"title":"'Porting' a react application to elm - starting with a conclusion","tags":["programming","web","react"]}}},"pageContext":{"title":"'Porting' a react application to elm - starting with a conclusion","previous":{"fields":{"slug":"/2017/07/29/ms-asp-net-mvc-certification-course-vs-asp-net-core","published":true},"frontmatter":{"title":"MS ASP.NET MVC Certification course vs ASP.NET core","tags":["web","programming","dotnet"],"date":"2017/07/29"}},"next":{"fields":{"slug":"/2017/08/21/react-redux-to-elm-feature-comparison-playing-morse-sounds","published":true},"frontmatter":{"title":"react/redux to elm feature comparison: playing morse sounds","tags":["web","programming","javascript"],"date":"2017/08/21"}}}},
    "staticQueryHashes": ["256249292","2581731408"]}