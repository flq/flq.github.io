{"componentChunkName":"component---src-templates-article-template-js","path":"/2010/09/06/membus-a-more-complex-rich-client-setup","result":{"data":{"markdownRemark":{"html":"<p>Let us consider a more complex Bus setup in order to understand the capabilities of the different parts of the infrastructure:</p>\n<p> <img src=\"/assets/image_7337b070-7353-4041-bb93-87aca8327ca8.png\" alt=\"image\" title=\"image\"> </p>\n<p>What are we expressing here?</p>\n<ul>\n<li>Publishing is configured</li>\n<li>If a message of type Transport is published, use the Sequential publisher</li>\n<li>If a message type ends with “Request” in its name, publish a message of type Transport as constructed and use the non blocking publisher for the Request message.</li>\n<li>If a message type ends with “Response” in its name, publish it in the parallel blocking fashion, then an instance of type Transport as shown.*   Subscriptions are configured </li>\n</ul>\n<p>This is an example where you perform Requests with messages that may be long running: They are published and the UI would have to wait until a “Response” becomes available. The Transport-messages mark those cycles such that a UI can use them in a general form to provide feedback to the user that something is happening.</p>","fields":{"slug":"/2010/09/06/membus-a-more-complex-rich-client-setup"},"frontmatter":{"date":"September 06, 2010","path":null,"title":"MemBus: A more complex rich client setup","tags":["software-development","dotnet","patterns","membus"]}}},"pageContext":{"title":"MemBus: A more complex rich client setup","previous":{"fields":{"slug":"/2010/09/02/introducing-membus-construction-variants","published":true},"frontmatter":{"title":"Introducing MemBus: Construction Variants","tags":["csharp","membus"],"date":"2010/09/02"}},"next":{"fields":{"slug":"/2010/09/08/membus-performance-considerations","published":true},"frontmatter":{"title":"Membus: Performance considerations","tags":["software-development","patterns","csharp","membus"],"date":"2010/09/08"}}}}}