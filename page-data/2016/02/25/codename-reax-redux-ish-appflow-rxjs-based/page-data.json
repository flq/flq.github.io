{"componentChunkName":"component---src-templates-article-template-js","path":"/2016/02/25/codename-reax-redux-ish-appflow-rxjs-based","result":{"data":{"mdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"codename reax - redux-ish appflow, rxjs-based\",\n  \"layout\": \"post\",\n  \"tags\": [\"own-software\", \"javascript\", \"libs-and-frameworks\", \"react\"],\n  \"date\": \"2016-02-25T14:00:00.000Z\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"I have to admit: I have not done much \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/reactjs/redux\"\n  }, \"redux\"), \" yet. My colleague has and I was able to help him at times and look over his shoulder. Redux is possibly the (\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"currently\"), \") most popular implementation of the pattern coined as \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Flux\"), \" by facebook. I wouldn't be surprised if people would call it reactive loop or something along those lines. At least you'll see me using this term ;)\"), mdx(\"p\", null, \"Whatever implementation you use, they will have in common the way in which the UI informs about user actions, a place to act upon those actions and a place to modify some kind of state which dictates the data and state of the UI on the next render pass.\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"text\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-text\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\"\n  }, \"UI -> dispatch(a : Action) -> **logic e.g. in Stores etc.** -> New State -> UI\"))), mdx(\"p\", null, \"I have been a big friend of the concept of Observables and the utilities built around them in the form of the Rx libraries since I got to know it on .NET. In js we get the functionality via \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/Reactive-Extensions/RxJS\"\n  }, \"rxjs\"), \".\"), mdx(\"p\", null, \"For some time I wanted to see how I could use the power of observables to get a reactive loop going. I wanted to end up with the basic notion of an \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"application function\"), \" which has the following signature:\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"text\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-text\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\"\n  }, \"(state, action) -> new state\"))), mdx(\"p\", null, \"I have been working irregularly towards a prototype, at the end it got quite a bit more polished than that. You can find the current results at the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"a\", {\n    parentName: \"strong\",\n    \"href\": \"https://github.com/flq/reax\"\n  }, \"reax repository at github\")), \".\"), mdx(\"p\", null, \"The core of the idea is that there is a state observable as well as an action observable.\"), mdx(\"p\", null, \"These two observables are zipped together and the resulting return value is fed back onto the state observable.\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"text\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-text\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\"\n  }, \"var allSyncStates = map(app.appFuncs, (appFunc) => {\\n  return actionObservable\\n    .filter(createAppFuncFilter(appFunc.selector))\\n    .withLatestFrom(stateObservable,\\n      (action, state) => { return { state, action } })\\n    .map(wrapFuncWithErrorDispatch(appFunc.func, additionalContext));\\n});\"))), mdx(\"p\", null, \"This is one of the hearts of the whole reax loop. Whenever a dispatch occurs (e.g. from within the UI), the action observable will produce a new element. It will be filtered depending on the action type (\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"simply its type property\"), \") and then zipped with the latest element from the state observable. That is the one that provides the sequence of state changes, and to which e.g. react components are subscribed.\"), mdx(\"p\", null, \"This zipping together happens for all application functions that you provide. Due to the way how action and state are joined and due to the call within the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"map\"), \" of the resulting observable, we can provide functions with exactly the signature I was desiring.\"), mdx(\"p\", null, \"Since we now have as many state observables as application functions, we need to merge them together. Thanks to rxjs, a straightforward operation:\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"text\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-text\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\"\n  }, \"const stateStream = Observable.merge(allSyncStates.concat(allAsyncStates));\"))), mdx(\"p\", null, \"The async state providers need to be treated differently. Hence, the application functions are also treated differently, but they are allowed to return a promise which will eventually provide a state.\"), mdx(\"p\", null, \"To mitigate some of the problems that result in having functions providing state possibly after some other action may already have changed the state, the state parameter to the application functions is not the state object, but a function providing the state object.\"), mdx(\"p\", null, \"An additional change for convenience was to allow application functions the access to the dispatcher function with which new actions can be dispatched. This makes for the nice signature:\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"text\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-text\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\"\n  }, \"(s, a, d) => ... //State, Action, Dispatcher\"))), mdx(\"p\", null, \"A logical progression for this project is the ability to dispatch Observables that will produce actions:\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"text\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-text\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\"\n  }, \"d(Observable\\n  .timer(200,200)\\n  .take(COUNTER_START - s().counter)\\n  .map(_ => ({ type: 'tick', increment: -1 })));\"))), mdx(\"p\", null, \"Finally there is the Observables-speciality that once an exception is thrown in some running observable, that particular instance is dead. There are ways to pick up but the easiest in the context of reax is to catch any exceptions arising from an application function and feed them back into the reactive loop in the form of an action with the type being \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"\\\"error\\\"\"), \" (See \", mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"wrapFuncWithErrorDispatch\"), \" above).\"), mdx(\"p\", null, \"The first level of the API follows the builder pattern. It allows to\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"set the initial state\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"add application functions (sync and async)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"add action sources (observables whose output will be dispatched as actions)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"add state refiners: methods with the signature s => s, which allow you to look at the state resulting from the call of application functions, possibly refine it, or simply monitor it.\")), mdx(\"p\", null, \"Here's an example from a test:\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"text\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-text\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\"\n  }, \"const app = appBuilder()\\n  .addAppFunc('foo', (s,a) => ({ count: s().count + 1 }))\\n  .addStateRefinement(s => ({ count: s.count * 2 }))\\n  .setInitialState({ count: 1 })\\n  .build();\\n\\nlet {dispatchAction,getCurrentState} = appInit(app);\\ndispatchAction(fooAct);\\n// s1 (1) -> refine -> s2 (2) -> foo -> s3 (3) -> refine -> s4 (6)\\nassert.equal(getCurrentState().count, 6);\"))), mdx(\"p\", null, \"The second level of the API provides the possibility to pass in functions to the builder based on conventions. Here you have a very simple undo module that will work.\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"text\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-text\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\"\n  }, \"function undoApp() {\\n\\n  const stateStack = [];\\n\\n  return {\\n    onUndo(s,a,d) {\\n      stateStack.pop(); // current\\n      var last = stateStack.pop();\\n      return last;\\n    },\\n    monitorState(s) {\\n      stateStack.push(s);\\n    }\\n  }\\n}\\n\\nconst app = appBuilder()\\n  .addApp(undoApp)\\n  .build();\"))), mdx(\"p\", null, \"The conventions are summarized quickly:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Any function beginning with \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"\\\"on\\\"\"), \", the remaining name will be camel-cased and the function will be registered for actions whose type-property equal the camel-cased name (\", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"onUndo -> undo\"), \").\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Any function that starts with \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"\\\"refine\\\"\"), \" or \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"\\\"monitor\\\"\"), \" will be registered as a state refiner.\")), mdx(\"p\", null, \"Up to here we have no dependency to React (much like redux), but rather a way to listen to actions/messages and pushing changes to a tracked state object.\"), mdx(\"p\", null, \"The second part of the project is heavily inspired by Redux in that we have\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A Connector React-component that is the home of the \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"app\"), \" as constructed by the app builder and which makes sure that the state changes are communicated to the React API.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A connect method that can be called on React components and provides them access to the dispatch function and which allows to influence what kind of state the connected component gets to see. The code used here really is a copy of the \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://github.com/reactjs/react-redux\"\n  }, \"react-redux\"), \" code, stripped of code which I assume to be hardening :)\")), mdx(\"p\", null, \"A more complete example, inspired by the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://www.infoq.com/articles/no-more-mvc-frameworks\"\n  }, \"launch\"), \" \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://bitbucket.org/snippets/jdubray/9dgKp/sa-sample\"\n  }, \"example\"), \" provided by \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Jean-Jacques Dubray\"), \" can be found \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/flq/reax/blob/master/samples/launch.js\"\n  }, \"here\"), \".\"), mdx(\"p\", null, \"Other things I would have to look at before I would say that this is definitely useful...\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Support for async app funcs, action providers and initial state in the high-level API.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Support for a mount point for application functions belonging together (i.e. only seeing / updating a branch of the tree.)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Looking into a compatibility layer to redux-based projects \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"(wouldn't it be nice to be able to use redux forms while still using reax for the reactive loop?)\"))), mdx(\"p\", null, \"All in all I am relatively happy with the result. What I like is that the Observable powers are usually never too far away to be used. I am also happy with the way the reactive loop is set up, something that I find a little bit more daunting than it should be in redux. Lately I have been wondering whether the state that is used to render the UI is nothing more than a glorified global variable, but I suppose that this is a different story that should be told at another time.\"));\n}\n;\nMDXContent.isMDXComponent = true;","fields":{"slug":"/2016/02/25/codename-reax-redux-ish-appflow-rxjs-based"},"frontmatter":{"date":"2016-02-25","path":null,"title":"codename reax - redux-ish appflow, rxjs-based","tags":["own-software","javascript","libs-and-frameworks","react"]}}},"pageContext":{"title":"codename reax - redux-ish appflow, rxjs-based","previous":{"fields":{"slug":"/2016/02/09/up-a-free","published":true},"frontmatter":{"title":"Up a Free","tags":["fsharp"],"date":"2016/02/09"}},"next":{"fields":{"slug":"/2016/02/28/on-the-fractal-nature-of-effort-estimates","published":true},"frontmatter":{"title":"On the fractal nature of effort estimates","tags":["software-development"],"date":"2016/02/28"}}}},"staticQueryHashes":["256249292","2581731408"]}