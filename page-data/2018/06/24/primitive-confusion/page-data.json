{"componentChunkName":"component---src-templates-article-template-js","path":"/2018/06/24/primitive-confusion","result":{"data":{"mdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Primitive Confusion\",\n  \"layout\": \"post\",\n  \"tags\": [\"programming\", \"fsharp\", \"csharp\"],\n  \"date\": \"2018-06-23T22:00:00.000Z\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"My last post on primitive obsession has been \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/2015/12/30/nmeasure-and-the-global-warming\"\n  }, \"a while ago\"), \", whose predecessor is \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/2010/11/30/dealing-with-primitive-obsession-this-time-measurements\"\n  }, \"even older\"), \".\"), mdx(\"p\", null, \"Primitives are still bad. The following illustrative code just happened to me two days ago (it didn't reach production, but hey):\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"csharp\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-csharp\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token keyword\"\n  }, \"public\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token keyword\"\n  }, \"class\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token class-name\"\n  }, \"Program\"), \"\\n\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"{\"), \"\\n\\t\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token keyword\"\n  }, \"public\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token keyword\"\n  }, \"static\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token return-type class-name\"\n  }, mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"token keyword\"\n  }, \"string\")), \" UserId \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"=>\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token string\"\n  }, \"\\\"u-123\\\"\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \";\"), \"\\n\\t\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token keyword\"\n  }, \"public\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token keyword\"\n  }, \"static\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token return-type class-name\"\n  }, mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"token keyword\"\n  }, \"string\")), \" ProductId \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"=>\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token string\"\n  }, \"\\\"p-abc\\\"\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \";\"), \"\\n\\t\\n\\t\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token keyword\"\n  }, \"public\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token keyword\"\n  }, \"static\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token return-type class-name\"\n  }, mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"token keyword\"\n  }, \"void\")), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token function\"\n  }, \"Order\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"(\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token class-name\"\n  }, mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"token keyword\"\n  }, \"string\")), \" userId\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \",\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token class-name\"\n  }, mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"token keyword\"\n  }, \"string\")), \" productId\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \")\"), \"\\n\\t\\t\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"=>\"), \" System\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \".\"), \"Console\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \".\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token function\"\n  }, \"WriteLine\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"(\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token interpolation-string\"\n  }, mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"token string\"\n  }, \"$\\\"User \"), mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"token interpolation\"\n  }, mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"token punctuation\"\n  }, \"{\"), mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"token expression language-csharp\"\n  }, \"userId\"), mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"token punctuation\"\n  }, \"}\")), mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"token string\"\n  }, \" ordered \"), mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"token interpolation\"\n  }, mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"token punctuation\"\n  }, \"{\"), mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"token expression language-csharp\"\n  }, \"productId\"), mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"token punctuation\"\n  }, \"}\")), mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"token string\"\n  }, \"\\\"\")), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \")\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \";\"), \"\\n\\t\\n\\t\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token keyword\"\n  }, \"public\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token keyword\"\n  }, \"static\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token return-type class-name\"\n  }, mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"token keyword\"\n  }, \"void\")), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token function\"\n  }, \"Main\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"(\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \")\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"=>\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token function\"\n  }, \"Order\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"(\"), \"ProductId\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \",\"), \" UserId\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \")\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \";\"), \"\\n\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"}\")))), mdx(\"p\", null, \"See the problem? Because we are the dealing with ids as strings, the compiler can't help us when we use APIs the wrong way. When you use the API correctly in unit tests it so can happen that confusing such IDs may only turn up in integration or, as the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"very last resort\"), \", production.\"), mdx(\"p\", null, \"The same mistake can happen to us in other languages, too. Here's the example in F#:\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"fsharp\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-fsharp\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-fsharp\"\n  }, mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token keyword\"\n  }, \"let\"), \" getUserId \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"=\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token string\"\n  }, \"\\\"u-123\\\"\"), \"\\n\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token keyword\"\n  }, \"let\"), \" getProductId \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"=\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token string\"\n  }, \"\\\"p-ABC\\\"\"), \"\\n\\n\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token keyword\"\n  }, \"let\"), \" order userId productId \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"=\"), \" \\n    printfn \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token string\"\n  }, \"\\\"user %s orders %s\\\"\"), \" userId productId\\n\\n\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token annotation\"\n  }, mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"token punctuation\"\n  }, \"[<\"), mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"token class-name\"\n  }, \"EntryPoint\"), mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"token punctuation\"\n  }, \">]\")), \"\\n\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token keyword\"\n  }, \"let\"), \" main argv \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"=\"), \"\\n    order getProductId getUserId\\n    \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token number\"\n  }, \"0\")))), mdx(\"p\", null, \"The compiler happily does its job, no surprises. Obviously I chose F# as second example for a reason. Here, the barrier to type even singular primitives to provide improved compile time safety is considerably lower. Enter \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://fsharpforfunandprofit.com/posts/discriminated-unions/\"\n  }, mdx(\"strong\", {\n    parentName: \"a\"\n  }, \"Discriminated Unions\")), \".\"), mdx(\"p\", null, \"They are something like the crack of type-safe pattern matching, or state representations on steroids or whatever you like to call them. Let's use them in our example:\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"fsharp\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-fsharp\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-fsharp\"\n  }, mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token keyword\"\n  }, \"type\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token class-name\"\n  }, \"UserId\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"=\"), \" UserId \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token keyword\"\n  }, \"of\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token class-name\"\n  }, \"string\"), \"\\n\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token keyword\"\n  }, \"type\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token class-name\"\n  }, \"ProductId\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"=\"), \" ProductId \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token keyword\"\n  }, \"of\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token class-name\"\n  }, \"string\"), \"\\n\\n\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token keyword\"\n  }, \"let\"), \" getUserId \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"=\"), \" UserId \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token string\"\n  }, \"\\\"u-123\\\"\"), \"\\n\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token keyword\"\n  }, \"let\"), \" getProductId \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"=\"), \" ProductId \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token string\"\n  }, \"\\\"p-ABC\\\"\"), \"\\n\\n\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token keyword\"\n  }, \"let\"), \" order \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"(\"), \"UserId userId\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \")\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"(\"), \"ProductId productId\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \")\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"=\"), \"\\n    printfn \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token string\"\n  }, \"\\\"user %s orders %s\\\"\"), \" userId productId\\n\\n\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token annotation\"\n  }, mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"token punctuation\"\n  }, \"[<\"), mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"token class-name\"\n  }, \"EntryPoint\"), mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"token punctuation\"\n  }, \">]\")), \"\\n\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token keyword\"\n  }, \"let\"), \" main argv \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"=\"), \"\\n    order getUserId getProductId\\n    \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token number\"\n  }, \"0\")))), mdx(\"p\", null, \"In this case the \", mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"userId\"), \" and \", mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"productId\"), \"are still essentially strings, but you can only get at them by acknowledging the type that is guarding those primitive values. It is hard to conceive and even smaller encoding of semantics with regard to some primitive value, which is why I highly approve of this use case of discriminated unions and often miss them in C#.\"));\n}\n;\nMDXContent.isMDXComponent = true;","fields":{"slug":"/2018/06/24/primitive-confusion"},"frontmatter":{"date":"June 23, 2018","path":null,"title":"Primitive Confusion","tags":["programming","fsharp","csharp"]}}},"pageContext":{"title":"Primitive Confusion","previous":{"fields":{"slug":"/2018/06/10/typescript-type-shenanigans-conditional-types","published":true},"frontmatter":{"title":"Typescript type shenanigans: Conditional Types","tags":["programming","typescript","react"],"date":"2018/06/10"}},"next":{"fields":{"slug":"/2018/12/30/from-jekyll-to-gatsby","published":true},"frontmatter":{"title":"From Jekyll to Gatsby","tags":["meta","web"],"date":"2018/12/30"}}}},"staticQueryHashes":["256249292","2581731408","3764592887"]}