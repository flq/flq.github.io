---
title: "The no frills, bare-bones example to Duplex WCF"
layout: post
tags: download dotnet TrivadisContent WCF
date: 2008-01-30 15:51:35
redirect_from: "/go/113"
---

Can a WCF client call a WCF service and have the server call back with whatever? Oh, yes. Can you get an example how it's done? Indeed.

Are these good examples? Well, you can get [MS samples for WCF](http://www.microsoft.com/downloads/thankyou.aspx?familyId=2611a6ff-fd2d-4f5b-a672-c002f1c09ccd&amp;displayLang=en) (which in their entirety are really helpful) or [another blog post](http://dotnetaddict.dotnetdevelopersjournal.com/wcf_alarmclock.htm) on the subject. Don't get me wrong, they work, but in my humble opinion they have shortcomings.

*   They have funny classes and interfaces generated by svcutil with some really horrid artefacts  <li>The interfaces are not shared among client &amp; server which annoys my desire for harmony and DRYness, which should be followed even in an example (or, maybe, especially in an example). 

Anyway, here's my version, which is quite reduced to just the duplex stuff.

## Common bits
 <div style="padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px" id="scid:812469c5-0cb0-4c63-8c15-c81123a09de7:b84e0aa5-f624-4b9f-8a90-5bc11903d60c" class="wlWriterEditableSmartContent"><pre name="code" class="c#">[ServiceContract(Namespace = "rf.services", 
   CallbackContract = typeof(IDataOutputCallback), 
   SessionMode = SessionMode.Required)]
  public interface IServerWithCallback
  {
      [OperationContract(IsOneWay=true)]
      void StartDataOutput();
  }
</pre></div>

That's the Server interface which the client will use to talk to the server. Please note the _CallBackContract _property of the _ServiceContract _attribute. That's the interface that will have to be implemented by the client. The server will use it to call back.
`public interface IDataOutputCallback { [OperationContract(IsOneWay = true)] void SendDataPacket(string data); } `

All this _IsOneWay _business is one way to avoid issues when you're calling back a client within the method that is being called by the client. The issues are described [here](http://www.codeproject.com/KB/WCF/WCF_Duplex_UI_Threads.aspx).

## Server

Of course we need an implementation of the service (doh): 

<div style="padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px" id="scid:812469c5-0cb0-4c63-8c15-c81123a09de7:b65716d2-8495-4776-a1f2-630422a9d87f" class="wlWriterEditableSmartContent"><pre name="code" class="c#">class ServerWCallbackImpl : IServerWithCallback { 
  #region IServerWithCallback Members 
  public void StartDataOutput() { 
    IDataOutputCallback callback = OperationContext.Current.GetCallbackChannel&lt;IDataOutputCallback&gt;(); 
    for (int i = 0; i &lt; 10; i++) { 
      Random r = new Random(); 
      int interval = r.Next(500,3000); 
      System.Threading.Thread.Sleep(interval); 
      callback.SendDataPacket("Packet " + i.ToString()); 
    } 
    callback.SendDataPacket("Last packet is this one :)"); 
  }
  #endregion 
}</pre></div>The important line is the very first one. The rest is just a crappy example to get some funny callback side-effects. Next we have the configuration of the thing...

<div style="padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px" id="scid:812469c5-0cb0-4c63-8c15-c81123a09de7:20c9e10e-13a4-4233-9ef8-d55f0f58b45a" class="wlWriterEditableSmartContent"><pre name="code" class="xml">&lt;system.serviceModel&gt;
    &lt;services&gt;
      &lt;service name="ServerPart.ServerWCallbackImpl"&gt;
        &lt;endpoint address="net.tcp://localhost:9080/DataService" binding="netTcpBinding"
            bindingConfiguration="" name="DataEndpoint" contract="CommonParts.IServerWithCallback" /&gt;
      &lt;/service&gt;
    &lt;/services&gt;
&lt;/system.serviceModel&gt;
</pre></div>

And some boilerplate to get it running e.g. in a command-line:

<div style="padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px" id="scid:812469c5-0cb0-4c63-8c15-c81123a09de7:db170c66-f040-4556-a162-e181781df1cf" class="wlWriterEditableSmartContent"><pre name="code" class="c#">ServiceHost svc = new ServiceHost(typeof(ServerWCallbackImpl)); 
svc.Open(); 
Console.WriteLine("Listening according to configuration"); 
Console.ReadKey(); 
</pre></div>

If you want to save yourself the configuration etry in the app.config file, you can also set up the ServiceHost programmatically:
<pre class="sh_csharp">  ServiceHost duplex = new ServiceHost(typeof(ServerWCallbackImpl)); 
  duplex.AddServiceEndpoint(typeof(IServerWithCallback), new NetTcpBinding(), "net.tcp://localhost:9080/DataService"); 
  duplex.Open(); 
</pre>

## Client

Want to call the server? Well, first you could go and configure it:

<div style="padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px" id="scid:812469c5-0cb0-4c63-8c15-c81123a09de7:f785f17a-1924-4386-a48d-1924162cfc1a" class="wlWriterEditableSmartContent"><pre name="code" class="xml">&lt;system.serviceModel&gt;
    &lt;client&gt;
      &lt;endpoint address="net.tcp://localhost:9080/DataService" binding="netTcpBinding"
            bindingConfiguration="" contract="CommonParts.IServerWithCallback" name="Callback"&gt;
      &lt;/endpoint&gt;
    &lt;/client&gt;
&lt;/system.serviceModel&gt;</pre></div>

Then it'll make sense to provide an implementation of the Callback interface:

<div style="padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px" id="scid:812469c5-0cb0-4c63-8c15-c81123a09de7:821149d6-1c75-43d6-8aff-a235f7d28cea" class="wlWriterEditableSmartContent"><pre name="code" class="c#">class CallbackImpl : IDataOutputCallback { 
  #region IDataOutputCallback Members 
  public void SendDataPacket(string data) { 
    Console.WriteLine(data); } #endregion 
  } </pre></div>

Brill! Finally the boilerplate to kickstart the thing:

<div style="padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px" id="scid:812469c5-0cb0-4c63-8c15-c81123a09de7:5bcc92ac-b84a-450f-8b87-678b9f5c4f2e" class="wlWriterEditableSmartContent"><pre name="code" class="c#">DuplexChannelFactory&lt;IServerWithCallback&gt; cf = new DuplexChannelFactory&lt;IServerWithCallback&gt;( new CallbackImpl(), "Callback"); 
IServerWithCallback srv = cf.CreateChannel(); 
srv.StartDataOutput(); 
</pre></div>

Again, if you prefer working without a configuration entry, you can set this up programmatically, too:

<div style="padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px" id="scid:812469c5-0cb0-4c63-8c15-c81123a09de7:29ed4d5a-dce3-417b-9f63-f724d2a1fda0" class="wlWriterEditableSmartContent"><pre name="code" class="c#">DuplexChannelFactory&lt;IServerWithCallback&gt; cf = new DuplexChannelFactory&lt;IServerWithCallback&gt;(
  new CallbackImpl(), new NetTcpBinding(), new EndpointAddress("net.tcp://localhost:9080/DataService")); </pre></div>

That's it, you shouldn't need more, honest, dude. No generated class in sight, all interfaces are the same throughout Client and Server. Distribute over projects/threads/app domains at your leisure and enjoy.

**Update**: There is a small vs2008 solution attached below that shows the programmatic setup of this blog post.